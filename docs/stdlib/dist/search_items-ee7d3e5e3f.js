searchNodes=[{"ref":"array.html","title":"array","type":"module","doc":"Functional, extendible arrays. Arrays can have fixed size, or can grow automatically as needed. A default value is used for entries that have not been explicitly set. Arrays uses zero-based indexing. This is a deliberate design choice and differs from other Erlang data structures, for example, tuples. Unless specified by the user when the array is created, the default value is the atom undefined. There is no difference between an unset entry and an entry that has been explicitly set to the same value as the default one (compare reset/2). If you need to differentiate between unset and set entries, ensure that the default value cannot be confused with the values of set entries. The array never shrinks automatically. If an index I has been used to set an entry successfully, all indices in the range [0,I] stay accessible unless the array size is explicitly changed by calling resize/2. Examples: Create a fixed-size array with entries 0-9 set to undefined: A0 = array:new(10). 10 = array:size(A0). Create an extendible array and set entry 17 to true, causing the array to grow automatically: A1 = array:set(17, true, array:new()). 18 = array:size(A1). Read back a stored value: true = array:get(17, A1). Accessing an unset entry returns default value: undefined = array:get(3, A1) Accessing an entry beyond the last set entry also returns the default value, if the array does not have fixed size: undefined = array:get(18, A1). &quot;Sparse&quot; functions ignore default-valued entries: A2 = array:set(4, false, A1). [{4, false}, {17, true}] = array:sparse_to_orddict(A2). An extendible array can be made fixed-size later: A3 = array:fix(A2). A fixed-size array does not grow automatically and does not allow accesses beyond the last set entry: {&#39;EXIT&#39;,{badarg,_}} = (catch array:set(18, true, A3)). {&#39;EXIT&#39;,{badarg,_}} = (catch array:get(18, A3))."},{"ref":"array.html#default/1","title":"array.default/1","type":"function","doc":"Gets the value used for uninitialized entries. See also new/2."},{"ref":"array.html#fix/1","title":"array.fix/1","type":"function","doc":"Fixes the array size. This prevents it from growing automatically upon insertion. See also set/3 and relax/1."},{"ref":"array.html#foldl/3","title":"array.foldl/3","type":"function","doc":"Folds the array elements using the specified function and initial accumulator value. The elements are visited in order from the lowest index to the highest. If Function is not a function, the call fails with reason badarg. See also foldr/3, map/2, sparse_foldl/3."},{"ref":"array.html#foldr/3","title":"array.foldr/3","type":"function","doc":"Folds the array elements right-to-left using the specified function and initial accumulator value. The elements are visited in order from the highest index to the lowest. If Function is not a function, the call fails with reason badarg. See also foldl/3, map/2."},{"ref":"array.html#from_list/1","title":"array.from_list/1","type":"function","doc":"Equivalent to from_list(``List``, undefined)."},{"ref":"array.html#from_list/2","title":"array.from_list/2","type":"function","doc":"Converts a list to an extendible array. Default is used as the value for uninitialized entries of the array. If List is not a proper list, the call fails with reason badarg. See also new/2, to_list/1."},{"ref":"array.html#from_orddict/1","title":"array.from_orddict/1","type":"function","doc":"Equivalent to from_orddict(``Orddict``, undefined)."},{"ref":"array.html#from_orddict/2","title":"array.from_orddict/2","type":"function","doc":"Converts an ordered list of pairs {Index, ``Value``} to a corresponding extendible array. Default is used as the value for uninitialized entries of the array. If Orddict is not a proper, ordered list of pairs whose first elements are non-negative integers, the call fails with reason badarg. See also new/2, to_orddict/1."},{"ref":"array.html#get/2","title":"array.get/2","type":"function","doc":"Gets the value of entry I. If I is not a non-negative integer, or if the array has fixed size and I is larger than the maximum index, the call fails with reason badarg. If the array does not have fixed size, the default value for any index I greater than size(``Array``)-1 is returned. See also set/3."},{"ref":"array.html#is_array/1","title":"array.is_array/1","type":"function","doc":"Returns true if X is an array, otherwise false. Notice that the check is only shallow, as there is no guarantee that X is a well-formed array representation even if this function returns true."},{"ref":"array.html#is_fix/1","title":"array.is_fix/1","type":"function","doc":"Checks if the array has fixed size. Returns true if the array is fixed, otherwise false. See also fix/1."},{"ref":"array.html#map/2","title":"array.map/2","type":"function","doc":"Maps the specified function onto each array element. The elements are visited in order from the lowest index to the highest. If Function is not a function, the call fails with reason badarg. See also foldl/3, foldr/3, sparse_map/2."},{"ref":"array.html#new/0","title":"array.new/0","type":"function","doc":"Creates a new, extendible array with initial size zero. See also new/1, new/2."},{"ref":"array.html#new/1","title":"array.new/1","type":"function","doc":"Creates a new array according to the specified otions. By default, the array is extendible and has initial size zero. Array indices start at 0. Options is a single term or a list of terms, selected from the following: N::integer() &gt;= 0 or {size, N::integer() &gt;= 0} * Specifies the initial array size; this also implies {fixed, true}. If N is not a non-negative integer, the call fails with reason badarg. fixed or {fixed, true} * Creates a fixed-size array. See also fix/1. {fixed, false} * Creates an extendible (non-fixed-size) array. {default, Value} * Sets the default value for the array to Value. Options are processed in the order they occur in the list, that is, later options have higher precedence. The default value is used as the value of uninitialized entries, and cannot be changed once the array has been created. Examples: array:new(100) creates a fixed-size array of size 100. array:new({default,0}) creates an empty, extendible array whose default value is 0. array:new([{size,10},{fixed,false},{default,-1}]) creates an extendible array with initial size 10 whose default value is -1. See also fix/1, from_list/2, get/2, new/0, new/2, set/3."},{"ref":"array.html#new/2","title":"array.new/2","type":"function","doc":"Creates a new array according to the specified size and options. If Size is not a non-negative integer, the call fails with reason badarg. By default, the array has fixed size. Notice that any size specifications in Options override parameter Size. If Options is a list, this is equivalent to new([{size, ``Size``} | ``Options``], otherwise it is equivalent to `new([{size, Size} | [``Options``]]`. However, using this function directly is more efficient. Example: array:new(100, {default,0}) creates a fixed-size array of size 100, whose default value is 0. See also new/1."},{"ref":"array.html#relax/1","title":"array.relax/1","type":"function","doc":"Makes the array resizable. (Reverses the effects of fix/1.) See also fix/1."},{"ref":"array.html#reset/2","title":"array.reset/2","type":"function","doc":"Resets entry I to the default value for the array. If the value of entry I is the default value, the array is returned unchanged. Reset never changes the array size. Shrinking can be done explicitly by calling resize/2. If I is not a non-negative integer, or if the array has fixed size and I is larger than the maximum index, the call fails with reason badarg; compare set/3 See also new/2, set/3."},{"ref":"array.html#resize/1","title":"array.resize/1","type":"function","doc":"Changes the array size to that reported by sparse_size/1. If the specified array has fixed size, also the resulting array has fixed size. See also resize/2, sparse_size/1."},{"ref":"array.html#resize/2","title":"array.resize/2","type":"function","doc":"Change the array size. If Size is not a non-negative integer, the call fails with reason badarg. If the specified array has fixed size, also the resulting array has fixed size."},{"ref":"array.html#set/3","title":"array.set/3","type":"function","doc":"Sets entry I of the array to Value. If I is not a non-negative integer, or if the array has fixed size and I is larger than the maximum index, the call fails with reason badarg. If the array does not have fixed size, and I is greater than size(``Array``)-1, the array grows to size I``+1. See also get/2, reset/2."},{"ref":"array.html#size/1","title":"array.size/1","type":"function","doc":"Gets the number of entries in the array. Entries are numbered from 0 to size(``Array``)-1. Hence, this is also the index of the first entry that is guaranteed to not have been previously set. See also set/3, sparse_size/1."},{"ref":"array.html#sparse_foldl/3","title":"array.sparse_foldl/3","type":"function","doc":"Folds the array elements using the specified function and initial accumulator value, skipping default-valued entries. The elements are visited in order from the lowest index to the highest. If Function is not a function, the call fails with reason badarg. See also foldl/3, sparse_foldr/3."},{"ref":"array.html#sparse_foldr/3","title":"array.sparse_foldr/3","type":"function","doc":"Folds the array elements right-to-left using the specified function and initial accumulator value, skipping default-valued entries. The elements are visited in order from the highest index to the lowest. If Function is not a function, the call fails with reason badarg. See also foldr/3, sparse_foldl/3."},{"ref":"array.html#sparse_map/2","title":"array.sparse_map/2","type":"function","doc":"Maps the specified function onto each array element, skipping default-valued entries. The elements are visited in order from the lowest index to the highest. If Function is not a function, the call fails with reason badarg. See also map/2."},{"ref":"array.html#sparse_size/1","title":"array.sparse_size/1","type":"function","doc":"Gets the number of entries in the array up until the last non-default-valued entry. That is, returns I+1 if I is the last non-default-valued entry in the array, or zero if no such entry exists. See also resize/1, size/1."},{"ref":"array.html#sparse_to_list/1","title":"array.sparse_to_list/1","type":"function","doc":"Converts the array to a list, skipping default-valued entries. See also to_list/1."},{"ref":"array.html#sparse_to_orddict/1","title":"array.sparse_to_orddict/1","type":"function","doc":"Converts the array to an ordered list of pairs {Index, ``Value``}, skipping default-valued entries. See also to_orddict/1."},{"ref":"array.html#to_list/1","title":"array.to_list/1","type":"function","doc":"Converts the array to a list. See also from_list/2, sparse_to_list/1."},{"ref":"array.html#to_orddict/1","title":"array.to_orddict/1","type":"function","doc":"Converts the array to an ordered list of pairs {Index, ``Value``}. See also from_orddict/2, sparse_to_orddict/1."},{"ref":"base64.html","title":"base64","type":"module","doc":"Provides base64 encode and decode, see RFC 2045."},{"ref":"base64.html#decodedecode_to_stringmime_decodemime_decode_to_string/1111","title":"base64.decodedecode_to_stringmime_decodemime_decode_to_string/1111","type":"function","doc":"Decodes a base64-encoded string to plain ASCII. See RFC 4648. mime_decode/1 and mime_decode_to_string/1 strip away illegal characters, while decode/1 and decode_to_string/1 only strip away whitespace characters."},{"ref":"base64.html#encodeencode_to_string/11","title":"base64.encodeencode_to_string/11","type":"function","doc":"Encodes a plain ASCII string into base64. The result is 33% larger than the data."},{"ref":"beam_lib.html","title":"beam_lib","type":"module","doc":"This module provides an interface to files created by the BEAM Compiler (&quot;BEAM files&quot;). The format used, a variant of &quot;EA IFF 1985&quot; Standard for Interchange Format Files, divides data into chunks. Chunk data can be returned as binaries or as compound terms. Compound terms are returned when chunks are referenced by names (atoms) rather than identifiers (strings). The recognized names and the corresponding identifiers are as follows: * `atoms (&quot;Atom&quot;)` * `attributes (&quot;Attr&quot;)` * `compile_info (&quot;CInf&quot;)` * `debug_info (&quot;Dbgi&quot;)` * `exports (&quot;ExpT&quot;)` * `imports (&quot;ImpT&quot;)` * `indexed_imports (&quot;ImpT&quot;)` * `labeled_exports (&quot;ExpT&quot;)` * `labeled_locals (&quot;LocT&quot;)` * `locals (&quot;LocT&quot;)`"},{"ref":"beam_lib.html#all_chunks/1","title":"beam_lib.all_chunks/1","type":"function","doc":"Reads chunk data for all chunks."},{"ref":"beam_lib.html#build_module/1","title":"beam_lib.build_module/1","type":"function","doc":"Builds a BEAM module (as a binary) from a list of chunks."},{"ref":"beam_lib.html#chunks/2","title":"beam_lib.chunks/2","type":"function","doc":"Reads chunk data for selected chunks references. The order of the returned list of chunk data is determined by the order of the list of chunks references."},{"ref":"beam_lib.html#chunks/3","title":"beam_lib.chunks/3","type":"function","doc":"Reads chunk data for selected chunks references. The order of the returned list of chunk data is determined by the order of the list of chunks references. By default, if any requested chunk is missing in Beam, an error tuple is returned. However, if option allow_missing_chunks is specified, a result is returned even if chunks are missing. In the result list, any missing chunks are represented as {``ChunkRef``,missing_chunk}. Notice however that if chunk &quot;Atom&quot; is missing, that is considered a fatal error and the return value is an error tuple."},{"ref":"beam_lib.html#clear_crypto_key_fun/0","title":"beam_lib.clear_crypto_key_fun/0","type":"function","doc":"Unregisters the crypto key fun and terminates the process holding it, started by crypto_key_fun/1. Returns either {ok, undefined} if no crypto key fun is registered, or {ok, Term}, where Term is the return value from CryptoKeyFun(clear), see crypto_key_fun/1."},{"ref":"beam_lib.html#cmp/2","title":"beam_lib.cmp/2","type":"function","doc":"Compares the contents of two BEAM files. If the module names are the same, and all chunks except for chunk &quot;CInf&quot; (the chunk containing the compilation information that is returned by Module:module_info(compile)) have the same contents in both files, ok is returned. Otherwise an error message is returned."},{"ref":"beam_lib.html#cmp_dirs/2","title":"beam_lib.cmp_dirs/2","type":"function","doc":"Compares the BEAM files in two directories. Only files with extension &quot;.beam&quot; are compared. BEAM files that exist only in directory Dir1 (Dir2) are returned in Only1 (Only2). BEAM files that exist in both directories but are considered different by cmp/2 are returned as pairs {Filename1, Filename2}, where Filename1 (Filename2) exists in directory Dir1 (Dir2)."},{"ref":"beam_lib.html#crypto_key_fun/1","title":"beam_lib.crypto_key_fun/1","type":"function","doc":"Registers an unary fun that is called if beam_lib must read an debug_info chunk that has been encrypted. The fun is held in a process that is started by the function. If a fun is already registered when attempting to register a fun, {error, exists} is returned. The fun must handle the following arguments: CryptoKeyFun(init) -&gt; ok | {ok, NewCryptoKeyFun} | {error, Term} Called when the fun is registered, in the process that holds the fun. Here the crypto key fun can do any necessary initializations. If {ok, NewCryptoKeyFun} is returned, NewCryptoKeyFun is registered instead of CryptoKeyFun. If {error, Term} is returned, the registration is aborted and crypto_key_fun/1 also returns {error, Term}. CryptoKeyFun({debug_info, Mode, Module, Filename}) -&gt; Key Called when the key is needed for module Module in the file named Filename. Mode is the type of crypto algorithm; currently, the only possible value is des3_cbc. The call is to fail (raise an exception) if no key is available. CryptoKeyFun(clear) -&gt; term() Called before the fun is unregistered. Here any cleaning up can be done. The return value is not important, but is passed back to the caller of clear_crypto_key_fun/0 as part of its return value."},{"ref":"beam_lib.html#diff_dirs/2","title":"beam_lib.diff_dirs/2","type":"function","doc":"Compares the BEAM files in two directories as cmp_dirs/2, but the names of files that exist in only one directory or are different are presented on standard output."},{"ref":"beam_lib.html#format_error/1","title":"beam_lib.format_error/1","type":"function","doc":"For a specified error returned by any function in this module, this function returns a descriptive string of the error in English. For file errors, function file:format_error(Posix) is to be called."},{"ref":"beam_lib.html#info/1","title":"beam_lib.info/1","type":"function","doc":"Returns a list containing some information about a BEAM file as tuples {Item, Info}: `{file, Filename} | {binary, ``Binary``}` * The name (string) of the BEAM file, or the binary from which the information was extracted. {module, ``Module``} * The name (atom) of the module. {chunks, [{``ChunkId``, ``Pos``, ``Size``}]} * For each chunk, the identifier (string) and the position and size of the chunk data, in bytes."},{"ref":"beam_lib.html#md5/1","title":"beam_lib.md5/1","type":"function","doc":"Calculates an MD5 redundancy check for the code of the module (compilation date and other attributes are not included)."},{"ref":"beam_lib.html#strip/1","title":"beam_lib.strip/1","type":"function","doc":"Removes all chunks from a BEAM file except those needed by the loader. In particular, the debug information (chunk debug_info and abstract_code) is removed."},{"ref":"beam_lib.html#strip/2","title":"beam_lib.strip/2","type":"function","doc":"Removes all chunks from a BEAM file except those needed by the loader or passed in. In particular, the debug information (chunk debug_info and abstract_code) is removed."},{"ref":"beam_lib.html#strip_files/1","title":"beam_lib.strip_files/1","type":"function","doc":"Removes all chunks except those needed by the loader from BEAM files. In particular, the debug information (chunk debug_info and abstract_code) is removed. The returned list contains one element for each specified filename, in the same order as in Files."},{"ref":"beam_lib.html#strip_files/2","title":"beam_lib.strip_files/2","type":"function","doc":"Removes all chunks except those needed by the loader or passed in from BEAM files. In particular, the debug information (chunk debug_info and abstract_code) is removed. The returned list contains one element for each specified filename, in the same order as in Files."},{"ref":"beam_lib.html#strip_release/1","title":"beam_lib.strip_release/1","type":"function","doc":"Removes all chunks except those needed by the loader from the BEAM files of a release. Dir is to be the installation root directory. For example, the current OTP release can be stripped with the call beam_lib:strip_release(code:root_dir())."},{"ref":"beam_lib.html#strip_release/2","title":"beam_lib.strip_release/2","type":"function","doc":"Removes all chunks except those needed by the loader or passed in from the BEAM files of a release. Dir is to be the installation root directory. For example, the current OTP release can be stripped with the call beam_lib:strip_release(code:root_dir())."},{"ref":"beam_lib.html#version/1","title":"beam_lib.version/1","type":"function","doc":"Returns the module version or versions. A version is defined by module attribute -vsn(Vsn). If this attribute is not specified, the version defaults to the checksum of the module. Notice that if version Vsn is not a list, it is made into one, that is {ok,{Module,[Vsn]}} is returned. If there are many -vsn module attributes, the result is the concatenated list of versions. Examples: 1&gt; beam_lib:version(a). % -vsn(1). {ok,{a,[1]}} 2&gt; beam_lib:version(b). % -vsn([1]). {ok,{b,[1]}} 3&gt; beam_lib:version(c). % -vsn([1]). -vsn(2). {ok,{c,[1,2]}} 4&gt; beam_lib:version(d). % no -vsn attribute {ok,{d,[275613208176997377698094100858909383631]}}"},{"ref":"binary.html","title":"binary","type":"module","doc":"This module contains functions for manipulating byte-oriented binaries. Although the majority of functions could be provided using bit-syntax, the functions in this library are highly optimized and are expected to either execute faster or consume less memory, or both, than a counterpart written in pure Erlang. The module is provided according to Erlang Enhancement Proposal (EEP) 31. The library handles byte-oriented data. For bitstrings that are not binaries (does not contain whole octets of bits) a badarg exception is thrown from any of the functions in this module."},{"ref":"binary.html#at/2","title":"binary.at/2","type":"function","doc":"Returns the byte at position Pos (zero-based) in binary Subject as an integer. If Pos &gt;= byte_size(``Subject``), a badarg exception is raised."},{"ref":"binary.html#bin_to_list/1","title":"binary.bin_to_list/1","type":"function","doc":"Same as bin_to_list(``Subject``, {0,byte_size(``Subject``)})."},{"ref":"binary.html#bin_to_list/2","title":"binary.bin_to_list/2","type":"function","doc":"Converts Subject to a list of byte()s, each representing the value of one byte. part() denotes which part of the binary() to convert. Example: 1&gt; binary:bin_to_list(&lt;&lt;&quot;erlang&quot;&gt;&gt;, {1,3}). &quot;rla&quot; %% or [114,108,97] in list notation. If PosLen in any way references outside the binary, a badarg exception is raised."},{"ref":"binary.html#bin_to_list/3","title":"binary.bin_to_list/3","type":"function","doc":"Same asbin_to_list(``Subject``, {``Pos``, ``Len``})."},{"ref":"binary.html#compile_pattern/1","title":"binary.compile_pattern/1","type":"function","doc":"Builds an internal structure representing a compilation of a search pattern, later to be used in functions match/3, matches/3, split/3, or replace/4. The cp() returned is guaranteed to be a tuple() to allow programs to distinguish it from non-precompiled search patterns. When a list of binaries is specified, it denotes a set of alternative binaries to search for. For example, if [&lt;&lt;&quot;functional&quot;&gt;&gt;,&lt;&lt;&quot;programming&quot;&gt;&gt;] is specified as Pattern, this means either &lt;&lt;&quot;functional&quot;&gt;&gt; or &lt;&lt;&quot;programming&quot;&gt;&gt;&quot;. The pattern is a set of alternatives; when only a single binary is specified, the set has only one element. The order of alternatives in a pattern is not significant. The list of binaries used for search alternatives must be flat and proper. If Pattern is not a binary or a flat proper list of binaries with length &gt; 0, a badarg exception is raised."},{"ref":"binary.html#copy/1","title":"binary.copy/1","type":"function","doc":"Same as copy(``Subject``, 1)."},{"ref":"binary.html#copy/2","title":"binary.copy/2","type":"function","doc":"Creates a binary with the content of Subject duplicated N times. This function always creates a new binary, even if N`` = 1. By using copy/1 on a binary referencing a larger binary, one can free up the larger binary for garbage collection. By deliberately copying a single binary to avoid referencing a larger binary, one can, instead of freeing up the larger binary for later garbage collection, create much more binary data than needed. Sharing binary data is usually good. Only in special cases, when small parts reference large binaries and the large binaries are no longer used in any process, deliberate copying can be a good idea. If N &lt; 0, a badarg exception is raised."},{"ref":"binary.html#decode_unsigned/1","title":"binary.decode_unsigned/1","type":"function","doc":"Same as decode_unsigned(``Subject``, big)."},{"ref":"binary.html#decode_unsigned/2","title":"binary.decode_unsigned/2","type":"function","doc":"Converts the binary digit representation, in big endian or little endian, of a positive integer in Subject to an Erlang integer(). Example: 1&gt; binary:decode_unsigned(&lt;&lt;169,138,199&gt;&gt;,big). 11111111"},{"ref":"binary.html#encode_unsigned/1","title":"binary.encode_unsigned/1","type":"function","doc":"Same as encode_unsigned(``Unsigned``, big)."},{"ref":"binary.html#encode_unsigned/2","title":"binary.encode_unsigned/2","type":"function","doc":"Converts a positive integer to the smallest possible representation in a binary digit representation, either big endian or little endian. Example: 1&gt; binary:encode_unsigned(11111111, big). &lt;&lt;169,138,199&gt;&gt;"},{"ref":"binary.html#first/1","title":"binary.first/1","type":"function","doc":"Returns the first byte of binary Subject as an integer. If the size of Subject is zero, a badarg exception is raised."},{"ref":"binary.html#last/1","title":"binary.last/1","type":"function","doc":"Returns the last byte of binary Subject as an integer. If the size of Subject is zero, a badarg exception is raised."},{"ref":"binary.html#list_to_bin/1","title":"binary.list_to_bin/1","type":"function","doc":"Works exactly as erlang:list_to_binary/1, added for completeness."},{"ref":"binary.html#longest_common_prefix/1","title":"binary.longest_common_prefix/1","type":"function","doc":"Returns the length of the longest common prefix of the binaries in list Binaries. Example: 1&gt; binary:longest_common_prefix([&lt;&lt;&quot;erlang&quot;&gt;&gt;, &lt;&lt;&quot;ergonomy&quot;&gt;&gt;]). 2 2&gt; binary:longest_common_prefix([&lt;&lt;&quot;erlang&quot;&gt;&gt;, &lt;&lt;&quot;perl&quot;&gt;&gt;]). 0 If Binaries is not a flat list of binaries, a badarg exception is raised."},{"ref":"binary.html#longest_common_suffix/1","title":"binary.longest_common_suffix/1","type":"function","doc":"Returns the length of the longest common suffix of the binaries in list Binaries. Example: 1&gt; binary:longest_common_suffix([&lt;&lt;&quot;erlang&quot;&gt;&gt;, &lt;&lt;&quot;fang&quot;&gt;&gt;]). 3 2&gt; binary:longest_common_suffix([&lt;&lt;&quot;erlang&quot;&gt;&gt;, &lt;&lt;&quot;perl&quot;&gt;&gt;]). 0 If Binaries is not a flat list of binaries, a badarg exception is raised."},{"ref":"binary.html#match/2","title":"binary.match/2","type":"function","doc":"Same as match(``Subject``, ``Pattern``, [])."},{"ref":"binary.html#match/3","title":"binary.match/3","type":"function","doc":"Searches for the first occurrence of Pattern in Subject and returns the position and length. The function returns {Pos, Length} for the binary in Pattern, starting at the lowest position in Subject. Example: 1&gt; binary:match(&lt;&lt;&quot;abcde&quot;&gt;&gt;, [&lt;&lt;&quot;bcde&quot;&gt;&gt;, &lt;&lt;&quot;cd&quot;&gt;&gt;],[]). {1,4} Even though &lt;&lt;&quot;cd&quot;&gt;&gt; ends before &lt;&lt;&quot;bcde&quot;&gt;&gt;, &lt;&lt;&quot;bcde&quot;&gt;&gt; begins first and is therefore the first match. If two overlapping matches begin at the same position, the longest is returned. Summary of the options: {scope, {Start, Length}} * Only the specified part is searched. Return values still have offsets from the beginning of Subject. A negative Length is allowed as described in section Data Types in this manual. If none of the strings in Pattern is found, the atom nomatch is returned. For a description of Pattern, see function compile_pattern/1. If {scope, {Start,Length}} is specified in the options such that Start &gt; size of Subject, Start + Length &lt; 0 or Start + Length &gt; size of Subject, a badarg exception is raised."},{"ref":"binary.html#matches/2","title":"binary.matches/2","type":"function","doc":"Same as matches(``Subject``, ``Pattern``, [])."},{"ref":"binary.html#matches/3","title":"binary.matches/3","type":"function","doc":"As match/2, but Subject is searched until exhausted and a list of all non-overlapping parts matching Pattern is returned (in order). The first and longest match is preferred to a shorter, which is illustrated by the following example: 1&gt; binary:matches(&lt;&lt;&quot;abcde&quot;&gt;&gt;, [&lt;&lt;&quot;bcde&quot;&gt;&gt;,&lt;&lt;&quot;bc&quot;&gt;&gt;,&lt;&lt;&quot;de&quot;&gt;&gt;],[]). [{1,4}] The result shows that &lt;&lt;&quot;bcde&quot;&gt;&gt; is selected instead of the shorter match &lt;&lt;&quot;bc&quot;&gt;&gt; (which would have given raise to one more match, &lt;&lt;&quot;de&quot;&gt;&gt;). This corresponds to the behavior of POSIX regular expressions (and programs like awk), but is not consistent with alternative matches in re (and Perl), where instead lexical ordering in the search pattern selects which string matches. If none of the strings in a pattern is found, an empty list is returned. For a description of Pattern, see compile_pattern/1. For a description of available options, see match/3. If {scope, {``Start``,``Length``}} is specified in the options such that Start &gt; size of Subject, Start`` + ``Length &lt; 0 or Start`` + ``Length is &gt; size of Subject, a badarg exception is raised."},{"ref":"binary.html#part/2","title":"binary.part/2","type":"function","doc":"Extracts the part of binary Subject described by PosLen. A negative length can be used to extract bytes at the end of a binary: 1&gt; Bin = &lt;&lt;1,2,3,4,5,6,7,8,9,10&gt;&gt;. 2&gt; binary:part(Bin, {byte_size(Bin), -5}). &lt;&lt;6,7,8,9,10&gt;&gt; part/2 and part/3 are also available in the erlang module under the names binary_part/2 and binary_part/3. Those BIFs are allowed in guard tests. If PosLen in any way references outside the binary, a badarg exception is raised."},{"ref":"binary.html#part/3","title":"binary.part/3","type":"function","doc":"Same as part(``Subject``, {``Pos``, ``Len``})."},{"ref":"binary.html#referenced_byte_size/1","title":"binary.referenced_byte_size/1","type":"function","doc":"If a binary references a larger binary (often described as being a subbinary), it can be useful to get the size of the referenced binary. This function can be used in a program to trigger the use of copy/1. By copying a binary, one can dereference the original, possibly large, binary that a smaller binary is a reference to. Example: store(Binary, GBSet) -&gt; NewBin = case binary:referenced_byte_size(Binary) of Large when Large &gt; 2 * byte_size(Binary) -&gt; binary:copy(Binary); _ -&gt; Binary end, gb_sets:insert(NewBin,GBSet). In this example, we chose to copy the binary content before inserting it in gb_sets:set() if it references a binary more than twice the data size we want to keep. Of course, different rules apply when copying to different programs. Binary sharing occurs whenever binaries are taken apart. This is the fundamental reason why binaries are fast, decomposition can always be done with O(1) complexity. In rare circumstances this data sharing is however undesirable, why this function together with copy/1 can be useful when optimizing for memory use. Example of binary sharing: 1&gt; A = binary:copy(&lt;&lt;1&gt;&gt;, 100). &lt;&lt;1,1,1,1,1 ... 2&gt; byte_size(A). 100 3&gt; binary:referenced_byte_size(A). 100 4&gt; &lt;&lt;B:10/binary, C:90/binary&gt;&gt; = A. &lt;&lt;1,1,1,1,1 ... 5&gt; {byte_size(B), binary:referenced_byte_size(B)}. {10,10} 6&gt; {byte_size(C), binary:referenced_byte_size(C)}. {90,100} In the above example, the small binary B was copied while the larger binary C references binary A. Binary data is shared among processes. If another process still references the larger binary, copying the part this process uses only consumes more memory and does not free up the larger binary for garbage collection. Use this kind of intrusive functions with extreme care and only if a real problem is detected."},{"ref":"binary.html#replace/3","title":"binary.replace/3","type":"function","doc":"Same as replace(``Subject``, ``Pattern``, ``Replacement``,[])."},{"ref":"binary.html#replace/4","title":"binary.replace/4","type":"function","doc":"Constructs a new binary by replacing the parts in Subject matching Pattern with the content of Replacement. If the matching subpart of Subject giving raise to the replacement is to be inserted in the result, option {insert_replaced, ``InsPos``} inserts the matching part into Replacement at the specified position (or positions) before inserting Replacement into Subject. Example: 1&gt; binary:replace(&lt;&lt;&quot;abcde&quot;&gt;&gt;,&lt;&lt;&quot;b&quot;&gt;&gt;,&lt;&lt;&quot;[]&quot;&gt;&gt;, [{insert_replaced,1}]). &lt;&lt;&quot;a[b]cde&quot;&gt;&gt; 2&gt; binary:replace(&lt;&lt;&quot;abcde&quot;&gt;&gt;,[&lt;&lt;&quot;b&quot;&gt;&gt;,&lt;&lt;&quot;d&quot;&gt;&gt;],&lt;&lt;&quot;[]&quot;&gt;&gt;,[global,{insert_replaced,1}]). &lt;&lt;&quot;a[b]c[d]e&quot;&gt;&gt; 3&gt; binary:replace(&lt;&lt;&quot;abcde&quot;&gt;&gt;,[&lt;&lt;&quot;b&quot;&gt;&gt;,&lt;&lt;&quot;d&quot;&gt;&gt;],&lt;&lt;&quot;[]&quot;&gt;&gt;,[global,{insert_replaced,[1,1]}]). &lt;&lt;&quot;a[bb]c[dd]e&quot;&gt;&gt; 4&gt; binary:replace(&lt;&lt;&quot;abcde&quot;&gt;&gt;,[&lt;&lt;&quot;b&quot;&gt;&gt;,&lt;&lt;&quot;d&quot;&gt;&gt;],&lt;&lt;&quot;[-]&quot;&gt;&gt;,[global,{insert_replaced,[1,2]}]). &lt;&lt;&quot;a[b-b]c[d-d]e&quot;&gt;&gt; If any position specified in InsPos &gt; size of the replacement binary, a badarg exception is raised. Options global and {scope, part()} work as for split/3. The return type is always a binary(). For a description of Pattern, see compile_pattern/1."},{"ref":"binary.html#split/2","title":"binary.split/2","type":"function","doc":"Same as split(``Subject``, ``Pattern``, [])."},{"ref":"binary.html#split/3","title":"binary.split/3","type":"function","doc":"Splits Subject into a list of binaries based on Pattern. If option global is not specified, only the first occurrence of Pattern in Subject gives rise to a split. The parts of Pattern found in Subject are not included in the result. Example: 1&gt; binary:split(&lt;&lt;1,255,4,0,0,0,2,3&gt;&gt;, [&lt;&lt;0,0,0&gt;&gt;,&lt;&lt;2&gt;&gt;],[]). [&lt;&lt;1,255,4&gt;&gt;, &lt;&lt;2,3&gt;&gt;] 2&gt; binary:split(&lt;&lt;0,1,0,0,4,255,255,9&gt;&gt;, [&lt;&lt;0,0&gt;&gt;, &lt;&lt;255,255&gt;&gt;],[global]). [&lt;&lt;0,1&gt;&gt;,&lt;&lt;4&gt;&gt;,&lt;&lt;9&gt;&gt;] Summary of options: {scope, part()} * Works as in match/3 and matches/3. Notice that this only defines the scope of the search for matching strings, it does not cut the binary before splitting. The bytes before and after the scope are kept in the result. See the example below. trim * Removes trailing empty parts of the result (as does trim in re:split/3. trim_all * Removes all empty parts of the result. global * Repeats the split until Subject is exhausted. Conceptually option global makes split work on the positions returned by matches/3, while it normally works on the position returned by match/3. Example of the difference between a scope and taking the binary apart before splitting: 1&gt; binary:split(&lt;&lt;&quot;banana&quot;&gt;&gt;, [&lt;&lt;&quot;a&quot;&gt;&gt;],[{scope,{2,3}}]). [&lt;&lt;&quot;ban&quot;&gt;&gt;,&lt;&lt;&quot;na&quot;&gt;&gt;] 2&gt; binary:split(binary:part(&lt;&lt;&quot;banana&quot;&gt;&gt;,{2,3}), [&lt;&lt;&quot;a&quot;&gt;&gt;],[]). [&lt;&lt;&quot;n&quot;&gt;&gt;,&lt;&lt;&quot;n&quot;&gt;&gt;] The return type is always a list of binaries that are all referencing Subject. This means that the data in Subject is not copied to new binaries, and that Subject cannot be garbage collected until the results of the split are no longer referenced. For a description of Pattern, see compile_pattern/1."},{"ref":"c.html","title":"c","type":"module","doc":"This module enables users to enter the short form of some commonly used commands. These functions are intended for interactive use in the Erlang shell only. The module prefix can be omitted."},{"ref":"c.html#bt/1","title":"c.bt/1","type":"function","doc":"Stack backtrace for a process. Equivalent to erlang:process_display(``Pid``, backtrace)."},{"ref":"c.html#ccc/123","title":"c.ccc/123","type":"function","doc":"Compiles and then purges and loads the code for a module. Module can be either a module name or a source file path, with or without .erl extension. Options defaults to []. If Module is an atom and is not the path of a source file, then the code path is searched to locate the object file for the module and extract its original compiler options and source path. If the source file is not found in the original location, filelib:find_source/1 is used to search for it relative to the directory of the object file. The source file is compiled with the the original options appended to the given Options, the output replacing the old object file if and only if compilation succeeds. A function Filter can be specified for removing elements from from the original compiler options before the new options are added. Notice that purging the code means that any processes lingering in old code for the module are killed without warning. For more information, see code/3."},{"ref":"c.html#cd/1","title":"c.cd/1","type":"function","doc":"Changes working directory to Dir, which can be a relative name, and then prints the name of the new working directory. Example: 2&gt; cd(&quot;../erlang&quot;). /home/ron/erlang"},{"ref":"c.html#erlangrc/1","title":"c.erlangrc/1","type":"function","doc":"Search PathList and load .erlang resource file if found."},{"ref":"c.html#flush/0","title":"c.flush/0","type":"function","doc":"Flushes any messages sent to the shell."},{"ref":"c.html#help/0","title":"c.help/0","type":"function","doc":"Displays help information: all valid shell internal commands, and commands in this module."},{"ref":"c.html#i/3","title":"c.i/3","type":"function","doc":"Displays information about a process, Equivalent to process_info(pid(``X``, ``Y``, ``Z``)), but location transparent."},{"ref":"c.html#ini/0","title":"c.ini/0","type":"function","doc":"i/0 displays system information, listing information about all processes. ni/0 does the same, but for all nodes the network."},{"ref":"c.html#l/1","title":"c.l/1","type":"function","doc":"Purges and loads, or reloads, a module by calling code:purge(``Module``) followed by code:load_file(``Module``). Notice that purging the code means that any processes lingering in old code for the module are killed without warning. For more information, see code/3."},{"ref":"c.html#lm/0","title":"c.lm/0","type":"function","doc":"Reloads all currently loaded modules that have changed on disk (see mm()). Returns the list of results from calling l(M) for each such M."},{"ref":"c.html#ls/0","title":"c.ls/0","type":"function","doc":"Lists files in the current directory."},{"ref":"c.html#ls/1","title":"c.ls/1","type":"function","doc":"Lists files in directory Dir or, if Dir is a file, only lists it."},{"ref":"c.html#m/0","title":"c.m/0","type":"function","doc":"Displays information about the loaded modules, including the files from which they have been loaded."},{"ref":"c.html#m/1","title":"c.m/1","type":"function","doc":"Displays information about Module."},{"ref":"c.html#memory/0","title":"c.memory/0","type":"function","doc":"Memory allocation information. Equivalent to erlang:memory/0."},{"ref":"c.html#memorymemory/11","title":"c.memorymemory/11","type":"function","doc":"Memory allocation information. Equivalent to erlang:memory/1."},{"ref":"c.html#mm/0","title":"c.mm/0","type":"function","doc":"Lists all modified modules. Shorthand for code:modified_modules/0."},{"ref":"c.html#ncnc/12","title":"c.ncnc/12","type":"function","doc":"Compiles and then loads the code for a file on all nodes. Options defaults to []. Compilation is equivalent to: compile:file(File, Options ++ [report_errors, report_warnings])"},{"ref":"c.html#nl/1","title":"c.nl/1","type":"function","doc":"Loads Module on all nodes."},{"ref":"c.html#pid/3","title":"c.pid/3","type":"function","doc":"Converts X, Y, Z to pid &lt;X.Y.Z&gt;. This function is only to be used when debugging."},{"ref":"c.html#pwd/0","title":"c.pwd/0","type":"function","doc":"Prints the name of the working directory."},{"ref":"c.html#q/0","title":"c.q/0","type":"function","doc":"This function is shorthand for init:stop(), that is, it causes the node to stop in a controlled fashion."},{"ref":"c.html#regsnregs/0","title":"c.regsnregs/0","type":"function","doc":"regs/0 displays information about all registered processes. nregs/0 does the same, but for all nodes in the network."},{"ref":"c.html#uptime/0","title":"c.uptime/0","type":"function","doc":"Prints the node uptime (as specified by erlang:statistics(wall_clock)) in human-readable form."},{"ref":"calendar.html","title":"calendar","type":"module","doc":"This module provides computation of local and universal time, day of the week, and many time conversion functions. Time is local when it is adjusted in accordance with the current time zone and daylight saving. Time is universal when it reflects the time at longitude zero, without any adjustment for daylight saving. Universal Coordinated Time (UTC) time is also called Greenwich Mean Time (GMT). The time functions local_time/0 and universal_time/0 in this module both return date and time. The is because separate functions for date and time can result in a date/time combination that is displaced by 24 hours. This occurs if one of the functions is called before midnight, and the other after midnight. This problem also applies to the Erlang BIFs date/0 and time/0, and their use is strongly discouraged if a reliable date/time stamp is required. All dates conform to the Gregorian calendar. This calendar was introduced by Pope Gregory XIII in 1582 and was used in all Catholic countries from this year. Protestant parts of Germany and the Netherlands adopted it in 1698, England followed in 1752, and Russia in 1918 (the October revolution of 1917 took place in November according to the Gregorian calendar). The Gregorian calendar in this module is extended back to year 0. For a given date, the gregorian days is the number of days up to and including the date specified. Similarly, the gregorian seconds for a specified date and time is the number of seconds up to and including the specified date and time. For computing differences between epochs in time, use the functions counting gregorian days or seconds. If epochs are specified as local time, they must be converted to universal time to get the correct value of the elapsed time between epochs. Use of function time_difference/2 is discouraged. Different definitions exist for the week of the year. This module contains a week of the year implementation conforming to the ISO 8601 standard. As the week number for a specified date can fall on the previous, the current, or on the next year, it is important to specify both the year and the week number. Functions iso_week_number/0 and iso_week_number/1 return a tuple of the year and the week number."},{"ref":"calendar.html#date_to_gregorian_daysdate_to_gregorian_days/13","title":"calendar.date_to_gregorian_daysdate_to_gregorian_days/13","type":"function","doc":"Computes the number of gregorian days starting with year 0 and ending at the specified date."},{"ref":"calendar.html#datetime_to_gregorian_seconds/1","title":"calendar.datetime_to_gregorian_seconds/1","type":"function","doc":"Computes the number of gregorian seconds starting with year 0 and ending at the specified date and time."},{"ref":"calendar.html#day_of_the_weekday_of_the_week/13","title":"calendar.day_of_the_weekday_of_the_week/13","type":"function","doc":"Computes the day of the week from the specified Year, Month, and Day. Returns the day of the week as 1: Monday, 2: Tuesday, and so on."},{"ref":"calendar.html#gregorian_days_to_date/1","title":"calendar.gregorian_days_to_date/1","type":"function","doc":"Computes the date from the specified number of gregorian days."},{"ref":"calendar.html#gregorian_seconds_to_datetime/1","title":"calendar.gregorian_seconds_to_datetime/1","type":"function","doc":"Computes the date and time from the specified number of gregorian seconds."},{"ref":"calendar.html#is_leap_year/1","title":"calendar.is_leap_year/1","type":"function","doc":"Checks if the specified year is a leap year."},{"ref":"calendar.html#iso_week_number/0","title":"calendar.iso_week_number/0","type":"function","doc":"Returns tuple {Year, WeekNum} representing the ISO week number for the actual date. To determine the actual date, use function local_time/0."},{"ref":"calendar.html#iso_week_number/1","title":"calendar.iso_week_number/1","type":"function","doc":"Returns tuple {Year, WeekNum} representing the ISO week number for the specified date."},{"ref":"calendar.html#last_day_of_the_month/2","title":"calendar.last_day_of_the_month/2","type":"function","doc":"Computes the number of days in a month."},{"ref":"calendar.html#local_time/0","title":"calendar.local_time/0","type":"function","doc":"Returns the local time reported by the underlying operating system."},{"ref":"calendar.html#local_time_to_universal_time/1","title":"calendar.local_time_to_universal_time/1","type":"function","doc":"Converts from local time to Universal Coordinated Time (UTC). DateTime1 must refer to a local date after Jan 1, 1970. This function is deprecated. Use local_time_to_universal_time_dst/1 instead, as it gives a more correct and complete result. Especially for the period that does not exist, as it is skipped during the switch to daylight saving time, this function still returns a result."},{"ref":"calendar.html#local_time_to_universal_time_dst/1","title":"calendar.local_time_to_universal_time_dst/1","type":"function","doc":"Converts from local time to Universal Coordinated Time (UTC). DateTime1 must refer to a local date after Jan 1, 1970. The return value is a list of 0, 1, or 2 possible UTC times: [] * For a local {Date1, Time1} during the period that is skipped when switching to daylight saving time, there is no corresponding UTC, as the local time is illegal (it has never occured). [DstDateTimeUTC, DateTimeUTC] * For a local {Date1, Time1} during the period that is repeated when switching from daylight saving time, two corresponding UTCs exist; one for the first instance of the period when daylight saving time is still active, and one for the second instance. [DateTimeUTC] * For all other local times only one corresponding UTC exists."},{"ref":"calendar.html#now_to_datetime/1","title":"calendar.now_to_datetime/1","type":"function","doc":"Returns Universal Coordinated Time (UTC) converted from the return value from erlang:timestamp/0."},{"ref":"calendar.html#now_to_local_time/1","title":"calendar.now_to_local_time/1","type":"function","doc":"Returns local date and time converted from the return value from erlang:timestamp/0."},{"ref":"calendar.html#now_to_universal_time/1","title":"calendar.now_to_universal_time/1","type":"function","doc":"Returns Universal Coordinated Time (UTC) converted from the return value from erlang:timestamp/0."},{"ref":"calendar.html#rfc3339_to_system_timerfc3339_to_system_time/12","title":"calendar.rfc3339_to_system_timerfc3339_to_system_time/12","type":"function","doc":"Converts an RFC 3339 timestamp into system time. The data format of RFC 3339 timestamps is described by RFC 3339. Valid option: {unit, Unit} * The time unit of the return value. The default is second. 1&gt; calendar:rfc3339_to_system_time(&quot;2018-02-01T16:17:58+01:00&quot;). 1517498278 2&gt; calendar:rfc3339_to_system_time(&quot;2018-02-01 15:18:02.088Z&quot;, [{unit, nanosecond}]). 1517498282088000000"},{"ref":"calendar.html#seconds_to_daystime/1","title":"calendar.seconds_to_daystime/1","type":"function","doc":"Converts a specified number of seconds into days, hours, minutes, and seconds. Time is always non-negative, but Days is negative if argument Seconds is."},{"ref":"calendar.html#seconds_to_time/1","title":"calendar.seconds_to_time/1","type":"function","doc":"Computes the time from the specified number of seconds. Seconds must be less than the number of seconds per day (86400)."},{"ref":"calendar.html#system_time_to_local_time/2","title":"calendar.system_time_to_local_time/2","type":"function","doc":"Converts a specified system time into local date and time."},{"ref":"calendar.html#system_time_to_rfc3339system_time_to_rfc3339/12","title":"calendar.system_time_to_rfc3339system_time_to_rfc3339/12","type":"function","doc":"Converts a system time into an RFC 3339 timestamp. The data format of RFC 3339 timestamps is described by RFC 3339. The data format of offsets is also described by RFC 3339. Valid options: {offset, Offset} * The offset, either a string or an integer, to be included in the formatted string. An empty string, which is the default, is interpreted as local time. A non-empty string is included as is. The time unit of the integer is the same as the one of Time. {time_designator, Character} * The character used as time designator, that is, the date and time separator. The default is $T. {unit, Unit} * The time unit of Time. The default is second. If some other unit is given (millisecond, microsecond, or nanosecond), the formatted string includes a fraction of a second. The number of fractional second digits is three, six, or nine depending on what time unit is chosen. Notice that trailing zeros are not removed from the fraction. 1&gt; calendar:system_time_to_rfc3339(erlang:system_time(second)). &quot;2018-04-23T14:56:28+02:00&quot; 2&gt; calendar:system_time_to_rfc3339(erlang:system_time(second), [{offset, &quot;-02:00&quot;}]). &quot;2018-04-23T10:56:52-02:00&quot; 3&gt; calendar:system_time_to_rfc3339(erlang:system_time(second), [{offset, -7200}]). &quot;2018-04-23T10:57:05-02:00&quot; 4&gt; calendar:system_time_to_rfc3339(erlang:system_time(millisecond), [{unit, millisecond}, {time_designator, $\\s}, {offset, &quot;Z&quot;}]). &quot;2018-04-23 12:57:20.482Z&quot;"},{"ref":"calendar.html#system_time_to_universal_time/2","title":"calendar.system_time_to_universal_time/2","type":"function","doc":"Converts a specified system time into universal date and time."},{"ref":"calendar.html#time_difference/2","title":"calendar.time_difference/2","type":"function","doc":"Returns the difference between two {Date, Time} tuples. T2 is to refer to an epoch later than T1. This function is obsolete. Use the conversion functions for gregorian days and seconds instead."},{"ref":"calendar.html#time_to_seconds/1","title":"calendar.time_to_seconds/1","type":"function","doc":"Returns the number of seconds since midnight up to the specified time."},{"ref":"calendar.html#universal_time/0","title":"calendar.universal_time/0","type":"function","doc":"Returns the Universal Coordinated Time (UTC) reported by the underlying operating system. Returns local time if universal time is unavailable."},{"ref":"calendar.html#universal_time_to_local_time/1","title":"calendar.universal_time_to_local_time/1","type":"function","doc":"Converts from Universal Coordinated Time (UTC) to local time. DateTime must refer to a date after Jan 1, 1970."},{"ref":"calendar.html#valid_datevalid_date/13","title":"calendar.valid_datevalid_date/13","type":"function","doc":"This function checks if a date is a valid."},{"ref":"dets.html","title":"dets","type":"module","doc":"This module provides a term storage on file. The stored terms, in this module called objects, are tuples such that one element is defined to be the key. A Dets table is a collection of objects with the key at the same position stored on a file. This module is used by the Mnesia application, and is provided &quot;as is&quot; for users who are interested in efficient storage of Erlang terms on disk only. Many applications only need to store some terms in a file. Mnesia adds transactions, queries, and distribution. The size of Dets files cannot exceed 2 GB. If larger tables are needed, table fragmentation in Mnesia can be used. Three types of Dets tables exist: * `set`. A table of this type has at most one object with a given key. If an object with a key already present in the table is inserted, the existing object is overwritten by the new object. * `bag`. A table of this type has zero or more different objects with a given key. * `duplicate_bag`. A table of this type has zero or more possibly matching objects with a given key. Dets tables must be opened before they can be updated or read, and when finished they must be properly closed. If a table is not properly closed, Dets automatically repairs the table. This can take a substantial time if the table is large. A Dets table is closed when the process which opened the table terminates. If many Erlang processes (users) open the same Dets table, they share the table. The table is properly closed when all users have either terminated or closed the table. Dets tables are not properly closed if the Erlang runtime system terminates abnormally. A ^C command abnormally terminates an Erlang runtime system in a Unix environment with a break-handler. As all operations performed by Dets are disk operations, it is important to realize that a single look-up operation involves a series of disk seek and read operations. The Dets functions are therefore much slower than the corresponding ets(3) functions, although Dets exports a similar interface. Dets organizes data as a linear hash list and the hash list grows gracefully as more data is inserted into the table. Space management on the file is performed by what is called a buddy system. The current implementation keeps the entire buddy system in RAM, which implies that if the table gets heavily fragmented, quite some memory can be used up. The only way to defragment a table is to close it and then open it again with option repair set to force. Notice that type ordered_set in Ets is not yet provided by Dets, neither is the limited support for concurrent updates that makes a sequence of first and next calls safe to use on fixed ETS tables. Both these features may be provided by Dets in a future release of Erlang/OTP. Until then, the Mnesia application (or some user-implemented method for locking) must be used to implement safe concurrency. Currently, no Erlang/OTP library has support for ordered disk-based term storage. All Dets functions return {error, Reason} if an error occurs (first/1 and next/2 are exceptions, they exit the process with the error tuple). If badly formed arguments are specified, all functions exit the process with a badarg message."},{"ref":"dets.html#all/0","title":"dets.all/0","type":"function","doc":"Returns a list of the names of all open tables on this node."},{"ref":"dets.html#bchunk/2","title":"dets.bchunk/2","type":"function","doc":"Returns a list of objects stored in a table. The exact representation of the returned objects is not public. The lists of data can be used for initializing a table by specifying value bchunk to option format of function init_table/3 The Mnesia application uses this function for copying open tables. Unless the table is protected using safe_fixtable/2, calls to bchunk/2 do possibly not work as expected if concurrent updates are made to the table. The first time bchunk/2 is called, an initial continuation, the atom start, must be provided. bchunk/2 returns a tuple {``Continuation2``, ``Data``}, where Data is a list of objects. Continuation2 is another continuation that is to be passed on to a subsequent call to bchunk/2. With a series of calls to bchunk/2, all table objects can be extracted. bchunk/2 returns &#39;$end_of_table&#39; when all objects are returned, or {error, ``Reason``} if an error occurs."},{"ref":"dets.html#close/1","title":"dets.close/1","type":"function","doc":"Closes a table. Only processes that have opened a table are allowed to close it. All open tables must be closed before the system is stopped. If an attempt is made to open a table that is not properly closed, Dets automatically tries to repair it."},{"ref":"dets.html#delete/2","title":"dets.delete/2","type":"function","doc":"Deletes all objects with key Key from table Name."},{"ref":"dets.html#delete_all_objects/1","title":"dets.delete_all_objects/1","type":"function","doc":"Deletes all objects from a table in almost constant time. However, if the table if fixed, delete_all_objects(T) is equivalent to match_delete(T, &#39;_&#39;)."},{"ref":"dets.html#delete_object/2","title":"dets.delete_object/2","type":"function","doc":"Deletes all instances of a specified object from a table. If a table is of type bag or duplicate_bag, this function can be used to delete only some of the objects with a specified key."},{"ref":"dets.html#first/1","title":"dets.first/1","type":"function","doc":"Returns the first key stored in table Name according to the internal order of the table, or &#39;$end_of_table&#39; if the table is empty. Unless the table is protected using safe_fixtable/2, subsequent calls to next/2 do possibly not work as expected if concurrent updates are made to the table. If an error occurs, the process is exited with an error tuple {error, Reason}. The error tuple is not returned, as it cannot be distinguished from a key. There are two reasons why first/1 and next/2 are not to be used: they are not efficient, and they prevent the use of key &#39;$end_of_table&#39;, as this atom is used to indicate the end of the table. If possible, use functions match, match_object, and select for traversing tables."},{"ref":"dets.html#foldlfoldr/33","title":"dets.foldlfoldr/33","type":"function","doc":"Calls Function on successive elements of table Name together with an extra argument AccIn. The table elements are traversed in unspecified order. Function must return a new accumulator that is passed to the next call. Acc0 is returned if the table is empty."},{"ref":"dets.html#from_ets/2","title":"dets.from_ets/2","type":"function","doc":"Deletes all objects of table Name and then inserts all the objects of the ETS table EtsTab. The objects are inserted in unspecified order. As ets:safe_fixtable/2 is called, the ETS table must be public or owned by the calling process."},{"ref":"dets.html#info/1","title":"dets.info/1","type":"function","doc":"Returns information about table Name as a list of tuples: * `{file_size, integer() &gt;= 0}}` - The file size, in bytes. * `{filename, ` `file:name()``}` - The name of the file where objects are stored. * `{keypos, ` `keypos()``}` - The key position. * `{size, integer() &gt;= 0}` - The number of objects stored in the table. * `{type, ` `type()``}` - The table type."},{"ref":"dets.html#info/2","title":"dets.info/2","type":"function","doc":"Returns the information associated with Item for table Name. In addition to the {``Item``, ``Value``} pairs defined for info/1, the following items are allowed: * `{access, ` `access()``}` - The access mode. * `{auto_save, ` `auto_save()``}` - The autosave interval. * `{bchunk_format, binary()}` - An opaque binary describing the format of the objects returned by [`bchunk/2`](#bchunk/2). The binary can be used as argument to `is_compatible_chunk_format/2`. * `{hash, Hash}` - Describes which BIF is used to calculate the hash values of the objects stored in the Dets table. Possible values of `Hash`: * `phash` - Implies that the `erlang:phash/2` BIF is used. * `phash2` - Implies that the `erlang:phash2/1` BIF is used. * `{memory, integer() &gt;= 0}` - The file size, in bytes. The same value is associated with item `file_size`. * `{no_keys, integer &gt;= 0()}` - The number of different keys stored in the table. * `{no_objects, integer &gt;= 0()}` - The number of objects stored in the table. * `{no_slots, {Min, Used, Max}}` - The number of slots of the table. `Min` is the minimum number of slots, `Used` is the number of currently used slots, and `Max` is the maximum number of slots. * `{owner, pid()}` - The pid of the process that handles requests to the Dets table. * `{ram_file, boolean()}` - Whether the table is kept in RAM. * `{safe_fixed_monotonic_time, SafeFixed}` - If the table is fixed, `SafeFixed` is a tuple `{FixedAtTime, [{Pid,RefCount}]}`. `FixedAtTime` is the time when the table was first fixed, and `Pid` is the pid of the process that fixes the table `RefCount` times. There can be any number of processes in the list. If the table is not fixed, `SafeFixed` is the atom `false`. FixedAtTime corresponds to the result returned by erlang:monotonic_time/0 at the time of fixation. The use of safe_fixed_monotonic_time is time warp safe. * `{safe_fixed, SafeFixed}` - The same as `{safe_fixed_monotonic_time, SafeFixed}` except the format and value of `FixedAtTime`. FixedAtTime corresponds to the result returned by erlang:timestamp/0 at the time of fixation. Notice that when the system uses single or multi time warp modes, this can produce strange results. This is because the use of safe_fixed is not time warp safe. Time warp safe code must use safe_fixed_monotonic_time instead."},{"ref":"dets.html#init_tableinit_table/23","title":"dets.init_tableinit_table/23","type":"function","doc":"Replaces the existing objects of table Name with objects created by calling the input function InitFun, see below. The reason for using this function rather than calling insert/2 is that of efficiency. Notice that the input functions are called by the process that handles requests to the Dets table, not by the calling process. When called with argument read, function InitFun is assumed to return end_of_input when there is no more input, or {Objects, Fun}, where Objects is a list of objects and Fun is a new input function. Any other value Value is returned as an error {error, {init_fun, Value}}. Each input function is called exactly once, and if an error occurs, the last function is called with argument close, the reply of which is ignored. If the table type is set and more than one object exists with a given key, one of the objects is chosen. This is not necessarily the last object with the given key in the sequence of objects returned by the input functions. Avoid duplicate keys, otherwise the file becomes unnecessarily fragmented. This holds also for duplicated objects stored in tables of type bag. It is important that the table has a sufficient number of slots for the objects. If not, the hash list starts to grow when init_table/2 returns, which significantly slows down access to the table for a period of time. The minimum number of slots is set by the open_file/2 option min_no_slots and returned by the info/2 item no_slots. See also option min_no_slots below. Argument Options is a list of {Key, Val} tuples, where the following values are allowed: * `{min_no_slots, no_slots()}` - Specifies the estimated number of different keys to be stored in the table. The [`open_file/2`](#open_file/2) option with the same name is ignored, unless the table is created, in which case performance can be enhanced by supplying an estimate when initializing the table. * `{format, Format}` - Specifies the format of the objects returned by function `InitFun`. If `Format` is `term` (the default), `InitFun` is assumed to return a list of tuples. If `Format` is `bchunk`, `InitFun` is assumed to return `Data` as returned by [`bchunk/2`](#bchunk/2). This option overrides option `min_no_slots`."},{"ref":"dets.html#insert/2","title":"dets.insert/2","type":"function","doc":"Inserts one or more objects into the table Name. If there already exists an object with a key matching the key of some of the given objects and the table type is set, the old object will be replaced."},{"ref":"dets.html#insert_new/2","title":"dets.insert_new/2","type":"function","doc":"Inserts one or more objects into table Name. If there already exists some object with a key matching the key of any of the specified objects, the table is not updated and false is returned. Otherwise the objects are inserted and true returned."},{"ref":"dets.html#is_compatible_bchunk_format/2","title":"dets.is_compatible_bchunk_format/2","type":"function","doc":"Returns true if it would be possible to initialize table Name, using init_table/3 with option {format,bchunk}, with objects read with bchunk/2 from some table T, such that calling info(T,bchunk_format) returns BchunkFormat."},{"ref":"dets.html#is_dets_file/1","title":"dets.is_dets_file/1","type":"function","doc":"Returns true if file Filename is a Dets table, otherwise false."},{"ref":"dets.html#lookup/2","title":"dets.lookup/2","type":"function","doc":"Returns a list of all objects with key Key stored in table Name, for example: 2&gt; dets:open_file(abc, [{type, bag}]). {ok,abc} 3&gt; dets:insert(abc, {1,2,3}). ok 4&gt; dets:insert(abc, {1,3,4}). ok 5&gt; dets:lookup(abc, 1). [{1,2,3},{1,3,4}] If the table type is set, the function returns either the empty list or a list with one object, as there cannot be more than one object with a given key. If the table type is bag or duplicate_bag, the function returns a list of arbitrary length. Notice that the order of objects returned is unspecified. In particular, the order in which objects were inserted is not reflected."},{"ref":"dets.html#match/1","title":"dets.match/1","type":"function","doc":"Matches some objects stored in a table and returns a non-empty list of the bindings matching a specified pattern in some unspecified order. The table, the pattern, and the number of objects that are matched are all defined by Continuation, which has been returned by a previous call to match/1 or match/3. When all table objects are matched, &#39;$end_of_table&#39; is returned."},{"ref":"dets.html#match/2","title":"dets.match/2","type":"function","doc":"Returns for each object of table Name that matches Pattern a list of bindings in some unspecified order. For a description of patterns, see ets:match/2. If the keypos&#39;th element of Pattern is unbound, all table objects are matched. If the keypos&#39;th element is bound, only the objects with the correct key are matched."},{"ref":"dets.html#match/3","title":"dets.match/3","type":"function","doc":"Matches some or all objects of table Name and returns a non-empty list of the bindings that match Pattern in some unspecified order. For a description of patterns, see ets:match/2. A tuple of the bindings and a continuation is returned, unless the table is empty, in which case &#39;$end_of_table&#39; is returned. The continuation is to be used when matching further objects by calling match/1. If the keypos&#39;th element of Pattern is bound, all table objects are matched. If the keypos&#39;th element is unbound, all table objects are matched, N objects at a time, until at least one object matches or the end of the table is reached. The default, indicated by giving N the value default, is to let the number of objects vary depending on the sizes of the objects. All objects with the same key are always matched at the same time, which implies that more than N objects can sometimes be matched. The table is always to be protected using safe_fixtable/2 before calling match/3, otherwise errors can occur when calling match/1."},{"ref":"dets.html#match_delete/2","title":"dets.match_delete/2","type":"function","doc":"Deletes all objects that match Pattern from table Name. For a description of patterns, see ets:match/2. If the keypos&#39;th element of Pattern is bound, only the objects with the correct key are matched."},{"ref":"dets.html#match_object/1","title":"dets.match_object/1","type":"function","doc":"Returns a non-empty list of some objects stored in a table that match a given pattern in some unspecified order. The table, the pattern, and the number of objects that are matched are all defined by Continuation, which has been returned by a previous call to match_object/1 or match_object/3. When all table objects are matched, &#39;$end_of_table&#39; is returned."},{"ref":"dets.html#match_object/2","title":"dets.match_object/2","type":"function","doc":"Returns a list of all objects of table Name that match Pattern in some unspecified order. For a description of patterns, see ets:match/2. If the keypos&#39;th element of Pattern is unbound, all table objects are matched. If the keypos&#39;th element of Pattern is bound, only the objects with the correct key are matched. Using the match_object functions for traversing all table objects is more efficient than calling first/1 and next/2 or slot/2."},{"ref":"dets.html#match_object/3","title":"dets.match_object/3","type":"function","doc":"Matches some or all objects stored in table Name and returns a non-empty list of the objects that match Pattern in some unspecified order. For a description of patterns, see ets:match/2. A list of objects and a continuation is returned, unless the table is empty, in which case &#39;$end_of_table&#39; is returned. The continuation is to be used when matching further objects by calling match_object/1. If the keypos&#39;th element of Pattern is bound, all table objects are matched. If the keypos&#39;th element is unbound, all table objects are matched, N objects at a time, until at least one object matches or the end of the table is reached. The default, indicated by giving N the value default, is to let the number of objects vary depending on the sizes of the objects. All matching objects with the same key are always returned in the same reply, which implies that more than N objects can sometimes be returned. The table is always to be protected using safe_fixtable/2 before calling match_object/3, otherwise errors can occur when calling match_object/1."},{"ref":"dets.html#member/2","title":"dets.member/2","type":"function","doc":"Works like lookup/2, but does not return the objects. Returns true if one or more table elements has key Key, otherwise false."},{"ref":"dets.html#next/2","title":"dets.next/2","type":"function","doc":"Returns either the key following Key1 in table Name according to the internal order of the table, or &#39;$end_of_table&#39; if there is no next key. If an error occurs, the process is exited with an error tuple {error, Reason}. To find the first key in the table, use first/1."},{"ref":"dets.html#open_file/1","title":"dets.open_file/1","type":"function","doc":"Opens an existing table. If the table is not properly closed, it is repaired. The returned reference is to be used as the table name. This function is most useful for debugging purposes."},{"ref":"dets.html#open_file/2","title":"dets.open_file/2","type":"function","doc":"Opens a table. An empty Dets table is created if no file exists. The atom Name is the table name. The table name must be provided in all subsequent operations on the table. The name can be used by other processes as well, and many processes can share one table. If two processes open the same table by giving the same name and arguments, the table has two users. If one user closes the table, it remains open until the second user closes it. Argument Args is a list of {Key, Val} tuples, where the following values are allowed: * `{access, ` `access()``}` - Existing tables can be opened in read-only mode. A table that is opened in read-only mode is not subjected to the automatic file reparation algorithm if it is later opened after a crash. Defaults to `read_write`. * `{auto_save, ` `auto_save()``}` - The autosave interval. If the interval is an integer [`Time`](https://hexdocs.pm/elixir/Time.html), the table is flushed to disk whenever it is not accessed for [`Time`](https://hexdocs.pm/elixir/Time.html) milliseconds. A table that has been flushed requires no reparation when reopened after an uncontrolled emulator halt. If the interval is the atom `infinity`, autosave is disabled. Defaults to 180000 (3 minutes). * `{estimated_no_objects, ` `no_slots()``}` - Equivalent to option `min_no_slots`. * `{file, ` `file:name()``}` - The name of the file to be opened. Defaults to the table name. * `{max_no_slots, ` `no_slots()``}` - The maximum number of slots to be used. Defaults to 32 M, which is the maximal value. Notice that a higher value can increase the table fragmentation, and a smaller value can decrease the fragmentation, at the expense of execution time. * `{min_no_slots, ` `no_slots()``}` - Application performance can be enhanced with this flag by specifying, when the table is created, the estimated number of different keys to be stored in the table. Defaults to 256, which is the minimum value. * `{keypos, ` `keypos()``}` - The position of the element of each object to be used as key. Defaults to 1. The ability to explicitly state the key position is most convenient when we want to store Erlang records in which the first position of the record is the name of the record type. * `{ram_file, boolean()}` - Whether the table is to be kept in RAM. Keeping the table in RAM can sound like an anomaly, but can enhance the performance of applications that open a table, insert a set of objects, and then close the table. When the table is closed, its contents are written to the disk file. Defaults to `false`. * `{repair, Value}` - `Value` can be either a `boolean()` or the atom `force`. The flag specifies if the Dets server is to invoke the automatic file reparation algorithm. Defaults to `true`. If `false` is specified, no attempt is made to repair the file, and `{error, {needs_repair, FileName}}` is returned if the table must be repaired. Value force means that a reparation is made even if the table is properly closed. This is a seldom needed option. Option repair is ignored if the table is already open. * `{type, ` `type()``}` - The table type. Defaults to `set`."},{"ref":"dets.html#pid2name/1","title":"dets.pid2name/1","type":"function","doc":"Returns the table name given the pid of a process that handles requests to a table, or undefined if there is no such table. This function is meant to be used for debugging only."},{"ref":"dets.html#repair_continuation/2","title":"dets.repair_continuation/2","type":"function","doc":"This function can be used to restore an opaque continuation returned by select/3 or select/1 if the continuation has passed through external term format (been sent between nodes or stored on disk). The reason for this function is that continuation terms contain compiled match specifications and therefore are invalidated if converted to external term format. Given that the original match specification is kept intact, the continuation can be restored, meaning it can once again be used in subsequent select/1 calls even though it has been stored on disk or on another node. For more information and examples, see the ets(3) module. This function is rarely needed in application code. It is used by application Mnesia to provide distributed select/3 and select/1 sequences. A normal application would either use Mnesia or keep the continuation from being converted to external format. The reason for not having an external representation of compiled match specifications is performance. It can be subject to change in future releases, while this interface remains for backward compatibility."},{"ref":"dets.html#safe_fixtable/2","title":"dets.safe_fixtable/2","type":"function","doc":"If Fix is true, table Name is fixed (once more) by the calling process, otherwise the table is released. The table is also released when a fixing process terminates. If many processes fix a table, the table remains fixed until all processes have released it or terminated. A reference counter is kept on a per process basis, and N consecutive fixes require N releases to release the table. It is not guaranteed that calls to first/1, next/2, or select and match functions work as expected even if the table is fixed; the limited support for concurrency provided by the ets(3) module is not yet provided by Dets. Fixing a table currently only disables resizing of the hash list of the table. If objects have been added while the table was fixed, the hash list starts to grow when the table is released, which significantly slows down access to the table for a period of time."},{"ref":"dets.html#select/1","title":"dets.select/1","type":"function","doc":"Applies a match specification to some objects stored in a table and returns a non-empty list of the results. The table, the match specification, and the number of objects that are matched are all defined by Continuation, which is returned by a previous call to select/1 or select/3. When all objects of the table have been matched, &#39;$end_of_table&#39; is returned."},{"ref":"dets.html#select/2","title":"dets.select/2","type":"function","doc":"Returns the results of applying match specification MatchSpec to all or some objects stored in table Name. The order of the objects is not specified. For a description of match specifications, see the ERTS User&#39;s Guide. If the keypos&#39;th element of MatchSpec is unbound, the match specification is applied to all objects of the table. If the keypos&#39;th element is bound, the match specification is applied to the objects with the correct key(s) only. Using the select functions for traversing all objects of a table is more efficient than calling first/1 and next/2 or slot/2."},{"ref":"dets.html#select/3","title":"dets.select/3","type":"function","doc":"Returns the results of applying match specification MatchSpec to some or all objects stored in table Name. The order of the objects is not specified. For a description of match specifications, see the ERTS User&#39;s Guide. A tuple of the results of applying the match specification and a continuation is returned, unless the table is empty, in which case &#39;$end_of_table&#39; is returned. The continuation is to be used when matching more objects by calling select/1. If the keypos&#39;th element of MatchSpec is bound, the match specification is applied to all objects of the table with the correct key(s). If the keypos&#39;th element of MatchSpec is unbound, the match specification is applied to all objects of the table, N objects at a time, until at least one object matches or the end of the table is reached. The default, indicated by giving N the value default, is to let the number of objects vary depending on the sizes of the objects. All objects with the same key are always handled at the same time, which implies that the match specification can be applied to more than N objects. The table is always to be protected using safe_fixtable/2 before calling select/3, otherwise errors can occur when calling select/1."},{"ref":"dets.html#select_delete/2","title":"dets.select_delete/2","type":"function","doc":"Deletes each object from table Name such that applying match specification MatchSpec to the object returns value true. For a description of match specifications, see the ERTS User&#39;s Guide. Returns the number of deleted objects. If the keypos&#39;th element of MatchSpec is bound, the match specification is applied to the objects with the correct key(s) only."},{"ref":"dets.html#slot/2","title":"dets.slot/2","type":"function","doc":"The objects of a table are distributed among slots, starting with slot 0 and ending with slot n. Returns the list of objects associated with slot I. If I &gt; n, &#39;$end_of_table&#39; is returned."},{"ref":"dets.html#sync/1","title":"dets.sync/1","type":"function","doc":"Ensures that all updates made to table Name are written to disk. This also applies to tables that have been opened with flag ram_file set to true. In this case, the contents of the RAM file are flushed to disk. Notice that the space management data structures kept in RAM, the buddy system, is also written to the disk. This can take some time if the table is fragmented."},{"ref":"dets.html#tabletable/12","title":"dets.tabletable/12","type":"function","doc":"Returns a Query List Comprehension (QLC) query handle. The qlc(3) module provides a query language aimed mainly for Mnesia, but ETS tables, Dets tables, and lists are also recognized by qlc as sources of data. Calling dets:table/1,2 is the means to make Dets table Name usable to qlc. When there are only simple restrictions on the key position, qlc uses dets:lookup/2 to look up the keys. When that is not possible, the whole table is traversed. Option traverse determines how this is done: * `first_next` - The table is traversed one key at a time by calling `dets:first/1` and `dets:next/2`. * `select` - The table is traversed by calling `dets:select/3` and `dets:select/1`. Option `n_objects` determines the number of objects returned (the third argument of [`select/3`](#select/3)). The match specification (the second argument of [`select/3`](#select/3)) is assembled by `qlc`: * Simple filters are translated into equivalent match specifications. * More complicated filters must be applied to all objects returned by [`select/3`](#select/3) given a match specification that matches all objects. * `{select, ` match_spec()`}` - As for `select`, the table is traversed by calling `dets:select/3` and `dets:select/1`. The difference is that the match specification is specified explicitly. This is how to state match specifications that cannot easily be expressed within the syntax provided by `qlc`. The following example uses an explicit match specification to traverse the table: 1&gt; dets:open_file(t, []), ok = dets:insert(t, [{1,a},{2,b},{3,c},{4,d}]), MS = ets:fun2ms(fun({X,Y}) when (X &gt; 1) or (X &lt; 5) -&gt; {Y} end), QH1 = dets:table(t, [{traverse, {select, MS}}]). An example with implicit match specification: 2&gt; QH2 = qlc:q([{Y} || {X,Y} &lt;- dets:table(t), (X &gt; 1) or (X &lt; 5)]). The latter example is equivalent to the former, which can be verified using function qlc:info/1: 3&gt; qlc:info(QH1) =:= qlc:info(QH2). true qlc:info/1 returns information about a query handle. In this case identical information is returned for the two query handles."},{"ref":"dets.html#to_ets/2","title":"dets.to_ets/2","type":"function","doc":"Inserts the objects of the Dets table Name into the ETS table EtsTab. The order in which the objects are inserted is not specified. The existing objects of the ETS table are kept unless overwritten."},{"ref":"dets.html#traverse/2","title":"dets.traverse/2","type":"function","doc":"Applies Fun to each object stored in table Name in some unspecified order. Different actions are taken depending on the return value of Fun. The following Fun return values are allowed: continue * Continue to perform the traversal. For example, the following function can be used to print the contents of a table: fun(X) -&gt; io:format(&quot;~p~n&quot;, [X]), continue end. {continue, Val} * Continue the traversal and accumulate Val. The following function is supplied to collect all objects of a table in a list: fun(X) -&gt; {continue, X} end. {done, ``Value``} * Terminate the traversal and return [``Value`` | Acc]. Any other value OtherValue returned by Fun terminates the traversal and is returned immediately."},{"ref":"dets.html#update_counter/3","title":"dets.update_counter/3","type":"function","doc":"Updates the object with key Key stored in table Name of type set by adding Incr to the element at the Pos:th position. The new counter value is returned. If no position is specified, the element directly following the key is updated. This functions provides a way of updating a counter, without having to look up an object, update the object by incrementing an element, and insert the resulting object into the table again."},{"ref":"dict.html","title":"dict","type":"module","doc":"This module provides a Key-Value dictionary. The representation of a dictionary is not defined. This module provides the same interface as the orddict(3) module. One difference is that while this module considers two keys as different if they do not match (=:=), orddict considers two keys as different if and only if they do not compare equal (==)."},{"ref":"dict.html#append/3","title":"dict.append/3","type":"function","doc":"Appends a new Value to the current list of values associated with Key. See also section Notes."},{"ref":"dict.html#append_list/3","title":"dict.append_list/3","type":"function","doc":"Appends a list of values ValList to the current list of values associated with Key. An exception is generated if the initial value associated with Key is not a list of values. See also section Notes."},{"ref":"dict.html#erase/2","title":"dict.erase/2","type":"function","doc":"Erases all items with a given key from a dictionary."},{"ref":"dict.html#fetch/2","title":"dict.fetch/2","type":"function","doc":"Returns the value associated with Key in dictionary Dict. This function assumes that Key is present in dictionary Dict, and an exception is generated if Key is not in the dictionary. See also section Notes."},{"ref":"dict.html#fetch_keys/1","title":"dict.fetch_keys/1","type":"function","doc":"Returns a list of all keys in dictionary Dict."},{"ref":"dict.html#filter/2","title":"dict.filter/2","type":"function","doc":"Dict2 is a dictionary of all keys and values in Dict1 for which Pred``(``Key``, ``Value``) is true."},{"ref":"dict.html#find/2","title":"dict.find/2","type":"function","doc":"Searches for a key in dictionary Dict. Returns {ok, ``Value``}, where Value is the value associated with Key, or error if the key is not present in the dictionary. See also section Notes."},{"ref":"dict.html#fold/3","title":"dict.fold/3","type":"function","doc":"Calls Fun on successive keys and values of dictionary Dict together with an extra argument Acc (short for accumulator). Fun must return a new accumulator that is passed to the next call. Acc0 is returned if the dictionary is empty. The evaluation order is undefined."},{"ref":"dict.html#from_list/1","title":"dict.from_list/1","type":"function","doc":"Converts the Key-Value list List to dictionary Dict."},{"ref":"dict.html#is_empty/1","title":"dict.is_empty/1","type":"function","doc":"Returns true if dictionary Dict has no elements, otherwise false."},{"ref":"dict.html#is_key/2","title":"dict.is_key/2","type":"function","doc":"Tests if Key is contained in dictionary Dict."},{"ref":"dict.html#map/2","title":"dict.map/2","type":"function","doc":"Calls Fun on successive keys and values of dictionary Dict1 to return a new value for each key. The evaluation order is undefined."},{"ref":"dict.html#merge/3","title":"dict.merge/3","type":"function","doc":"Merges two dictionaries, Dict1 and Dict2, to create a new dictionary. All the Key-Value pairs from both dictionaries are included in the new dictionary. If a key occurs in both dictionaries, Fun is called with the key and both values to return a new value. merge can be defined as follows, but is faster: merge(Fun, D1, D2) -&gt; fold(fun (K, V1, D) -&gt; update(K, fun (V2) -&gt; Fun(K, V1, V2) end, V1, D) end, D2, D1)."},{"ref":"dict.html#new/0","title":"dict.new/0","type":"function","doc":"Creates a new dictionary."},{"ref":"dict.html#size/1","title":"dict.size/1","type":"function","doc":"Returns the number of elements in dictionary Dict."},{"ref":"dict.html#store/3","title":"dict.store/3","type":"function","doc":"Stores a Key-Value pair in dictionary Dict2. If Key already exists in Dict1, the associated value is replaced by Value."},{"ref":"dict.html#take/2","title":"dict.take/2","type":"function","doc":"This function returns value from dictionary and a new dictionary without this value. Returns error if the key is not present in the dictionary."},{"ref":"dict.html#to_list/1","title":"dict.to_list/1","type":"function","doc":"Converts dictionary Dict to a list representation."},{"ref":"dict.html#update/3","title":"dict.update/3","type":"function","doc":"Updates a value in a dictionary by calling Fun on the value to get a new value. An exception is generated if Key is not present in the dictionary."},{"ref":"dict.html#update/4","title":"dict.update/4","type":"function","doc":"Updates a value in a dictionary by calling Fun on the value to get a new value. If Key is not present in the dictionary, Initial is stored as the first value. For example, append/3 can be defined as: append(Key, Val, D) -&gt; update(Key, fun (Old) -&gt; Old ++ [Val] end, [Val], D)."},{"ref":"dict.html#update_counter/3","title":"dict.update_counter/3","type":"function","doc":"Adds Increment to the value associated with Key and stores this value. If Key is not present in the dictionary, Increment is stored as the first value. This can be defined as follows, but is faster: update_counter(Key, Incr, D) -&gt; update(Key, fun (Old) -&gt; Old + Incr end, Incr, D)."},{"ref":"digraph.html","title":"digraph","type":"module","doc":"This module provides a version of labeled directed graphs (&quot;digraphs&quot;). The digraphs managed by this module are stored in ETS tables. That implies the following: * Only the process that created the digraph is allowed to update it. Digraphs will not be garbage collected. The ETS tables used for a digraph will only be deleted when delete/1 is called or the process that created the digraph terminates. A digraph is a mutable data structure. What makes the graphs provided here non-proper directed graphs is that multiple edges between vertices are allowed. However, the customary definition of directed graphs is used here. A directed graph (or just &quot;digraph&quot;) is a pair (V,E) of a finite set V of vertices and a finite set E of directed edges (or just &quot;edges&quot;). The set of edges E is a subset of VV (the Cartesian product of V with itself). In this module, V is allowed to be empty. The so obtained unique digraph is called the empty digraph. Both vertices and edges are represented by unique Erlang terms. * Digraphs can be annotated with more information. Such information can be attached to the vertices and to the edges of the digraph. An annotated digraph is called a labeled digraph, and the information attached to a vertex or an edge is called a label. Labels are Erlang terms. * An edge e=(v,w) is said to emanate from vertex v and to be incident on vertex w. * The out-degree of a vertex is the number of edges emanating from that vertex. * The in-degree of a vertex is the number of edges incident on that vertex. * If an edge is emanating from v and incident on w, then w is said to be an out-neighbor of v, and v is said to be an in-neighbor of w. * A path P from v[1] to v[k] in a digraph (V,E) is a non-empty sequence v[1],v[2],...,v[k] of vertices in V such that there is an edge (v[i],v[i+1]) in E for 1&lt;=i&lt;k. * The length of path P is k-1. * Path P is simple if all vertices are distinct, except that the first and the last vertices can be the same. * Path P is a cycle if the length of P is not zero and v[1] = v[k]. * A loop is a cycle of length one. * A simple cycle is a path that is both a cycle and simple. * An acyclic digraph is a digraph without cycles."},{"ref":"digraph.html#add_edgeadd_edgeadd_edge/345","title":"digraph.add_edgeadd_edgeadd_edge/345","type":"function","doc":"add_edge/5 creates (or modifies) edge E of digraph G, using Label as the (new) label of the edge. The edge is emanating from V1 and incident on V2. Returns E. add_edge(``G``,````V1``,````V2``,````Label``) is equivalent to add_edge(``G``,````E``,````V1``,````V2``,````Label``), where E is a created edge. The created edge is represented by term [&#39;$e&#39;|N], where N is an integer&gt;=0. add_edge(``G``,````V1``,````V2``) is equivalent to add_edge(``G``,````V1``,````V2``,``[]). If the edge would create a cycle in an acyclic digraph, {error,{bad_edge,``Path``}} is returned. If G already has an edge with value E connecting a different pair of vertices, {error,{bad_edge,[``V1``,````V2``]}} is returned. If either of V1 or V2 is not a vertex of digraph G, {error,{bad_vertex,V}} is returned, V=V1 or V=V2."},{"ref":"digraph.html#add_vertexadd_vertexadd_vertex/123","title":"digraph.add_vertexadd_vertexadd_vertex/123","type":"function","doc":"add_vertex/3 creates (or modifies) vertex V of digraph G, using Label as the (new) label of the vertex. Returns V. add_vertex(``G``,````V``) is equivalent to add_vertex(``G``,````V``,``[]). add_vertex/1 creates a vertex using the empty list as label, and returns the created vertex. The created vertex is represented by term [&#39;$v&#39;|N], where N is an integer&gt;=0."},{"ref":"digraph.html#del_edge/2","title":"digraph.del_edge/2","type":"function","doc":"Deletes edge E from digraph G."},{"ref":"digraph.html#del_edges/2","title":"digraph.del_edges/2","type":"function","doc":"Deletes the edges in list Edges from digraph G."},{"ref":"digraph.html#del_path/3","title":"digraph.del_path/3","type":"function","doc":"Deletes edges from digraph G until there are no paths from vertex V1 to vertex V2. A sketch of the procedure employed: * Find an arbitrary simple path v[1],v[2],...,v[k] from `V1` to `V2` in `G`. * Remove all edges of `G` emanating from v[i] and incident to v[i+1] for 1&lt;=i&lt;k (including multiple edges). * Repeat until there is no path between `V1` and `V2`."},{"ref":"digraph.html#del_vertex/2","title":"digraph.del_vertex/2","type":"function","doc":"Deletes vertex V from digraph G. Any edges emanating from V or incident on V are also deleted."},{"ref":"digraph.html#del_vertices/2","title":"digraph.del_vertices/2","type":"function","doc":"Deletes the vertices in list Vertices from digraph G."},{"ref":"digraph.html#delete/1","title":"digraph.delete/1","type":"function","doc":"Deletes digraph G. This call is important as digraphs are implemented with ETS. There is no garbage collection of ETS tables. However, the digraph is deleted if the process that created the digraph terminates."},{"ref":"digraph.html#edge/2","title":"digraph.edge/2","type":"function","doc":"Returns {``E``,````V1``,````V2``,````Label``}, where Label is the label of edge E emanating from V1 and incident on V2 of digraph G. If no edge E of digraph G exists, false is returned."},{"ref":"digraph.html#edges/1","title":"digraph.edges/1","type":"function","doc":"Returns a list of all edges of digraph G, in some unspecified order."},{"ref":"digraph.html#edges/2","title":"digraph.edges/2","type":"function","doc":"Returns a list of all edges emanating from or incident onV of digraph G, in some unspecified order."},{"ref":"digraph.html#get_cycle/2","title":"digraph.get_cycle/2","type":"function","doc":"If a simple cycle of length two or more exists through vertex V, the cycle is returned as a list [``V``,``...,````V``] of vertices. If a loop through V exists, the loop is returned as a list [``V``]. If no cycles through V exist, false is returned. get_path/3 is used for finding a simple cycle through V."},{"ref":"digraph.html#get_path/3","title":"digraph.get_path/3","type":"function","doc":"Tries to find a simple path from vertex V1 to vertex V2 of digraph G. Returns the path as a list [``V1``,``...,````V2``] of vertices, or false if no simple path from V1 to V2 of length one or more exists. Digraph G is traversed in a depth-first manner, and the first found path is returned."},{"ref":"digraph.html#get_short_cycle/2","title":"digraph.get_short_cycle/2","type":"function","doc":"Tries to find an as short as possible simple cycle through vertex V of digraph G. Returns the cycle as a list [``V``,``...,````V``] of vertices, or false if no simple cycle through V exists. Notice that a loop through V is returned as list [``V``,````V``]. get_short_path/3 is used for finding a simple cycle through V."},{"ref":"digraph.html#get_short_path/3","title":"digraph.get_short_path/3","type":"function","doc":"Tries to find an as short as possible simple path from vertex V1 to vertex V2 of digraph G. Returns the path as a list [``V1``,``...,````V2``] of vertices, or false if no simple path from V1 to V2 of length one or more exists. Digraph G is traversed in a breadth-first manner, and the first found path is returned."},{"ref":"digraph.html#in_degree/2","title":"digraph.in_degree/2","type":"function","doc":"Returns the in-degree of vertex V of digraph G."},{"ref":"digraph.html#in_edges/2","title":"digraph.in_edges/2","type":"function","doc":"Returns a list of all edges incident on V of digraph G, in some unspecified order."},{"ref":"digraph.html#in_neighbours/2","title":"digraph.in_neighbours/2","type":"function","doc":"Returns a list of all in-neighbors of V of digraph G, in some unspecified order."},{"ref":"digraph.html#info/1","title":"digraph.info/1","type":"function","doc":"Returns a list of {Tag, Value} pairs describing digraph G. The following pairs are returned: * `{cyclicity, ``Cyclicity``}`, where `Cyclicity` is `cyclic` or `acyclic`, according to the options given to `new`. * `{memory, ``NoWords``}`, where `NoWords` is the number of words allocated to the ETS tables. * `{protection, ``Protection``}`, where `Protection` is `protected` or `private`, according to the options given to `new`."},{"ref":"digraph.html#new/0","title":"digraph.new/0","type":"function","doc":"Equivalent to new([])."},{"ref":"digraph.html#new/1","title":"digraph.new/1","type":"function","doc":"Returns an empty digraph with properties according to the options in Type: cyclic * Allows cycles in the digraph (default). acyclic * The digraph is to be kept acyclic. protected * Other processes can read the digraph (default). private * The digraph can be read and modified by the creating process only. If an unrecognized type option T is specified or Type is not a proper list, a badarg exception is raised."},{"ref":"digraph.html#no_edges/1","title":"digraph.no_edges/1","type":"function","doc":"Returns the number of edges of digraph G."},{"ref":"digraph.html#no_vertices/1","title":"digraph.no_vertices/1","type":"function","doc":"Returns the number of vertices of digraph G."},{"ref":"digraph.html#out_degree/2","title":"digraph.out_degree/2","type":"function","doc":"Returns the out-degree of vertex V of digraph G."},{"ref":"digraph.html#out_edges/2","title":"digraph.out_edges/2","type":"function","doc":"Returns a list of all edges emanating from V of digraph G, in some unspecified order."},{"ref":"digraph.html#out_neighbours/2","title":"digraph.out_neighbours/2","type":"function","doc":"Returns a list of all out-neighbors of V of digraph G, in some unspecified order."},{"ref":"digraph.html#vertex/2","title":"digraph.vertex/2","type":"function","doc":"Returns {``V``,````Label``}, where Label is the label of the vertex V of digraph G, or false if no vertex V of digraph G exists."},{"ref":"digraph.html#vertices/1","title":"digraph.vertices/1","type":"function","doc":"Returns a list of all vertices of digraph G, in some unspecified order."},{"ref":"digraph_utils.html","title":"digraph_utils","type":"module","doc":"This module provides algorithms based on depth-first traversal of directed graphs. For basic functions on directed graphs, see the digraph(3) module. * A directed graph (or just &quot;digraph&quot;) is a pair (V,E) of a finite set V of vertices and a finite set E of directed edges (or just &quot;edges&quot;). The set of edges E is a subset of VV (the Cartesian product of V with itself). * Digraphs can be annotated with more information. Such information can be attached to the vertices and to the edges of the digraph. An annotated digraph is called a labeled digraph, and the information attached to a vertex or an edge is called a label. * An edge e=(v,w) is said to emanate from vertex v and to be incident on vertex w. * If an edge is emanating from v and incident on w, then w is said to be an out-neighbor of v, and v is said to be an in-neighbor of w. * A path P from v[1] to v[k] in a digraph (V,E) is a non-empty sequence v[1],v[2],...,v[k] of vertices in V such that there is an edge (v[i],v[i+1]) in E for 1&lt;=i&lt;k. * The length of path P is k-1. * Path P is a cycle if the length of P is not zero and v[1] = v[k]. * A loop is a cycle of length one. * An acyclic digraph is a digraph without cycles. * A depth-first traversal of a directed digraph can be viewed as a process that visits all vertices of the digraph. Initially, all vertices are marked as unvisited. The traversal starts with an arbitrarily chosen vertex, which is marked as visited, and follows an edge to an unmarked vertex, marking that vertex. The search then proceeds from that vertex in the same fashion, until there is no edge leading to an unvisited vertex. At that point the process backtracks, and the traversal continues as long as there are unexamined edges. If unvisited vertices remain when all edges from the first vertex have been examined, some so far unvisited vertex is chosen, and the process is repeated. * A partial ordering of a set S is a transitive, antisymmetric, and reflexive relation between the objects of S. * The problem of topological sorting is to find a total ordering of S that is a superset of the partial ordering. A digraph G=(V,E) is equivalent to a relation E on V (we neglect that the version of directed graphs provided by the `digraph` module allows multiple edges between vertices). If the digraph has no cycles of length two or more, the reflexive and transitive closure of E is a partial ordering. * A subgraph G&#39; of G is a digraph whose vertices and edges form subsets of the vertices and edges of G. * G&#39; is maximal with respect to a property P if all other subgraphs that include the vertices of G&#39; do not have property P. * A strongly connected component is a maximal subgraph such that there is a path between each pair of vertices. * A connected component is a maximal subgraph such that there is a path between each pair of vertices, considering all edges undirected. * An arborescence is an acyclic digraph with a vertex V, the root, such that there is a unique path from V to every other vertex of G. * A tree is an acyclic non-empty digraph such that there is a unique path between every pair of vertices, considering all edges undirected."},{"ref":"digraph_utils.html#arborescence_root/1","title":"digraph_utils.arborescence_root/1","type":"function","doc":"Returns {yes, ``Root``} if Root is the root of the arborescence Digraph, otherwise no."},{"ref":"digraph_utils.html#components/1","title":"digraph_utils.components/1","type":"function","doc":"Returns a list of connected components.. Each component is represented by its vertices. The order of the vertices and the order of the components are arbitrary. Each vertex of digraph Digraph occurs in exactly one component."},{"ref":"digraph_utils.html#condensation/1","title":"digraph_utils.condensation/1","type":"function","doc":"Creates a digraph where the vertices are the strongly connected components of Digraph as returned by strong_components/1. If X and Y are two different strongly connected components, and vertices x and y exist in X and Y, respectively, such that there is an edge emanating from x and incident on y, then an edge emanating from X and incident on Y is created. The created digraph has the same type as Digraph. All vertices and edges have the default label []. Each cycle is included in some strongly connected component, which implies that a topological ordering of the created digraph always exists."},{"ref":"digraph_utils.html#cyclic_strong_components/1","title":"digraph_utils.cyclic_strong_components/1","type":"function","doc":"Returns a list of strongly connected components. Each strongly component is represented by its vertices. The order of the vertices and the order of the components are arbitrary. Only vertices that are included in some cycle in Digraph are returned, otherwise the returned list is equal to that returned by strong_components/1."},{"ref":"digraph_utils.html#is_acyclic/1","title":"digraph_utils.is_acyclic/1","type":"function","doc":"Returns true if and only if digraph Digraph is acyclic."},{"ref":"digraph_utils.html#is_arborescence/1","title":"digraph_utils.is_arborescence/1","type":"function","doc":"Returns true if and only if digraph Digraph is an arborescence."},{"ref":"digraph_utils.html#is_tree/1","title":"digraph_utils.is_tree/1","type":"function","doc":"Returns true if and only if digraph Digraph is a tree."},{"ref":"digraph_utils.html#loop_vertices/1","title":"digraph_utils.loop_vertices/1","type":"function","doc":"Returns a list of all vertices of Digraph that are included in some loop."},{"ref":"digraph_utils.html#postorder/1","title":"digraph_utils.postorder/1","type":"function","doc":"Returns all vertices of digraph Digraph. The order is given by a depth-first traversal of the digraph, collecting visited vertices in postorder. More precisely, the vertices visited while searching from an arbitrarily chosen vertex are collected in postorder, and all those collected vertices are placed before the subsequently visited vertices."},{"ref":"digraph_utils.html#preorder/1","title":"digraph_utils.preorder/1","type":"function","doc":"Returns all vertices of digraph Digraph. The order is given by a depth-first traversal of the digraph, collecting visited vertices in preorder."},{"ref":"digraph_utils.html#reachable/2","title":"digraph_utils.reachable/2","type":"function","doc":"Returns an unsorted list of digraph vertices such that for each vertex in the list, there is a path in Digraph from some vertex of Vertices to the vertex. In particular, as paths can have length zero, the vertices of Vertices are included in the returned list."},{"ref":"digraph_utils.html#reachable_neighbours/2","title":"digraph_utils.reachable_neighbours/2","type":"function","doc":"Returns an unsorted list of digraph vertices such that for each vertex in the list, there is a path in Digraph of length one or more from some vertex of Vertices to the vertex. As a consequence, only those vertices of Vertices that are included in some cycle are returned."},{"ref":"digraph_utils.html#reaching/2","title":"digraph_utils.reaching/2","type":"function","doc":"Returns an unsorted list of digraph vertices such that for each vertex in the list, there is a path from the vertex to some vertex of Vertices. In particular, as paths can have length zero, the vertices of Vertices are included in the returned list."},{"ref":"digraph_utils.html#reaching_neighbours/2","title":"digraph_utils.reaching_neighbours/2","type":"function","doc":"Returns an unsorted list of digraph vertices such that for each vertex in the list, there is a path of length one or more from the vertex to some vertex of Vertices. Therefore only those vertices of Vertices that are included in some cycle are returned."},{"ref":"digraph_utils.html#strong_components/1","title":"digraph_utils.strong_components/1","type":"function","doc":"Returns a list of strongly connected components. Each strongly component is represented by its vertices. The order of the vertices and the order of the components are arbitrary. Each vertex of digraph Digraph occurs in exactly one strong component."},{"ref":"digraph_utils.html#subgraphsubgraph/23","title":"digraph_utils.subgraphsubgraph/23","type":"function","doc":"Creates a maximal subgraph of Digraph having as vertices those vertices of Digraph that are mentioned in Vertices. If the value of option type is inherit, which is the default, the type of Digraph is used for the subgraph as well. Otherwise the option value of type is used as argument to digraph:new/1. If the value of option keep_labels is true, which is the default, the labels of vertices and edges of Digraph are used for the subgraph as well. If the value is false, default label [] is used for the vertices and edges of the subgroup. subgraph(``Digraph``, ``Vertices``) is equivalent to subgraph(``Digraph``, ``Vertices``, []). If any of the arguments are invalid, a badarg exception is raised."},{"ref":"digraph_utils.html#topsort/1","title":"digraph_utils.topsort/1","type":"function","doc":"Returns a topological ordering of the vertices of digraph Digraph if such an ordering exists, otherwise false. For each vertex in the returned list, no out-neighbors occur earlier in the list."},{"ref":"epp.html","title":"epp","type":"module","doc":"The Erlang code preprocessor includes functions that are used by the compile module to preprocess macros and include files before the parsing takes place. The Erlang source file encoding is selected by a comment in one of the first two lines of the source file. The first string matching the regular expression coding\\s*[:=]\\s*([-a-zA-Z0-9])+ selects the encoding. If the matching string is not a valid encoding, it is ignored. The valid encodings are Latin-1 and UTF-8, where the case of the characters can be chosen freely. Examples: %% coding: utf-8 %% For this file we have chosen encoding = Latin-1 %% -*- coding: latin-1 -*-"},{"ref":"epp.html#close/1","title":"epp.close/1","type":"function","doc":"Closes the preprocessing of a file."},{"ref":"epp.html#default_encoding/0","title":"epp.default_encoding/0","type":"function","doc":"Returns the default encoding of Erlang source files."},{"ref":"epp.html#encoding_to_string/1","title":"epp.encoding_to_string/1","type":"function","doc":"Returns a string representation of an encoding. The string is recognized by read_encoding/1,2, read_encoding_from_binary/1,2, and set_encoding/1,2 as a valid encoding."},{"ref":"epp.html#format_error/1","title":"epp.format_error/1","type":"function","doc":"Takes an ErrorDescriptor and returns a string that describes the error or warning. This function is usually called implicitly when processing an ErrorInfo structure (see section Error Information)."},{"ref":"epp.html#open/1","title":"epp.open/1","type":"function","doc":"Opens a file for preprocessing. If you want to change the file name of the implicit -file() attributes inserted during preprocessing, you can do with {source_name, ``SourceName``}. If unset it will default to the name of the opened file. If extra is specified in Options, the return value is {ok, ``Epp``, ``Extra``} instead of {ok, ``Epp``}."},{"ref":"epp.html#open/2","title":"epp.open/2","type":"function","doc":"Equivalent to epp:open([{name, FileName}, {includes, IncludePath}])."},{"ref":"epp.html#open/3","title":"epp.open/3","type":"function","doc":"Equivalent to epp:open([{name, FileName}, {includes, IncludePath}, {macros, PredefMacros}])."},{"ref":"epp.html#parse_erl_form/1","title":"epp.parse_erl_form/1","type":"function","doc":"Returns the next Erlang form from the opened Erlang source file. Tuple {eof, ``Line``} is returned at the end of the file. The first form corresponds to an implicit attribute -file(File,1)., where File is the file name."},{"ref":"epp.html#parse_file/2","title":"epp.parse_file/2","type":"function","doc":"Preprocesses and parses an Erlang source file. Notice that tuple {eof, ``Line``} returned at the end of the file is included as a &quot;form&quot;. If you want to change the file name of the implicit -file() attributes inserted during preprocessing, you can do with {source_name, ``SourceName``}. If unset it will default to the name of the opened file. If extra is specified in Options, the return value is {ok, [``Form``], ``Extra``} instead of {ok, [``Form``]}."},{"ref":"epp.html#parse_file/3","title":"epp.parse_file/3","type":"function","doc":"Equivalent to epp:parse_file(FileName, [{includes, IncludePath}, {macros, PredefMacros}])."},{"ref":"epp.html#read_encoding_from_binaryread_encoding_from_binary/12","title":"epp.read_encoding_from_binaryread_encoding_from_binary/12","type":"function","doc":"Read the encoding from a binary. Returns the read encoding, or none if no valid encoding is found. Option in_comment_only is true by default, which is correct for Erlang source files. If set to false, the encoding string does not necessarily have to occur in a comment."},{"ref":"epp.html#read_encodingread_encoding/12","title":"epp.read_encodingread_encoding/12","type":"function","doc":"Read the encoding from a file. Returns the read encoding, or none if no valid encoding is found. Option in_comment_only is true by default, which is correct for Erlang source files. If set to false, the encoding string does not necessarily have to occur in a comment."},{"ref":"epp.html#set_encoding/1","title":"epp.set_encoding/1","type":"function","doc":"Reads the encoding from an I/O device and sets the encoding of the device accordingly. The position of the I/O device referenced by File is not affected. If no valid encoding can be read from the I/O device, the encoding of the I/O device is set to the default encoding. Returns the read encoding, or none if no valid encoding is found."},{"ref":"epp.html#set_encoding/2","title":"epp.set_encoding/2","type":"function","doc":"Reads the encoding from an I/O device and sets the encoding of the device accordingly. The position of the I/O device referenced by File is not affected. If no valid encoding can be read from the I/O device, the encoding of the I/O device is set to the encoding specified by Default. Returns the read encoding, or none if no valid encoding is found."},{"ref":"erl_anno.html","title":"erl_anno","type":"module","doc":"This module provides an abstract type that is used by the Erlang Compiler and its helper modules for holding data such as column, line number, and text. The data type is a collection of annotations as described in the following. The Erlang Token Scanner returns tokens with a subset of the following annotations, depending on the options: column * The column where the token begins. location * The line and column where the token begins, or just the line if the column is unknown. text * The token&#39;s text. From this, the following annotation is derived: line * The line where the token begins. This module also supports the following annotations, which are used by various modules: file * A filename. generated * A Boolean indicating if the abstract code is compiler-generated. The Erlang Compiler does not emit warnings for such code. record * A Boolean indicating if the origin of the abstract code is a record. Used by Dialyzer to assign types to tuple elements. The functions column(), end_location(), line(), location(), and text() in the erl_scan module can be used for inspecting annotations in tokens. The functions anno_from_term(), anno_to_term(), fold_anno(), map_anno(), mapfold_anno(), and new_anno(), in the erl_parse module can be used for manipulating annotations in abstract code."},{"ref":"erl_anno.html#column/1","title":"erl_anno.column/1","type":"function","doc":"Returns the column of the annotations Anno."},{"ref":"erl_anno.html#end_location/1","title":"erl_anno.end_location/1","type":"function","doc":"Returns the end location of the text of the annotations Anno. If there is no text, undefined is returned."},{"ref":"erl_anno.html#file/1","title":"erl_anno.file/1","type":"function","doc":"Returns the filename of the annotations Anno. If there is no filename, undefined is returned."},{"ref":"erl_anno.html#from_term/1","title":"erl_anno.from_term/1","type":"function","doc":"Returns annotations with representation Term. See also to_term()."},{"ref":"erl_anno.html#generated/1","title":"erl_anno.generated/1","type":"function","doc":"Returns true if annotations Anno is marked as generated. The default is to return false."},{"ref":"erl_anno.html#is_anno/1","title":"erl_anno.is_anno/1","type":"function","doc":"Returns true if Term is a collection of annotations, otherwise false."},{"ref":"erl_anno.html#line/1","title":"erl_anno.line/1","type":"function","doc":"Returns the line of the annotations Anno."},{"ref":"erl_anno.html#location/1","title":"erl_anno.location/1","type":"function","doc":"Returns the location of the annotations Anno."},{"ref":"erl_anno.html#new/1","title":"erl_anno.new/1","type":"function","doc":"Creates a new collection of annotations given a location."},{"ref":"erl_anno.html#set_file/2","title":"erl_anno.set_file/2","type":"function","doc":"Modifies the filename of the annotations Anno."},{"ref":"erl_anno.html#set_generated/2","title":"erl_anno.set_generated/2","type":"function","doc":"Modifies the generated marker of the annotations Anno."},{"ref":"erl_anno.html#set_line/2","title":"erl_anno.set_line/2","type":"function","doc":"Modifies the line of the annotations Anno."},{"ref":"erl_anno.html#set_location/2","title":"erl_anno.set_location/2","type":"function","doc":"Modifies the location of the annotations Anno."},{"ref":"erl_anno.html#set_record/2","title":"erl_anno.set_record/2","type":"function","doc":"Modifies the record marker of the annotations Anno."},{"ref":"erl_anno.html#set_text/2","title":"erl_anno.set_text/2","type":"function","doc":"Modifies the text of the annotations Anno."},{"ref":"erl_anno.html#text/1","title":"erl_anno.text/1","type":"function","doc":"Returns the text of the annotations Anno. If there is no text, undefined is returned."},{"ref":"erl_anno.html#to_term/1","title":"erl_anno.to_term/1","type":"function","doc":"Returns the term representing the annotations Anno. See also from_term()."},{"ref":"erl_eval.html","title":"erl_eval","type":"module","doc":"This module provides an interpreter for Erlang expressions. The expressions are in the abstract syntax as returned by erl_parse, the Erlang parser, or io."},{"ref":"erl_eval.html#add_binding/3","title":"erl_eval.add_binding/3","type":"function","doc":"Adds binding Name``=``Value to BindingStruct. Returns an updated binding structure."},{"ref":"erl_eval.html#binding/2","title":"erl_eval.binding/2","type":"function","doc":"Returns the binding of Name in BindingStruct."},{"ref":"erl_eval.html#bindings/1","title":"erl_eval.bindings/1","type":"function","doc":"Returns the list of bindings contained in the binding structure."},{"ref":"erl_eval.html#del_binding/2","title":"erl_eval.del_binding/2","type":"function","doc":"Removes the binding of Name in BindingStruct. Returns an updated binding structure."},{"ref":"erl_eval.html#expr_listexpr_listexpr_list/234","title":"erl_eval.expr_listexpr_listexpr_list/234","type":"function","doc":"Evaluates a list of expressions in parallel, using the same initial bindings for each expression. Attempts are made to merge the bindings returned from each evaluation. This function is useful in LocalFunctionHandler, see section Local Function Handler in this module. Returns {``ValueList``, ``NewBindings``}."},{"ref":"erl_eval.html#exprexprexprexpr/2345","title":"erl_eval.exprexprexprexpr/2345","type":"function","doc":"Evaluates Expression with the set of bindings Bindings. Expression is an expression in abstract syntax. For an explanation of when and how to use arguments LocalFunctionHandler and NonLocalFunctionHandler, see sections Local Function Handler and Non-Local Function Handler in this module. Returns {value, ``Value``, ``NewBindings``} by default. If ReturnFormat is value, only Value is returned."},{"ref":"erl_eval.html#exprsexprsexprs/234","title":"erl_eval.exprsexprsexprs/234","type":"function","doc":"Evaluates Expressions with the set of bindings Bindings, where Expressions is a sequence of expressions (in abstract syntax) of a type that can be returned by io:parse_erl_exprs/2. For an explanation of when and how to use arguments LocalFunctionHandler and NonLocalFunctionHandler, see sections Local Function Handler and Non-Local Function Handler in this module. Returns {value, ``Value``, ``NewBindings``}"},{"ref":"erl_eval.html#new_bindings/0","title":"erl_eval.new_bindings/0","type":"function","doc":"Returns an empty binding structure."},{"ref":"erl_expand_records.html","title":"erl_expand_records","type":"module","doc":"This module expands records in a module."},{"ref":"erl_expand_records.html#module/2","title":"erl_expand_records.module/2","type":"function","doc":"Expands all records in a module to use explicit tuple operations and adds explicit module names to calls to BIFs and imported functions. The returned module has no references to records, attributes, or code."},{"ref":"erl_internal.html","title":"erl_internal","type":"module","doc":"This module defines Erlang BIFs, guard tests, and operators. This module is only of interest to programmers who manipulate Erlang code."},{"ref":"erl_internal.html#add_predefined_functions/1","title":"erl_internal.add_predefined_functions/1","type":"function","doc":"Adds to Forms the code for the standard pre-defined functions (such as module_info/0) that are to be included in every module."},{"ref":"erl_internal.html#arith_op/2","title":"erl_internal.arith_op/2","type":"function","doc":"Returns true if OpName``/``Arity is an arithmetic operator, otherwise false."},{"ref":"erl_internal.html#bif/2","title":"erl_internal.bif/2","type":"function","doc":"Returns true if Name``/``Arity is an Erlang BIF that is automatically recognized by the compiler, otherwise false."},{"ref":"erl_internal.html#bool_op/2","title":"erl_internal.bool_op/2","type":"function","doc":"Returns true if OpName``/``Arity is a Boolean operator, otherwise false."},{"ref":"erl_internal.html#comp_op/2","title":"erl_internal.comp_op/2","type":"function","doc":"Returns true if OpName``/``Arity is a comparison operator, otherwise false."},{"ref":"erl_internal.html#guard_bif/2","title":"erl_internal.guard_bif/2","type":"function","doc":"Returns true if Name``/``Arity is an Erlang BIF that is allowed in guards, otherwise false."},{"ref":"erl_internal.html#list_op/2","title":"erl_internal.list_op/2","type":"function","doc":"Returns true if OpName``/``Arity is a list operator, otherwise false."},{"ref":"erl_internal.html#op_type/2","title":"erl_internal.op_type/2","type":"function","doc":"Returns the Type of operator that OpName``/``Arity belongs to, or generates a function_clause error if it is not an operator."},{"ref":"erl_internal.html#send_op/2","title":"erl_internal.send_op/2","type":"function","doc":"Returns true if OpName``/``Arity is a send operator, otherwise false."},{"ref":"erl_internal.html#type_test/2","title":"erl_internal.type_test/2","type":"function","doc":"Returns true if Name``/``Arity is a valid Erlang type test, otherwise false."},{"ref":"erl_lint.html","title":"erl_lint","type":"module","doc":"This module is used to check Erlang code for illegal syntax and other bugs. It also warns against coding practices that are not recommended. The errors detected include: * Redefined and undefined functions * Unbound and unsafe variables * Illegal record use The warnings detected include: * Unused functions and imports * Unused variables * Variables imported into matches * Variables exported from `if`/`case`/`receive` * Variables shadowed in funs and list comprehensions Some of the warnings are optional, and can be turned on by specifying the appropriate option, described below. The functions in this module are invoked automatically by the Erlang compiler. There is no reason to invoke these functions separately unless you have written your own Erlang compiler."},{"ref":"erl_lint.html#format_error/1","title":"erl_lint.format_error/1","type":"function","doc":"Takes an ErrorDescriptor and returns a string that describes the error or warning. This function is usually called implicitly when processing an ErrorInfo structure (see section Error Information)."},{"ref":"erl_lint.html#is_guard_test/1","title":"erl_lint.is_guard_test/1","type":"function","doc":"Tests if Expr is a legal guard test. Expr is an Erlang term representing the abstract form for the expression. erl_parse:parse_exprs(Tokens) can be used to generate a list of Expr."},{"ref":"erl_lint.html#modulemodulemodule/123","title":"erl_lint.modulemodulemodule/123","type":"function","doc":"Checks all the forms in a module for errors. It returns: {ok,``Warnings``} * There are no errors in the module. {error,``Errors``,``Warnings``} * There are errors in the module. As this module is of interest only to the maintainers of the compiler, and to avoid the same description in two places, the elements of Options that control the warnings are only described in the compile(3) module. AbsForms of a module, which comes from a file that is read through epp, the Erlang preprocessor, can come from many files. This means that any references to errors must include the filename, see the epp(3) module or parser (see the erl_parse(3) module). The returned errors and warnings have the following format: [{FileName2,[ErrorInfo]}] The errors and warnings are listed in the order in which they are encountered in the forms. The errors from one file can therefore be split into different entries in the list of errors."},{"ref":"erl_parse.html","title":"erl_parse","type":"module","doc":"This module is the basic Erlang parser that converts tokens into the abstract form of either forms (that is, top-level constructs), expressions, or terms. The Abstract Format is described in the ERTS User&#39;s Guide. Notice that a token list must end with the dot token to be acceptable to the parse functions (see the erl_scan(3)) module."},{"ref":"erl_parse.html#abstract/1","title":"erl_parse.abstract/1","type":"function","doc":"Converts the Erlang data structure Data into an abstract form of type AbsTerm. This function is the inverse of normalise/1. erl_parse:abstract(T) is equivalent to erl_parse:abstract(T, 0)."},{"ref":"erl_parse.html#abstract/2","title":"erl_parse.abstract/2","type":"function","doc":"Converts the Erlang data structure Data into an abstract form of type AbsTerm. Option Line is the line to be assigned to each node of AbsTerm. Option Encoding is used for selecting which integer lists to be considered as strings. The default is to use the encoding returned by function epp:default_encoding/0. Value none means that no integer lists are considered as strings. encoding_func() is called with one integer of a list at a time; if it returns true for every integer, the list is considered a string."},{"ref":"erl_parse.html#anno_from_term/1","title":"erl_parse.anno_from_term/1","type":"function","doc":"Assumes that Term is a term with the same structure as a erl_parse tree, but with terms, say T, where a erl_parse tree has collections of annotations. Returns a erl_parse tree where each term T is replaced by the value returned by erl_anno:from_term(T). The term Term is traversed in a depth-first, left-to-right fashion."},{"ref":"erl_parse.html#anno_to_term/1","title":"erl_parse.anno_to_term/1","type":"function","doc":"Returns a term where each collection of annotations Anno of the nodes of the erl_parse tree Abstr is replaced by the term returned by erl_anno:to_term(Anno). The erl_parse tree is traversed in a depth-first, left-to-right fashion."},{"ref":"erl_parse.html#fold_anno/3","title":"erl_parse.fold_anno/3","type":"function","doc":"Updates an accumulator by applying Fun on each collection of annotations of the erl_parse tree Abstr. The first call to Fun has AccIn as argument, the returned accumulator AccOut is passed to the next call, and so on. The final value of the accumulator is returned. The erl_parse tree is traversed in a depth-first, left-to-right fashion."},{"ref":"erl_parse.html#map_anno/2","title":"erl_parse.map_anno/2","type":"function","doc":"Modifies the erl_parse tree Abstr by applying Fun on each collection of annotations of the nodes of the erl_parse tree. The erl_parse tree is traversed in a depth-first, left-to-right fashion."},{"ref":"erl_parse.html#mapfold_anno/3","title":"erl_parse.mapfold_anno/3","type":"function","doc":"Modifies the erl_parse tree Abstr by applying Fun on each collection of annotations of the nodes of the erl_parse tree, while at the same time updating an accumulator. The first call to Fun has AccIn as second argument, the returned accumulator AccOut is passed to the next call, and so on. The modified erl_parse tree and the final value of the accumulator are returned. The erl_parse tree is traversed in a depth-first, left-to-right fashion."},{"ref":"erl_parse.html#new_anno/1","title":"erl_parse.new_anno/1","type":"function","doc":"Assumes that Term is a term with the same structure as a erl_parse tree, but with locations where a erl_parse tree has collections of annotations. Returns a erl_parse tree where each location L is replaced by the value returned by erl_anno:new(L). The term Term is traversed in a depth-first, left-to-right fashion."},{"ref":"erl_parse.html#normalise/1","title":"erl_parse.normalise/1","type":"function","doc":"Converts the abstract form AbsTerm of a term into a conventional Erlang data structure (that is, the term itself). This function is the inverse of abstract/1."},{"ref":"erl_parse.html#parse_exprs/1","title":"erl_parse.parse_exprs/1","type":"function","doc":"Parses Tokens as if it was a list of expressions. Returns one of the following: {ok, ``ExprList``} * The parsing was successful. ExprList is a list of the abstract forms of the parsed expressions. {error, ``ErrorInfo``} * An error occurred."},{"ref":"erl_parse.html#parse_form/1","title":"erl_parse.parse_form/1","type":"function","doc":"Parses Tokens as if it was a form. Returns one of the following: {ok, ``AbsForm``} * The parsing was successful. AbsForm is the abstract form of the parsed form. {error, ``ErrorInfo``} * An error occurred."},{"ref":"erl_parse.html#parse_term/1","title":"erl_parse.parse_term/1","type":"function","doc":"Parses Tokens as if it was a term. Returns one of the following: {ok, ``Term``} * The parsing was successful. Term is the Erlang term corresponding to the token list. {error, ``ErrorInfo``} * An error occurred."},{"ref":"erl_parse.html#tokenstokens/12","title":"erl_parse.tokenstokens/12","type":"function","doc":"Generates a list of tokens representing the abstract form AbsTerm of an expression. Optionally, MoreTokens is appended."},{"ref":"erl_pp.html","title":"erl_pp","type":"module","doc":"The functions in this module are used to generate aesthetically attractive representations of abstract forms, which are suitable for printing. All functions return (possibly deep) lists of characters and generate an error if the form is wrong. All functions can have an optional argument, which specifies a hook that is called if an attempt is made to print an unknown form."},{"ref":"erl_pp.html#attributeattribute/12","title":"erl_pp.attributeattribute/12","type":"function","doc":"Same as form/1,2, but only for attribute Attribute."},{"ref":"erl_pp.html#exprexprexprexpr/1234","title":"erl_pp.exprexprexprexpr/1234","type":"function","doc":"Prints one expression. It is useful for implementing hooks (see section Known Limitations)."},{"ref":"erl_pp.html#exprsexprsexprs/123","title":"erl_pp.exprsexprsexprs/123","type":"function","doc":"Same as form/1,2, but only for the sequence of expressions in Expressions."},{"ref":"erl_pp.html#formform/12","title":"erl_pp.formform/12","type":"function","doc":"Pretty prints a Form, which is an abstract form of a type that is returned by erl_parse:parse_form/1."},{"ref":"erl_pp.html#functionfunction/12","title":"erl_pp.functionfunction/12","type":"function","doc":"Same as form/1,2, but only for function Function."},{"ref":"erl_pp.html#guardguard/12","title":"erl_pp.guardguard/12","type":"function","doc":"Same as form/1,2, but only for the guard test Guard."},{"ref":"erl_scan.html","title":"erl_scan","type":"module","doc":"This module contains functions for tokenizing (scanning) characters into Erlang tokens."},{"ref":"erl_scan.html#category/1","title":"erl_scan.category/1","type":"function","doc":"Returns the category of Token."},{"ref":"erl_scan.html#column/1","title":"erl_scan.column/1","type":"function","doc":"Returns the column of Token&#39;s collection of annotations."},{"ref":"erl_scan.html#end_location/1","title":"erl_scan.end_location/1","type":"function","doc":"Returns the end location of the text of Token&#39;s collection of annotations. If there is no text, undefined is returned."},{"ref":"erl_scan.html#format_error/1","title":"erl_scan.format_error/1","type":"function","doc":"Uses an ErrorDescriptor and returns a string that describes the error or warning. This function is usually called implicitly when an ErrorInfo structure is processed (see section Error Information)."},{"ref":"erl_scan.html#line/1","title":"erl_scan.line/1","type":"function","doc":"Returns the line of Token&#39;s collection of annotations."},{"ref":"erl_scan.html#location/1","title":"erl_scan.location/1","type":"function","doc":"Returns the location of Token&#39;s collection of annotations."},{"ref":"erl_scan.html#reserved_word/1","title":"erl_scan.reserved_word/1","type":"function","doc":"Returns true if Atom is an Erlang reserved word, otherwise false."},{"ref":"erl_scan.html#stringstringstring/123","title":"erl_scan.stringstringstring/123","type":"function","doc":"Takes the list of characters String and tries to scan (tokenize) them. Returns one of the following: {ok, ``Tokens``, ``EndLocation``} * Tokens are the Erlang tokens from String. EndLocation is the first location after the last token. {error, ``ErrorInfo``, ``ErrorLocation``} * An error occurred. ErrorLocation is the first location after the erroneous token. string(``String``) is equivalent to string(``String``, 1), and string(``String``, ``StartLocation``) is equivalent to string(``String``, ``StartLocation``, []). StartLocation indicates the initial location when scanning starts. If StartLocation is a line, Anno, EndLocation, and ErrorLocation are lines. If StartLocation is a pair of a line and a column, Anno takes the form of an opaque compound data type, and EndLocation and ErrorLocation are pairs of a line and a column. The token annotations contain information about the column and the line where the token begins, as well as the text of the token (if option text is specified), all of which can be accessed by calling column/1, line/1, location/1, and text/1. A token is a tuple containing information about syntactic category, the token annotations, and the terminal symbol. For punctuation characters (such as ; and |) and reserved words, the category and the symbol coincide, and the token is represented by a two-tuple. Three-tuples have one of the following forms: * `{atom, Anno, atom()}` * `{char, Anno, char()}` * `{comment, Anno, string()}` * `{float, Anno, float()}` * `{integer, Anno, integer()}` * `{var, Anno, atom()}` * `{white_space, Anno, string()}` Valid options: {reserved_word_fun, reserved_word_fun()} * A callback function that is called when the scanner has found an unquoted atom. If the function returns true, the unquoted atom itself becomes the category of the token. If the function returns false, atom becomes the category of the unquoted atom. return_comments * Return comment tokens. return_white_spaces * Return white space tokens. By convention, a newline character, if present, is always the first character of the text (there cannot be more than one newline in a white space token). return * Short for [return_comments, return_white_spaces]. text * Include the token text in the token annotation. The text is the part of the input corresponding to the token."},{"ref":"erl_scan.html#symbol/1","title":"erl_scan.symbol/1","type":"function","doc":"Returns the symbol of Token."},{"ref":"erl_scan.html#text/1","title":"erl_scan.text/1","type":"function","doc":"Returns the text of Token&#39;s collection of annotations. If there is no text, undefined is returned."},{"ref":"erl_scan.html#tokenstokens/34","title":"erl_scan.tokenstokens/34","type":"function","doc":"This is the re-entrant scanner, which scans characters until either a dot (&#39;.&#39; followed by a white space) or eof is reached. It returns: {done, ``Result``, ``LeftOverChars``} * Indicates that there is sufficient input data to get a result. Result is: {ok, Tokens, EndLocation} * The scanning was successful. Tokens is the list of tokens including dot. {eof, EndLocation} * End of file was encountered before any more tokens. {error, ErrorInfo, EndLocation} * An error occurred. LeftOverChars is the remaining characters of the input data, starting from EndLocation. `{more, ``Continuation1``}` * More data is required for building a term. `Continuation1` must be passed in a new call to `tokens/3,4` when more data is available. The CharSpec eof signals end of file. LeftOverChars then takes the value eof as well. tokens(``Continuation``, ``CharSpec``, ``StartLocation``) is equivalent to tokens(``Continuation``, ``CharSpec``, ``StartLocation``, []). For a description of the options, see string/3."},{"ref":"erl_tar.html","title":"erl_tar","type":"module","doc":"This module archives and extract files to and from a tar file. This module supports reading most common tar formats, namely v7, STAR, USTAR, and PAX, as well as some of GNU tar&#39;s extensions to the USTAR format (sparse files most notably). It produces tar archives in USTAR format, unless the files being archived require PAX format due to restrictions in USTAR (such as unicode metadata, filename length, and more). As such, erl_tar supports tar archives produced by most all modern tar utilities, and produces tarballs which should be similarly portable. By convention, the name of a tar file is to end in &quot;.tar&quot;. To abide to the convention, add &quot;.tar&quot; to the name. Tar files can be created in one operation using function create/2 or create/3. Alternatively, for more control, use functions open/2, add/3,4, and close/1. To extract all files from a tar file, use function extract/1. To extract only some files or to be able to specify some more options, use function extract/2. To return a list of the files in a tar file, use function table/1 or table/2. To print a list of files to the Erlang shell, use function t/1 or tt/1. To convert an error term returned from one of the functions above to a readable message, use function format_error/1."},{"ref":"ets.html","title":"ets","type":"module","doc":"This module is an interface to the Erlang built-in term storage BIFs. These provide the ability to store very large quantities of data in an Erlang runtime system, and to have constant access time to the data. (In the case of ordered_set, see below, access time is proportional to the logarithm of the number of stored objects.) Data is organized as a set of dynamic tables, which can store tuples. Each table is created by a process. When the process terminates, the table is automatically destroyed. Every table has access rights set at creation. Tables are divided into four different types, set, ordered_set, bag, and duplicate_bag. A set or ordered_set table can only have one object associated with each key. A bag or duplicate_bag table can have many objects associated with each key. The number of tables stored at one Erlang node used to be limited. This is no longer the case (except by memory usage). The previous default limit was about 1400 tables and could be increased by setting the environment variable `ERL_MAX_ETS_TABLES` or the command line option `+e` before starting the Erlang runtime system. This hard limit has been removed, but it is currently useful to set the `ERL_MAX_ETS_TABLES` anyway. It should be set to an approximate of the maximum amount of tables used. This since an internal table for named tables is sized using this value. If large amounts of named tables are used and `ERL_MAX_ETS_TABLES` hasn&#39;t been increased, the performance of named table lookup will degrade. Notice that there is no automatic garbage collection for tables. Even if there are no references to a table from any process, it is not automatically destroyed unless the owner process terminates. To destroy a table explicitly, use function delete/1. The default owner is the process that created the table. To transfer table ownership at process termination, use option heir or call give_away/3. Some implementation details: * In the current implementation, every object insert and look-up operation results in a copy of the object. &#39;$end_of_table&#39; is not to be used as a key, as this atom is used to mark the end of the table when using functions first/1 and next/2. Notice the subtle difference between matching and comparing equal, which is demonstrated by table types set and ordered_set: Two Erlang terms match if they are of the same type and have the same value, so that 1 matches 1, but not 1.0 (as 1.0 is a float() and not an integer()). Two Erlang terms compare equal if they either are of the same type and value, or if both are numeric types and extend to the same value, so that 1 compares equal to both 1 and 1.0. The ordered_set works on the Erlang term order and no defined order exists between an integer() and a float() that extends to the same value. Hence the key 1 and the key 1.0 are regarded as equal in an ordered_set table."},{"ref":"ets.html#all/0","title":"ets.all/0","type":"function","doc":"Returns a list of all tables at the node. Named tables are specified by their names, unnamed tables are specified by their table identifiers. There is no guarantee of consistency in the returned list. Tables created or deleted by other processes &quot;during&quot; the ets:all() call either are or are not included in the list. Only tables created/deleted before ets:all() is called are guaranteed to be included/excluded."},{"ref":"ets.html#delete/1","title":"ets.delete/1","type":"function","doc":"Deletes the entire table Tab."},{"ref":"ets.html#delete/2","title":"ets.delete/2","type":"function","doc":"Deletes all objects with key Key from table Tab."},{"ref":"ets.html#delete_all_objects/1","title":"ets.delete_all_objects/1","type":"function","doc":"Delete all objects in the ETS table Tab. The operation is guaranteed to be atomic and isolated."},{"ref":"ets.html#delete_object/2","title":"ets.delete_object/2","type":"function","doc":"Delete the exact object Object from the ETS table, leaving objects with the same key but other differences (useful for type bag). In a duplicate_bag table, all instances of the object are deleted."},{"ref":"ets.html#file2tab/1","title":"ets.file2tab/1","type":"function","doc":"Reads a file produced by tab2file/2 or tab2file/3 and creates the corresponding table Tab. Equivalent to file2tab(``Filename``, [])."},{"ref":"ets.html#file2tab/2","title":"ets.file2tab/2","type":"function","doc":"Reads a file produced by tab2file/2 or tab2file/3 and creates the corresponding table Tab. The only supported option is {verify,boolean()}. If verification is turned on (by specifying {verify,true}), the function uses whatever information is present in the file to assert that the information is not damaged. How this is done depends on which extended_info was written using tab2file/3. If no extended_info is present in the file and {verify,true} is specified, the number of objects written is compared to the size of the original table when the dump was started. This can make verification fail if the table was public and objects were added or removed while the table was dumped to file. To avoid this problem, either do not verify files dumped while updated simultaneously or use option {extended_info, [object_count]} to tab2file/3, which extends the information in the file with the number of objects written. If verification is turned on and the file was written with option {extended_info, [md5sum]}, reading the file is slower and consumes radically more CPU time than otherwise. {verify,false} is the default."},{"ref":"ets.html#first/1","title":"ets.first/1","type":"function","doc":"Returns the first key Key in table Tab. For an ordered_set table, the first key in Erlang term order is returned. For other table types, the first key according to the internal order of the table is returned. If the table is empty, &#39;$end_of_table&#39; is returned. To find subsequent keys in the table, use next/2."},{"ref":"ets.html#foldl/3","title":"ets.foldl/3","type":"function","doc":"Acc0 is returned if the table is empty. This function is similar to lists:foldl/3. The table elements are traversed in an unspecified order, except for ordered_set tables, where they are traversed first to last. If Function inserts objects into the table, or another process inserts objects into the table, those objects can (depending on key ordering) be included in the traversal."},{"ref":"ets.html#foldr/3","title":"ets.foldr/3","type":"function","doc":"Acc0 is returned if the table is empty. This function is similar to lists:foldr/3. The table elements are traversed in an unspecified order, except for ordered_set tables, where they are traversed last to first. If Function inserts objects into the table, or another process inserts objects into the table, those objects can (depending on key ordering) be included in the traversal."},{"ref":"ets.html#from_dets/2","title":"ets.from_dets/2","type":"function","doc":"Fills an already created ETS table with the objects in the already opened Dets table DetsTab. Existing objects in the ETS table are kept unless overwritten. If any of the tables does not exist or the Dets table is not open, a badarg exception is raised."},{"ref":"ets.html#fun2ms/1","title":"ets.fun2ms/1","type":"function","doc":"Pseudo function that by a parse_transform translates LiteralFun typed as parameter in the function call to a match specification. With &quot;literal&quot; is meant that the fun must textually be written as the parameter of the function, it cannot be held in a variable that in turn is passed to the function. The parse transform is provided in the ms_transform module and the source must include file ms_transform.hrl in STDLIB for this pseudo function to work. Failing to include the hrl file in the source results in a runtime error, not a compile time error. The include file is easiest included by adding line -include_lib(&quot;stdlib/include/ms_transform.hrl&quot;). to the source file. The fun is very restricted, it can take only a single parameter (the object to match): a sole variable or a tuple. It must use the is_ guard tests. Language constructs that have no representation in a match specification (if, case, receive, and so on) are not allowed. The return value is the resulting match specification. Example: 1&gt; ets:fun2ms(fun({M,N}) when N &gt; 3 -&gt; M end). [{{&#39;$1&#39;,&#39;$2&#39;},[{&#39;&gt;&#39;,&#39;$2&#39;,3}],[&#39;$1&#39;]}] Variables from the environment can be imported, so that the following works: 2&gt; X=3. 3 3&gt; ets:fun2ms(fun({M,N}) when N &gt; X -&gt; M end). [{{&#39;$1&#39;,&#39;$2&#39;},[{&#39;&gt;&#39;,&#39;$2&#39;,{const,3}}],[&#39;$1&#39;]}] The imported variables are replaced by match specification const expressions, which is consistent with the static scoping for Erlang funs. However, local or global function calls cannot be in the guard or body of the fun. Calls to built-in match specification functions is of course allowed: 4&gt; ets:fun2ms(fun({M,N}) when N &gt; X, my_fun(M) -&gt; M end). Error: fun containing local Erlang function calls (&#39;my_fun&#39; called in guard) cannot be translated into match_spec {error,transform_error} 5&gt; ets:fun2ms(fun({M,N}) when N &gt; X, is_atom(M) -&gt; M end). [{{&#39;$1&#39;,&#39;$2&#39;},[{&#39;&gt;&#39;,&#39;$2&#39;,{const,3}},{is_atom,&#39;$1&#39;}],[&#39;$1&#39;]}] As shown by the example, the function can be called from the shell also. The fun must be literally in the call when used from the shell as well. If the parse_transform is not applied to a module that calls this pseudo function, the call fails in runtime (with a badarg). The ets module exports a function with this name, but it is never to be called except when using the function in the shell. If the parse_transform is properly applied by including header file ms_transform.hrl, compiled code never calls the function, but the function call is replaced by a literal match specification. For more information, see ms_transform(3)."},{"ref":"ets.html#give_away/3","title":"ets.give_away/3","type":"function","doc":"Make process Pid the new owner of table Tab. If successful, message {&#39;ETS-TRANSFER&#39;,``Tab``,FromPid,``GiftData``} is sent to the new owner. The process Pid must be alive, local, and not already the owner of the table. The calling process must be the table owner. Notice that this function does not affect option heir of the table. A table owner can, for example, set heir to itself, give the table away, and then get it back if the receiver terminates."},{"ref":"ets.html#i/0","title":"ets.i/0","type":"function","doc":"Displays information about all ETS tables on a terminal."},{"ref":"ets.html#i/1","title":"ets.i/1","type":"function","doc":"Browses table Tab on a terminal."},{"ref":"ets.html#info/1","title":"ets.info/1","type":"function","doc":"Returns information about table Tab as a list of tuples. If Tab has the correct type for a table identifier, but does not refer to an existing ETS table, undefined is returned. If Tab is not of the correct type, a badarg exception is raised. {compressed, boolean()} * Indicates if the table is compressed. {heir, pid() | none} * The pid of the heir of the table, or none if no heir is set. {id, tid()``} * The table identifier. {keypos, integer() &gt;= 1} * The key position. {memory, integer() &gt;= 0 * The number of words allocated to the table. {name, atom()} * The table name. {named_table, boolean()} * Indicates if the table is named. {node, node()} * The node where the table is stored. This field is no longer meaningful, as tables cannot be accessed from other nodes. {owner, pid()} * The pid of the owner of the table. {protection, access()``} * The table access rights. {size, integer() &gt;= 0 * The number of objects inserted in the table. {type, type()``} * The table type. {read_concurrency, boolean()} * Indicates whether the table uses read_concurrency or not. {write_concurrency, boolean()} * Indicates whether the table uses write_concurrency."},{"ref":"ets.html#info/2","title":"ets.info/2","type":"function","doc":"Returns the information associated with Item for table Tab, or returns undefined if Tab does not refer an existing ETS table. If Tab is not of the correct type, or if Item is not one of the allowed values, a badarg exception is raised. In addition to the {``Item``,``Value``} pairs defined for info/1, the following items are allowed: * `Item=binary, Value=BinInfo` BinInfo is a list containing miscellaneous information about binaries kept by the table. This Item can be changed or removed without prior notice. In the current implementation BinInfo is a list of tuples {BinaryId,BinarySize,BinaryRefcCount}. * `Item=fixed, Value=boolean()` Indicates if the table is fixed by any process. * Item=safe_fixed|safe_fixed_monotonic_time, Value={FixationTime,Info}|false If the table is fixed using safe_fixtable/2, the call returns a tuple where FixationTime is the last time when the table changed from unfixed to fixed. The format and value of FixationTime depends on Item: safe_fixed * FixationTime corresponds to the result returned by erlang:timestamp/0 at the time of fixation. Notice that when the system uses single or multi time warp modes this can produce strange results, as the use of safe_fixed is not time warp safe. Time warp safe code must use safe_fixed_monotonic_time instead. safe_fixed_monotonic_time * FixationTime corresponds to the result returned by erlang:monotonic_time/0 at the time of fixation. The use of safe_fixed_monotonic_time is time warp safe. Info is a possibly empty lists of tuples {Pid,RefCount}, one tuple for every process the table is fixed by now. RefCount is the value of the reference counter and it keeps track of how many times the table has been fixed by the process. Table fixations are not limited to safe_fixtable/2. Temporary fixations may also be done by for example traversing functions like select and match. Such table fixations are automatically released before the corresponding functions returns, but they may be seen by a concurrent call to ets:info(T,safe_fixed|safe_fixed_monotonic_time). If the table is not fixed at all, the call returns false. * `Item=stats, Value=tuple()` Returns internal statistics about tables on an internal format used by OTP test suites. Not for production use."},{"ref":"ets.html#init_table/2","title":"ets.init_table/2","type":"function","doc":"Replaces the existing objects of table Tab with objects created by calling the input function InitFun, see below. This function is provided for compatibility with the dets module, it is not more efficient than filling a table by using insert/2. When called with argument read, the function InitFun is assumed to return end_of_input when there is no more input, or {``Objects``, Fun}, where Objects is a list of objects and Fun is a new input function. Any other value Value is returned as an error {error, {init_fun, Value}}. Each input function is called exactly once, and if an error occur, the last function is called with argument close, the reply of which is ignored. If the table type is set and more than one object exists with a given key, one of the objects is chosen. This is not necessarily the last object with the given key in the sequence of objects returned by the input functions. This holds also for duplicated objects stored in tables of type bag."},{"ref":"ets.html#insert/2","title":"ets.insert/2","type":"function","doc":"Inserts the object or all of the objects in list ObjectOrObjects into table Tab. * If the table type is `set` and the key of the inserted objects matches the key of any object in the table, the old object is replaced. * If the table type is `ordered_set` and the key of the inserted object compares equal to the key of any object in the table, the old object is replaced. * If the list contains more than one object with matching keys and the table type is `set`, one is inserted, which one is not defined. The same holds for table type `ordered_set` if the keys compare equal. The entire operation is guaranteed to be atomic and isolated, even when a list of objects is inserted."},{"ref":"ets.html#insert_new/2","title":"ets.insert_new/2","type":"function","doc":"Same as insert/2 except that instead of overwriting objects with the same key (for set or ordered_set) or adding more objects with keys already existing in the table (for bag and duplicate_bag), false is returned. If ObjectOrObjects is a list, the function checks every key before inserting anything. Nothing is inserted unless all keys present in the list are absent from the table. Like insert/2, the entire operation is guaranteed to be atomic and isolated."},{"ref":"ets.html#is_compiled_ms/1","title":"ets.is_compiled_ms/1","type":"function","doc":"Checks if a term represent a valid compiled match specification. A compiled match specifications is only valid on the Erlang node where it was compiled by calling match_spec_compile/1. Before STDLIB 3.4 (OTP 20.0) compiled match specifications did not have an external representation. If passed through binary_to_term(term_to_binary(CMS)) or sent to another node and back, the result was always an empty binary &lt;&lt;&gt;&gt;. After STDLIB 3.4 (OTP 20.0) compiled match specifications have an external representation as a node specific reference to the original compiled match specification. If passed through binary_to_term(term_to_binary(CMS)) or sent to another node and back, the result may or may not be a valid compiled match specification depending on if the original compiled match specification was still alive."},{"ref":"ets.html#last/1","title":"ets.last/1","type":"function","doc":"Returns the last key Key according to Erlang term order in table Tab of type ordered_set. For other table types, the function is synonymous to first/1. If the table is empty, &#39;$end_of_table&#39; is returned. To find preceding keys in the table, use prev/2."},{"ref":"ets.html#lookup/2","title":"ets.lookup/2","type":"function","doc":"Returns a list of all objects with key Key in table Tab. * For tables of type `set`, `bag`, or `duplicate_bag`, an object is returned only if the specified key matches the key of the object in the table. * For tables of type `ordered_set`, an object is returned if the specified key compares equal to the key of an object in the table. The difference is the same as between =:= and ==. As an example, one can insert an object with integer() 1 as a key in an ordered_set and get the object returned as a result of doing a lookup/2 with float() 1.0 as the key to search for. For tables of type set or ordered_set, the function returns either the empty list or a list with one element, as there cannot be more than one object with the same key. For tables of type bag or duplicate_bag, the function returns a list of arbitrary length. Notice that the time order of object insertions is preserved; the first object inserted with the specified key is the first in the resulting list, and so on. Insert and lookup times in tables of type set, bag, and duplicate_bag are constant, regardless of the table size. For the ordered_set datatype, time is proportional to the (binary) logarithm of the number of objects."},{"ref":"ets.html#lookup_element/3","title":"ets.lookup_element/3","type":"function","doc":"For a table Tab of type set or ordered_set, the function returns the Pos:th element of the object with key Key. For tables of type bag or duplicate_bag, the functions returns a list with the Pos:th element of every object with key Key. If no object with key Key exists, the function exits with reason badarg. The difference between set, bag, and duplicate_bag on one hand, and ordered_set on the other, regarding the fact that ordered_set view keys as equal when they compare equal whereas the other table types regard them equal only when they match, holds for lookup_element/3."},{"ref":"ets.html#match/1","title":"ets.match/1","type":"function","doc":"Continues a match started with match/3. The next chunk of the size specified in the initial match/3 call is returned together with a new Continuation, which can be used in subsequent calls to this function. When there are no more objects in the table, &#39;$end_of_table&#39; is returned."},{"ref":"ets.html#match/2","title":"ets.match/2","type":"function","doc":"Matches the objects in table Tab against pattern Pattern. A pattern is a term that can contain: * Bound parts (Erlang terms) * `&#39;_&#39;` that matches any Erlang term * Pattern variables `&#39;$N&#39;`, where `N`=0,1,... The function returns a list with one element for each matching object, where each element is an ordered list of pattern variable bindings, for example: 6&gt; ets:match(T, &#39;$1&#39;). % Matches every object in table [[{rufsen,dog,7}],[{brunte,horse,5}],[{ludde,dog,5}]] 7&gt; ets:match(T, {&#39;_&#39;,dog,&#39;$1&#39;}). [[7],[5]] 8&gt; ets:match(T, {&#39;_&#39;,cow,&#39;$1&#39;}). [] If the key is specified in the pattern, the match is very efficient. If the key is not specified, that is, if it is a variable or an underscore, the entire table must be searched. The search time can be substantial if the table is very large. For tables of type ordered_set, the result is in the same order as in a first/next traversal."},{"ref":"ets.html#match/3","title":"ets.match/3","type":"function","doc":"Works like match/2, but returns only a limited (Limit) number of matching objects. Term Continuation can then be used in subsequent calls to match/1 to get the next chunk of matching objects. This is a space-efficient way to work on objects in a table, which is faster than traversing the table object by object using first/1 and next/2. If the table is empty, &#39;$end_of_table&#39; is returned. Use safe_fixtable/2 to guarantee safe traversal for subsequent calls to match/1."},{"ref":"ets.html#match_delete/2","title":"ets.match_delete/2","type":"function","doc":"Deletes all objects that match pattern Pattern from table Tab. For a description of patterns, see match/2."},{"ref":"ets.html#match_object/1","title":"ets.match_object/1","type":"function","doc":"Continues a match started with match_object/3. The next chunk of the size specified in the initial match_object/3 call is returned together with a new Continuation, which can be used in subsequent calls to this function. When there are no more objects in the table, &#39;$end_of_table&#39; is returned."},{"ref":"ets.html#match_object/2","title":"ets.match_object/2","type":"function","doc":"Matches the objects in table Tab against pattern Pattern. For a description of patterns, see match/2. The function returns a list of all objects that match the pattern. If the key is specified in the pattern, the match is very efficient. If the key is not specified, that is, if it is a variable or an underscore, the entire table must be searched. The search time can be substantial if the table is very large. For tables of type ordered_set, the result is in the same order as in a first/next traversal."},{"ref":"ets.html#match_object/3","title":"ets.match_object/3","type":"function","doc":"Works like match_object/2, but only returns a limited (Limit) number of matching objects. Term Continuation can then be used in subsequent calls to match_object/1 to get the next chunk of matching objects. This is a space-efficient way to work on objects in a table, which is faster than traversing the table object by object using first/1 and next/2. If the table is empty, &#39;$end_of_table&#39; is returned. Use safe_fixtable/2 to guarantee safe traversal for subsequent calls to match_object/1."},{"ref":"ets.html#match_spec_compile/1","title":"ets.match_spec_compile/1","type":"function","doc":"Transforms a match specification into an internal representation that can be used in subsequent calls to match_spec_run/2. The internal representation is opaque. To check the validity of a compiled match specification, use is_compiled_ms/1. If term MatchSpec cannot be compiled (does not represent a valid match specification), a badarg exception is raised. This function has limited use in normal code. It is used by the dets module to perform the dets:select() operations."},{"ref":"ets.html#match_spec_run/2","title":"ets.match_spec_run/2","type":"function","doc":"Executes the matching specified in a compiled match specification on a list of terms. Term CompiledMatchSpec is to be the result of a call to match_spec_compile/1 and is hence the internal representation of the match specification one wants to use. The matching is executed on each element in List and the function returns a list containing all results. If an element in List does not match, nothing is returned for that element. The length of the result list is therefore equal or less than the length of parameter List. Example: The following two calls give the same result (but certainly not the same execution time): Table = ets:new... MatchSpec = ... % The following call... ets:match_spec_run(ets:tab2list(Table), ets:match_spec_compile(MatchSpec)), % ...gives the same result as the more common (and more efficient) ets:select(Table, MatchSpec), This function has limited use in normal code. It is used by the dets module to perform the dets:select() operations and by Mnesia during transactions."},{"ref":"ets.html#member/2","title":"ets.member/2","type":"function","doc":"Works like lookup/2, but does not return the objects. Returns true if one or more elements in the table has key Key, otherwise false."},{"ref":"ets.html#new/2","title":"ets.new/2","type":"function","doc":"Creates a new table and returns a table identifier that can be used in subsequent operations. The table identifier can be sent to other processes so that a table can be shared between different processes within a node. Parameter Options is a list of options that specifies table type, access rights, key position, and whether the table is named. Default values are used for omitted options. This means that not specifying any options ([]) is the same as specifying [set, protected, {keypos,1}, {heir,none}, {write_concurrency,false}, {read_concurrency,false}]. set * The table is a set table: one key, one object, no order among objects. This is the default table type. ordered_set * The table is a ordered_set table: one key, one object, ordered in Erlang term order, which is the order implied by the &lt; and &gt; operators. Tables of this type have a somewhat different behavior in some situations than tables of other types. Most notably, the ordered_set tables regard keys as equal when they compare equal, not only when they match. This means that to an ordered_set table, integer() 1 and float() 1.0 are regarded as equal. This also means that the key used to lookup an element not necessarily matches the key in the returned elements, if float()&#39;s and integer()&#39;s are mixed in keys of a table. bag * The table is a bag table, which can have many objects, but only one instance of each object, per key. duplicate_bag * The table is a duplicate_bag table, which can have many objects, including multiple copies of the same object, per key. public * Any process can read or write to the table. protected * The owner process can read and write to the table. Other processes can only read the table. This is the default setting for the access rights. private * Only the owner process can read or write to the table. named_table * If this option is present, the table is registered under its Name which can then be used instead of the table identifier in subsequent operations. The function will also return the Name instead of the table identifier. To get the table identifier of a named table, use whereis/1. {keypos,``Pos``} * Specifies which element in the stored tuples to use as key. By default, it is the first element, that is, Pos``=1. However, this is not always appropriate. In particular, we do not want the first element to be the key if we want to store Erlang records in a table. Notice that any tuple stored in the table must have at least Pos number of elements. {heir,``Pid``,``HeirData``} | {heir,none} * Set a process as heir. The heir inherits the table if the owner terminates. Message {&#39;ETS-TRANSFER&#39;,tid(),FromPid,``HeirData``} is sent to the heir when that occurs. The heir must be a local process. Default heir is none, which destroys the table when the owner terminates. {write_concurrency,boolean()} * Performance tuning. Defaults to false, in which case an operation that mutates (writes to) the table obtains exclusive access, blocking any concurrent access of the same table until finished. If set to true, the table is optimized to concurrent write access. Different objects of the same table can be mutated (and read) by concurrent processes. This is achieved to some degree at the expense of memory consumption and the performance of sequential access and concurrent reading. Option write_concurrency can be combined with option read_concurrency. You typically want to combine these when large concurrent read bursts and large concurrent write bursts are common; for more information, see option read_concurrency. Notice that this option does not change any guarantees about atomicity and isolation. Functions that makes such promises over many objects (like insert/2) gain less (or nothing) from this option. The memory consumption inflicted by both write_concurrency and read_concurrency is a constant overhead per table for set, bag and duplicate_bag. For ordered_set the memory overhead depends on the number of inserted objects and the amount of actual detected concurrency in runtime. The memory overhead can be especially large when both options are combined. Prior to stdlib-3.7 (OTP-22.0) write_concurrency had no effect on ordered_set. `{read_concurrency,boolean()}` * Performance tuning. Defaults to `false`. When set to `true`, the table is optimized for concurrent read operations. When this option is enabled on a runtime system with SMP support, read operations become much cheaper; especially on systems with multiple physical processors. However, switching between read and write operations becomes more expensive. You typically want to enable this option when concurrent read operations are much more frequent than write operations, or when concurrent reads and writes comes in large read and write bursts (that is, many reads not interrupted by writes, and many writes not interrupted by reads). You typically do not want to enable this option when the common access pattern is a few read operations interleaved with a few write operations repeatedly. In this case, you would get a performance degradation by enabling this option. Option read_concurrency can be combined with option write_concurrency. You typically want to combine these when large concurrent read bursts and large concurrent write bursts are common. compressed * If this option is present, the table data is stored in a more compact format to consume less memory. However, it will make table operations slower. Especially operations that need to inspect entire objects, such as match and select, get much slower. The key element is not compressed."},{"ref":"ets.html#next/2","title":"ets.next/2","type":"function","doc":"Returns the next key Key2, following key Key1 in table Tab. For table type ordered_set, the next key in Erlang term order is returned. For other table types, the next key according to the internal order of the table is returned. If no next key exists, &#39;$end_of_table&#39; is returned. To find the first key in the table, use first/1. Unless a table of type set, bag, or duplicate_bag is fixated using safe_fixtable/2, a call to next/2 will fail if Key1 no longer exists in the table. For table type ordered_set, the function always returns the next key after Key1 in term order, regardless whether Key1 ever existed in the table."},{"ref":"ets.html#prev/2","title":"ets.prev/2","type":"function","doc":"Returns the previous key Key2, preceding key Key1 according to Erlang term order in table Tab of type ordered_set. For other table types, the function is synonymous to next/2. If no previous key exists, &#39;$end_of_table&#39; is returned. To find the last key in an ordered_set table, use last/1."},{"ref":"ets.html#rename/2","title":"ets.rename/2","type":"function","doc":"Renames the named table Tab to the new name Name. Afterwards, the old name cannot be used to access the table. Renaming an unnamed table has no effect."},{"ref":"ets.html#repair_continuation/2","title":"ets.repair_continuation/2","type":"function","doc":"Restores an opaque continuation returned by select/3 or select/1 if the continuation has passed through external term format (been sent between nodes or stored on disk). The reason for this function is that continuation terms contain compiled match specifications and may therefore be invalidated if converted to external term format. Given that the original match specification is kept intact, the continuation can be restored, meaning it can once again be used in subsequent select/1 calls even though it has been stored on disk or on another node. Examples: The following sequence of calls may fail: T=ets:new(x,[]), ... MS = ets:fun2ms(fun({N,_}=A) when (N rem 10) =:= 0 -&gt; A end), {_,C} = ets:select(T, MS, 10), MaybeBroken = binary_to_term(term_to_binary(C)), ets:select(MaybeBroken). The following sequence works, as the call to repair_continuation/2 reestablishes the MaybeBroken continuation. T=ets:new(x,[]), ... MS = ets:fun2ms(fun({N,_}=A) when (N rem 10) =:= 0 -&gt; A end), {_,C} = ets:select(T,MS,10), MaybeBroken = binary_to_term(term_to_binary(C)), ets:select(ets:repair_continuation(MaybeBroken,MS)). This function is rarely needed in application code. It is used by Mnesia to provide distributed select/3 and select/1 sequences. A normal application would either use Mnesia or keep the continuation from being converted to external format. The actual behavior of compiled match specifications when recreated from external format has changed and may change in future releases, but this interface remains for backward compatibility. See is_compiled_ms/1."},{"ref":"ets.html#safe_fixtable/2","title":"ets.safe_fixtable/2","type":"function","doc":"Fixes a table of type set, bag, or duplicate_bag for safe traversal using first/1 &amp; next/2, match/3 &amp; match/1, match_object/3 &amp; match_object/1, or select/3 &amp; select/1. A process fixes a table by calling safe_fixtable(``Tab``, true). The table remains fixed until the process releases it by calling safe_fixtable(``Tab``, false), or until the process terminates. If many processes fix a table, the table remains fixed until all processes have released it (or terminated). A reference counter is kept on a per process basis, and N consecutive fixes requires N releases to release the table. When a table is fixed, a sequence of first/1 and next/2 calls are guaranteed to succeed even if keys are removed during the traversal. The keys for objects inserted or deleted during a traversal may or may not be returned by next/2 depending on the ordering of keys within the table and if the key exists at the time next/2 is called. Example: clean_all_with_value(Tab,X) -&gt; safe_fixtable(Tab,true), clean_all_with_value(Tab,X,ets:first(Tab)), safe_fixtable(Tab,false). clean_all_with_value(Tab,X,&#39;$end_of_table&#39;) -&gt; true; clean_all_with_value(Tab,X,Key) -&gt; case ets:lookup(Tab,Key) of [{Key,X}] -&gt; ets:delete(Tab,Key); _ -&gt; true end, clean_all_with_value(Tab,X,ets:next(Tab,Key)). Notice that deleted objects are not freed from a fixed table until it has been released. If a process fixes a table but never releases it, the memory used by the deleted objects is never freed. The performance of operations on the table also degrades significantly. To retrieve information about which processes have fixed which tables, use info(Tab, safe_fixed_monotonic_time). A system with many processes fixing tables can need a monitor that sends alarms when tables have been fixed for too long. Notice that safe_fixtable/2 is not necessary for table type ordered_set and for traversals done by a single ETS function call, like select/2."},{"ref":"ets.html#select/1","title":"ets.select/1","type":"function","doc":"Continues a match started with select/3. The next chunk of the size specified in the initial select/3 call is returned together with a new Continuation, which can be used in subsequent calls to this function. When there are no more objects in the table, &#39;$end_of_table&#39; is returned."},{"ref":"ets.html#select/2","title":"ets.select/2","type":"function","doc":"Matches the objects in table Tab using a match specification. This is a more general call than match/2 and match_object/2 calls. In its simplest form, the match specification is as follows: MatchSpec = [MatchFunction] MatchFunction = {MatchHead, [Guard], [Result]} MatchHead = &quot;Pattern as in ets:match&quot; Guard = {&quot;Guardtest name&quot;, ...} Result = &quot;Term construct&quot; This means that the match specification is always a list of one or more tuples (of arity 3). The first element of the tuple is to be a pattern as described in match/2. The second element of the tuple is to be a list of 0 or more guard tests (described below). The third element of the tuple is to be a list containing a description of the value to return. In almost all normal cases, the list contains exactly one term that fully describes the value to return for each object. The return value is constructed using the &quot;match variables&quot; bound in MatchHead or using the special match variables &#39;$_&#39; (the whole matching object) and &#39;$$&#39; (all match variables in a list), so that the following match/2 expression: ets:match(Tab,{&#39;$1&#39;,&#39;$2&#39;,&#39;$3&#39;}) is exactly equivalent to: ets:select(Tab,[{{&#39;$1&#39;,&#39;$2&#39;,&#39;$3&#39;},[],[&#39;$$&#39;]}]) And that the following match_object/2 call: ets:match_object(Tab,{&#39;$1&#39;,&#39;$2&#39;,&#39;$1&#39;}) is exactly equivalent to ets:select(Tab,[{{&#39;$1&#39;,&#39;$2&#39;,&#39;$1&#39;},[],[&#39;$_&#39;]}]) Composite terms can be constructed in the Result part either by simply writing a list, so that the following code: ets:select(Tab,[{{&#39;$1&#39;,&#39;$2&#39;,&#39;$3&#39;},[],[&#39;$$&#39;]}]) gives the same output as: ets:select(Tab,[{{&#39;$1&#39;,&#39;$2&#39;,&#39;$3&#39;},[],[[&#39;$1&#39;,&#39;$2&#39;,&#39;$3&#39;]]}]) That is, all the bound variables in the match head as a list. If tuples are to be constructed, one has to write a tuple of arity 1 where the single element in the tuple is the tuple one wants to construct (as an ordinary tuple can be mistaken for a Guard). Therefore the following call: ets:select(Tab,[{{&#39;$1&#39;,&#39;$2&#39;,&#39;$1&#39;},[],[&#39;$_&#39;]}]) gives the same output as: ets:select(Tab,[{{&#39;$1&#39;,&#39;$2&#39;,&#39;$1&#39;},[],[{{&#39;$1&#39;,&#39;$2&#39;,&#39;$3&#39;}}]}]) This syntax is equivalent to the syntax used in the trace patterns (see the dbg(3)) module in Runtime_Tools. The Guards are constructed as tuples, where the first element is the test name and the remaining elements are the test parameters. To check for a specific type (say a list) of the element bound to the match variable &#39;$1&#39;, one would write the test as {is_list, &#39;$1&#39;}. If the test fails, the object in the table does not match and the next MatchFunction (if any) is tried. Most guard tests present in Erlang can be used, but only the new versions prefixed is_ are allowed (is_float, is_atom, and so on). The Guard section can also contain logic and arithmetic operations, which are written with the same syntax as the guard tests (prefix notation), so that the following guard test written in Erlang: is_integer(X), is_integer(Y), X + Y &lt; 4711 is expressed as follows (X replaced with &#39;$1&#39; and Y with &#39;$2&#39;): [{is_integer, &#39;$1&#39;}, {is_integer, &#39;$2&#39;}, {&#39;&lt;&#39;, {&#39;+&#39;, &#39;$1&#39;, &#39;$2&#39;}, 4711}] For tables of type ordered_set, objects are visited in the same order as in a first/next traversal. This means that the match specification is executed against objects with keys in the first/next order and the corresponding result list is in the order of that execution."},{"ref":"ets.html#select/3","title":"ets.select/3","type":"function","doc":"Works like select/2, but only returns a limited (Limit) number of matching objects. Term Continuation can then be used in subsequent calls to select/1 to get the next chunk of matching objects. This is a space-efficient way to work on objects in a table, which is still faster than traversing the table object by object using first/1 and next/2. If the table is empty, &#39;$end_of_table&#39; is returned. Use safe_fixtable/2 to guarantee safe traversal for subsequent calls to select/1."},{"ref":"ets.html#select_count/2","title":"ets.select_count/2","type":"function","doc":"Matches the objects in table Tab using a match specification. If the match specification returns true for an object, that object considered a match and is counted. For any other result from the match specification the object is not considered a match and is therefore not counted. This function can be described as a match_delete/2 function that does not delete any elements, but only counts them. The function returns the number of objects matched."},{"ref":"ets.html#select_delete/2","title":"ets.select_delete/2","type":"function","doc":"Matches the objects in table Tab using a match specification. If the match specification returns true for an object, that object is removed from the table. For any other result from the match specification the object is retained. This is a more general call than the match_delete/2 call. The function returns the number of objects deleted from the table. The match specification has to return the atom true if the object is to be deleted. No other return value gets the object deleted. So one cannot use the same match specification for looking up elements as for deleting them."},{"ref":"ets.html#select_replace/2","title":"ets.select_replace/2","type":"function","doc":"Matches the objects in the table Tab using a match specification. For each matched object, the existing object is replaced with the match specification result. The match-and-replace operation for each individual object is guaranteed to be atomic and isolated. The select_replace table traversal as a whole, like all other select functions, does not give such guarantees. The match specifiction must be guaranteed to retain the key of any matched object. If not, select_replace will fail with badarg without updating any objects. For the moment, due to performance and semantic constraints, tables of type bag are not yet supported. The function returns the total number of replaced objects. Example For all 2-tuples with a list in second position, add atom &#39;marker&#39; first in the list: 1&gt; T = ets:new(x,[]), ets:insert(T, {key, [1, 2, 3]}). true 2&gt; MS = ets:fun2ms(fun({K, L}) when is_list(L) -&gt; {K, [marker | L]} end). [{{&#39;$1&#39;,&#39;$2&#39;},[{is_list,&#39;$2&#39;}],[{{&#39;$1&#39;,[marker|&#39;$2&#39;]}}]}] 3&gt; ets:select_replace(T, MS). 1 4&gt; ets:tab2list(T). [{key,[marker,1,2,3]}] A generic single object compare-and-swap operation: [Old] = ets:lookup(T, Key), New = update_object(Old), Success = (1 =:= ets:select_replace(T, [{Old, [], [{const, New}]}])),"},{"ref":"ets.html#select_reverse/1","title":"ets.select_reverse/1","type":"function","doc":"Continues a match started with select_reverse/3. For tables of type ordered_set, the traversal of the table continues to objects with keys earlier in the Erlang term order. The returned list also contains objects with keys in reverse order. For all other table types, the behavior is exactly that of select/1. Example: 1&gt; T = ets:new(x,[ordered_set]). 2&gt; [ ets:insert(T,{N}) || N &lt;- lists:seq(1,10) ]. ... 3&gt; {R0,C0} = ets:select_reverse(T,[{&#39;_&#39;,[],[&#39;$_&#39;]}],4). ... 4&gt; R0. [{10},{9},{8},{7}] 5&gt; {R1,C1} = ets:select_reverse(C0). ... 6&gt; R1. [{6},{5},{4},{3}] 7&gt; {R2,C2} = ets:select_reverse(C1). ... 8&gt; R2. [{2},{1}] 9&gt; &#39;$end_of_table&#39; = ets:select_reverse(C2). ..."},{"ref":"ets.html#select_reverse/2","title":"ets.select_reverse/2","type":"function","doc":"Works like select/2, but returns the list in reverse order for table type ordered_set. For all other table types, the return value is identical to that of select/2."},{"ref":"ets.html#select_reverse/3","title":"ets.select_reverse/3","type":"function","doc":"Works like select/3, but for table type ordered_set traversing is done starting at the last object in Erlang term order and moves to the first. For all other table types, the return value is identical to that of select/3. Notice that this is not equivalent to reversing the result list of a select/3 call, as the result list is not only reversed, but also contains the last Limit matching objects in the table, not the first."},{"ref":"ets.html#setopts/2","title":"ets.setopts/2","type":"function","doc":"Sets table options. The only allowed option to be set after the table has been created is heir. The calling process must be the table owner."},{"ref":"ets.html#slot/2","title":"ets.slot/2","type":"function","doc":"This function is mostly for debugging purposes, Normally first/next or last/prev are to be used instead. Returns all objects in slot I of table Tab. A table can be traversed by repeatedly calling the function, starting with the first slot I``=0 and ending when &#39;$end_of_table&#39; is returned. If argument I is out of range, the function fails with reason badarg. Unless a table of type set, bag, or duplicate_bag is protected using safe_fixtable/2, a traversal can fail if concurrent updates are made to the table. For table type ordered_set, the function returns a list containing object I in Erlang term order."},{"ref":"ets.html#tab2file/2","title":"ets.tab2file/2","type":"function","doc":"Dumps table Tab to file Filename. Equivalent to tab2file(``Tab``, ``Filename``,[])"},{"ref":"ets.html#tab2file/3","title":"ets.tab2file/3","type":"function","doc":"Dumps table Tab to file Filename. When dumping the table, some information about the table is dumped to a header at the beginning of the dump. This information contains data about the table type, name, protection, size, version, and if it is a named table. It also contains notes about what extended information is added to the file, which can be a count of the objects in the file or a MD5 sum of the header and records in the file. The size field in the header might not correspond to the number of records in the file if the table is public and records are added or removed from the table during dumping. Public tables updated during dump, and that one wants to verify when reading, needs at least one field of extended information for the read verification process to be reliable later. Option extended_info specifies what extra information is written to the table dump: object_count * The number of objects written to the file is noted in the file footer, so file truncation can be verified even if the file was updated during dump. md5sum * The header and objects in the file are checksummed using the built-in MD5 functions. The MD5 sum of all objects is written in the file footer, so that verification while reading detects the slightest bitflip in the file data. Using this costs a fair amount of CPU time. Whenever option extended_info is used, it results in a file not readable by versions of ETS before that in STDLIB 1.15.1 If option sync is set to true, it ensures that the content of the file is written to the disk before tab2file returns. Defaults to {sync, false}."},{"ref":"ets.html#tab2list/1","title":"ets.tab2list/1","type":"function","doc":"Returns a list of all objects in table Tab."},{"ref":"ets.html#tabfile_info/1","title":"ets.tabfile_info/1","type":"function","doc":"Returns information about the table dumped to file by tab2file/2 or tab2file/3. The following items are returned: name * The name of the dumped table. If the table was a named table, a table with the same name cannot exist when the table is loaded from file with file2tab/2. If the table is not saved as a named table, this field has no significance when loading the table from file. type * The ETS type of the dumped table (that is, set, bag, duplicate_bag, or ordered_set). This type is used when loading the table again. protection * The protection of the dumped table (that is, private, protected, or public). A table loaded from the file gets the same protection. named_table * true if the table was a named table when dumped to file, otherwise false. Notice that when a named table is loaded from a file, there cannot exist a table in the system with the same name. keypos * The keypos of the table dumped to file, which is used when loading the table again. size * The number of objects in the table when the table dump to file started. For a public table, this number does not need to correspond to the number of objects saved to the file, as objects can have been added or deleted by another process during table dump. extended_info * The extended information written in the file footer to allow stronger verification during table loading from file, as specified to tab2file/3. Notice that this function only tells which information is present, not the values in the file footer. The value is a list containing one or more of the atoms object_count and md5sum. version * A tuple {``Major``,``Minor``} containing the major and minor version of the file format for ETS table dumps. This version field was added beginning with STDLIB 1.5.1. Files dumped with older versions return {0,0} in this field. An error is returned if the file is inaccessible, badly damaged, or not produced with tab2file/2 or tab2file/3."},{"ref":"ets.html#tabletable/12","title":"ets.tabletable/12","type":"function","doc":"Returns a Query List Comprehension (QLC) query handle. The qlc module provides a query language aimed mainly at Mnesia, but ETS tables, Dets tables, and lists are also recognized by QLC as sources of data. Calling table/1,2 is the means to make the ETS table Tab usable to QLC. When there are only simple restrictions on the key position, QLC uses lookup/2 to look up the keys. When that is not possible, the whole table is traversed. Option traverse determines how this is done: first_next * The table is traversed one key at a time by calling first/1 and next/2. last_prev * The table is traversed one key at a time by calling last/1 and prev/2. select * The table is traversed by calling select/3 and select/1. Option n_objects determines the number of objects returned (the third argument of select/3); the default is to return 100 objects at a time. The match specification (the second argument of select/3) is assembled by QLC: simple filters are translated into equivalent match specifications while more complicated filters must be applied to all objects returned by select/3 given a match specification that matches all objects. {select, ``MatchSpec``} * As for select, the table is traversed by calling select/3 and select/1. The difference is that the match specification is explicitly specified. This is how to state match specifications that cannot easily be expressed within the syntax provided by QLC. Examples: An explicit match specification is here used to traverse the table: 9&gt; true = ets:insert(Tab = ets:new(t, []), [{1,a},{2,b},{3,c},{4,d}]), MS = ets:fun2ms(fun({X,Y}) when (X &gt; 1) or (X &lt; 5) -&gt; {Y} end), QH1 = ets:table(Tab, [{traverse, {select, MS}}]). An example with an implicit match specification: 10&gt; QH2 = qlc:q([{Y} || {X,Y} &lt;- ets:table(Tab), (X &gt; 1) or (X &lt; 5)]). The latter example is equivalent to the former, which can be verified using function qlc:info/1: 11&gt; qlc:info(QH1) =:= qlc:info(QH2). true qlc:info/1 returns information about a query handle, and in this case identical information is returned for the two query handles."},{"ref":"ets.html#take/2","title":"ets.take/2","type":"function","doc":"Returns and removes a list of all objects with key Key in table Tab. The specified Key is used to identify the object by either comparing equal the key of an object in an ordered_set table, or matching in other types of tables (for details on the difference, see lookup/2 and new/2)."},{"ref":"ets.html#test_ms/2","title":"ets.test_ms/2","type":"function","doc":"This function is a utility to test a match specification used in calls to select/2. The function both tests MatchSpec for &quot;syntactic&quot; correctness and runs the match specification against object Tuple. If the match specification is syntactically correct, the function either returns {ok,``Result``}, where Result is what would have been the result in a real select/2 call, or false if the match specification does not match object Tuple. If the match specification contains errors, tuple {error, ``Errors``} is returned, where Errors is a list of natural language descriptions of what was wrong with the match specification. This is a useful debugging and test tool, especially when writing complicated select/2 calls. See also: erlang:match_spec_test/3."},{"ref":"ets.html#to_dets/2","title":"ets.to_dets/2","type":"function","doc":"Fills an already created/opened Dets table with the objects in the already opened ETS table named Tab. The Dets table is emptied before the objects are inserted."},{"ref":"ets.html#update_counterupdate_counterupdate_counterupdate_counterupdate_counterupdate_counter/343434","title":"ets.update_counterupdate_counterupdate_counterupdate_counterupdate_counterupdate_counter/343434","type":"function","doc":"This function provides an efficient way to update one or more counters, without the trouble of having to look up an object, update the object by incrementing an element, and insert the resulting object into the table again. The operation is guaranteed to be atomic and isolated. This function destructively update the object with key Key in table Tab by adding Incr to the element at position Pos. The new counter value is returned. If no position is specified, the element directly following key (&lt;keypos&gt;+1) is updated. If a Threshold is specified, the counter is reset to value SetValue if the following conditions occur: * `Incr` is not negative (`&gt;= 0`) and the result would be greater than (`&gt;`) `Threshold`. * `Incr` is negative (`&lt; 0`) and the result would be less than (`&lt;`) `Threshold`. A list of UpdateOp can be supplied to do many update operations within the object. The operations are carried out in the order specified in the list. If the same counter position occurs more than once in the list, the corresponding counter is thus updated many times, each time based on the previous result. The return value is a list of the new counter values from each update operation in the same order as in the operation list. If an empty list is specified, nothing is updated and an empty list is returned. If the function fails, no updates are done. The specified Key is used to identify the object by either matching the key of an object in a set table, or compare equal to the key of an object in an ordered_set table (for details on the difference, see lookup/2 and new/2). If a default object Default is specified, it is used as the object to be updated if the key is missing from the table. The value in place of the key is ignored and replaced by the proper key value. The return value is as if the default object had not been used, that is, a single updated element or a list of them. The function fails with reason badarg in the following situations: * The table type is not `set` or `ordered_set`. * No object with the correct key exists and no default object was supplied. * The object has the wrong arity. * The default object arity is smaller than `&lt;keypos&gt;`. * Any field from the default object that is updated is not an integer. * The element to update is not an integer. * The element to update is also the key. * Any of `Pos`, `Incr`, `Threshold`, or `SetValue` is not an integer."},{"ref":"ets.html#update_elementupdate_element/33","title":"ets.update_elementupdate_element/33","type":"function","doc":"This function provides an efficient way to update one or more elements within an object, without the trouble of having to look up, update, and write back the entire object. This function destructively updates the object with key Key in table Tab. The element at position Pos is given the value Value. A list of {``Pos``,``Value``} can be supplied to update many elements within the same object. If the same position occurs more than once in the list, the last value in the list is written. If the list is empty or the function fails, no updates are done. The function is also atomic in the sense that other processes can never see any intermediate results. Returns true if an object with key Key is found, otherwise false. The specified Key is used to identify the object by either matching the key of an object in a set table, or compare equal to the key of an object in an ordered_set table (for details on the difference, see lookup/2 and new/2). The function fails with reason badarg in the following situations: * The table type is not `set` or `ordered_set`. * `Pos` &lt; 1. * `Pos` &gt; object arity. * The element to update is also the key."},{"ref":"ets.html#whereis/1","title":"ets.whereis/1","type":"function","doc":"This function returns the tid() of the named table identified by TableName, or undefined if no such table exists. The tid() can be used in place of the table name in all operations, which is slightly faster since the name does not have to be resolved on each call. If the table is deleted, the tid() will be invalid even if another named table is created with the same name."},{"ref":"file_sorter.html","title":"file_sorter","type":"module","doc":"This module contains functions for sorting terms on files, merging already sorted files, and checking files for sortedness. Chunks containing binary terms are read from a sequence of files, sorted internally in memory and written on temporary files, which are merged producing one sorted file as output. Merging is provided as an optimization; it is faster when the files are already sorted, but it always works to sort instead of merge. On a file, a term is represented by a header and a binary. Two options define the format of terms on files: {header, HeaderLength} * HeaderLength determines the number of bytes preceding each binary and containing the length of the binary in bytes. Defaults to 4. The order of the header bytes is defined as follows: if B is a binary containing a header only, size Size of the binary is calculated as &lt;&lt;Size:HeaderLength/unit:8&gt;&gt; = B. {format, Format} * Option Format determines the function that is applied to binaries to create the terms to be sorted. Defaults to binary_term, which is equivalent to funbinary_to_term/1. Value binary is equivalent to fun(X) -&gt; X end, which means that the binaries are sorted as they are. This is the fastest format. If Format is term, io:read/2 is called to read terms. In that case, only the default value of option header is allowed. Option format also determines what is written to the sorted output file: if Format is term, then io:format/3 is called to write each term, otherwise the binary prefixed by a header is written. Notice that the binary written is the same binary that was read; the results of applying function Format are thrown away when the terms have been sorted. Reading and writing terms using the io module is much slower than reading and writing binaries. Other options are: {order, Order} * The default is to sort terms in ascending order, but that can be changed by value descending or by specifying an ordering function Fun. An ordering function is antisymmetric, transitive, and total. Fun(A,B) is to return true if A comes before B in the ordering, otherwise false. An example of a typical ordering function is less than or equal to, =&lt;/2. Using an ordering function slows down the sort considerably. Functions keysort, keymerge and keycheck do not accept ordering functions. {unique, boolean()} * When sorting or merging files, only the first of a sequence of terms that compare equal (==) is output if this option is set to true. Defaults to false, which implies that all terms that compare equal are output. When checking files for sortedness, a check that no pair of consecutive terms compares equal is done if this option is set to true. {tmpdir, TempDirectory} * The directory where temporary files are put can be chosen explicitly. The default, implied by value &quot;&quot;, is to put temporary files on the same directory as the sorted output file. If output is a function (see below), the directory returned by file:get_cwd() is used instead. The names of temporary files are derived from the Erlang nodename (node()), the process identifier of the current Erlang emulator (os:getpid()), and a unique integer (erlang:unique_integer([positive])). A typical name is fs_mynode@myhost_1763_4711.17, where 17 is a sequence number. Existing files are overwritten. Temporary files are deleted unless some uncaught EXIT signal occurs. {compressed, boolean()} * Temporary files and the output file can be compressed. Defaults false, which implies that written files are not compressed. Regardless of the value of option compressed, compressed files can always be read. Notice that reading and writing compressed files are significantly slower than reading and writing uncompressed files. {size, Size} By default about 5121024 bytes read from files are sorted internally. This option is rarely needed. {no_files, NoFiles} * By default 16 files are merged at a time. This option is rarely needed. As an alternative to sorting files, a function of one argument can be specified as input. When called with argument read, the function is assumed to return either of the following: * `end_of_input` or `{end_of_input, Value}}` when there is no more input (`Value` is explained below). * `{Objects, Fun}`, where `Objects` is a list of binaries or terms depending on the format, and `Fun` is a new input function. Any other value is immediately returned as value of the current call to sort or keysort. Each input function is called exactly once. If an error occurs, the last function is called with argument close, the reply of which is ignored. A function of one argument can be specified as output. The results of sorting or merging the input is collected in a non-empty sequence of variable length lists of binaries or terms depending on the format. The output function is called with one list at a time, and is assumed to return a new output function. Any other return value is immediately returned as value of the current call to the sort or merge function. Each output function is called exactly once. When some output function has been applied to all of the results or an error occurs, the last function is called with argument close, and the reply is returned as value of the current call to the sort or merge function. If a function is specified as input and the last input function returns {end_of_input, Value}, the function specified as output is called with argument {value, Value}. This makes it easy to initiate the sequence of output functions with a value calculated by the input functions. As an example, consider sorting the terms on a disk log file. A function that reads chunks from the disk log and returns a list of binaries is used as input. The results are collected in a list of terms. sort(Log) -&gt; {ok, _} = disk_log:open([{name,Log}, {mode,read_only}]), Input = input(Log, start), Output = output([]), Reply = file_sorter:sort(Input, Output, {format,term}), ok = disk_log:close(Log), Reply. input(Log, Cont) -&gt; fun(close) -&gt; ok; (read) -&gt; case disk_log:chunk(Log, Cont) of {error, Reason} -&gt; {error, Reason}; {Cont2, Terms} -&gt; {Terms, input(Log, Cont2)}; {Cont2, Terms, _Badbytes} -&gt; {Terms, input(Log, Cont2)}; eof -&gt; end_of_input end end. output(L) -&gt; fun(close) -&gt; lists:append(lists:reverse(L)); (Terms) -&gt; output([Terms | L]) end. For more examples of functions as input and output, see the end of the file_sorter module; the term format is implemented with functions. The possible values of Reason returned when an error occurs are: * `bad_object`, `{bad_object, FileName}` - Applying the format function failed for some binary, or the key(s) could not be extracted from some term. * `{bad_term, FileName}` - `io:read/2` failed to read some term. * `{file_error, FileName, file:posix()}` - For an explanation of `file:posix()`, see `file(3)`. * `{premature_eof, FileName}` - End-of-file was encountered inside some binary term."},{"ref":"file_sorter.html#checkcheck/12","title":"file_sorter.checkcheck/12","type":"function","doc":"Checks files for sortedness. If a file is not sorted, the first out-of-order element is returned. The first term on a file has position 1. check(FileName) is equivalent to check([FileName], [])."},{"ref":"file_sorter.html#keycheckkeycheck/23","title":"file_sorter.keycheckkeycheck/23","type":"function","doc":"Checks files for sortedness. If a file is not sorted, the first out-of-order element is returned. The first term on a file has position 1. keycheck(KeyPos, FileName) is equivalent to keycheck(KeyPos, [FileName], [])."},{"ref":"file_sorter.html#keymergekeymerge/34","title":"file_sorter.keymergekeymerge/34","type":"function","doc":"Merges tuples on files. Each input file is assumed to be sorted on key(s). keymerge(KeyPos, FileNames, Output) is equivalent to keymerge(KeyPos, FileNames, Output, [])."},{"ref":"file_sorter.html#keysort/2","title":"file_sorter.keysort/2","type":"function","doc":"Sorts tuples on files. keysort(N, FileName) is equivalent to keysort(N, [FileName], FileName)."},{"ref":"file_sorter.html#keysortkeysort/34","title":"file_sorter.keysortkeysort/34","type":"function","doc":"Sorts tuples on files. The sort is performed on the element(s) mentioned in KeyPos. If two tuples compare equal (==) on one element, the next element according to KeyPos is compared. The sort is stable. keysort(N, Input, Output) is equivalent to keysort(N, Input, Output, [])."},{"ref":"file_sorter.html#mergemerge/23","title":"file_sorter.mergemerge/23","type":"function","doc":"Merges terms on files. Each input file is assumed to be sorted. merge(FileNames, Output) is equivalent to merge(FileNames, Output, [])."},{"ref":"file_sorter.html#sort/1","title":"file_sorter.sort/1","type":"function","doc":"Sorts terms on files. sort(FileName) is equivalent to sort([FileName], FileName)."},{"ref":"file_sorter.html#sortsort/23","title":"file_sorter.sortsort/23","type":"function","doc":"Sorts terms on files. sort(Input, Output) is equivalent to sort(Input, Output, [])."},{"ref":"filelib.html","title":"filelib","type":"module","doc":"This module contains utilities on a higher level than the file module. This module does not support &quot;raw&quot; filenames (that is, files whose names do not comply with the expected encoding). Such files are ignored by the functions in this module. For more information about raw filenames, see the file module. Functionality in this module generally assumes valid input and does not necessarily fail on input that does not use a valid encoding, but may instead very likely produce invalid output. File operations used to accept filenames containing null characters (integer value zero). This caused the name to be truncated and in some cases arguments to primitive operations to be mixed up. Filenames containing null characters inside the filename are now rejected and will cause primitive file operations to fail. Currently null characters at the end of the filename will be accepted by primitive file operations. Such filenames are however still documented as invalid. The implementation will also change in the future and reject such filenames."},{"ref":"filelib.html#ensure_dir/1","title":"filelib.ensure_dir/1","type":"function","doc":"Ensures that all parent directories for the specified file or directory name Name exist, trying to create them if necessary. Returns ok if all parent directories already exist or can be created. Returns {error, ``Reason``} if some parent directory does not exist and cannot be created."},{"ref":"filelib.html#file_size/1","title":"filelib.file_size/1","type":"function","doc":"Returns the size of the specified file."},{"ref":"filelib.html#find_filefind_file/23","title":"filelib.find_filefind_file/23","type":"function","doc":"Looks for a file of the given name by applying suffix rules to the given directory path. For example, a rule {&quot;ebin&quot;, &quot;src&quot;} means that if the directory path ends with &quot;ebin&quot;, the corresponding path ending in &quot;src&quot; should be searched. If Rules is left out or is an empty list, the default system rules are used. See also the Kernel application parameter source_search_rules."},{"ref":"filelib.html#find_source/1","title":"filelib.find_source/1","type":"function","doc":"Equivalent to find_source(Base, Dir), where Dir is filename:dirname(``FilePath``) and Base is filename:basename(``FilePath``)."},{"ref":"filelib.html#find_sourcefind_source/23","title":"filelib.find_sourcefind_source/23","type":"function","doc":"Applies file extension specific rules to find the source file for a given object file relative to the object directory. For example, for a file with the extension .beam, the default rule is to look for a file with a corresponding extension .erl by replacing the suffix &quot;ebin&quot; of the object directory path with &quot;src&quot; or &quot;src/*&quot;. The file search is done through find_file/3. The directory of the object file is always tried before any other directory specified by the rules. If Rules is left out or is an empty list, the default system rules are used. See also the Kernel application parameter source_search_rules."},{"ref":"filelib.html#fold_files/5","title":"filelib.fold_files/5","type":"function","doc":"Folds function Fun over all (regular) files F in directory Dir that match the regular expression RegExp (for a description of the allowed regular expressions, see the re module). If Recursive is true, all subdirectories to Dir are processed. The regular expression matching is only done on the filename without the directory part. If Unicode filename translation is in effect and the file system is transparent, filenames that cannot be interpreted as Unicode can be encountered, in which case the fun() must be prepared to handle raw filenames (that is, binaries). If the regular expression contains codepoints &gt; 255, it does not match filenames that do not conform to the expected character encoding (that is, are not encoded in valid UTF-8). For more information about raw filenames, see the file module."},{"ref":"filelib.html#is_dir/1","title":"filelib.is_dir/1","type":"function","doc":"Returns true if Name refers to a directory, otherwise false."},{"ref":"filelib.html#is_file/1","title":"filelib.is_file/1","type":"function","doc":"Returns true if Name refers to a file or a directory, otherwise false."},{"ref":"filelib.html#is_regular/1","title":"filelib.is_regular/1","type":"function","doc":"Returns true if Name refers to a (regular) file, otherwise false."},{"ref":"filelib.html#last_modified/1","title":"filelib.last_modified/1","type":"function","doc":"Returns the date and time the specified file or directory was last modified, or 0 if the file does not exist."},{"ref":"filelib.html#wildcard/1","title":"filelib.wildcard/1","type":"function","doc":"Returns a list of all files that match Unix-style wildcard string Wildcard. The wildcard string looks like an ordinary filename, except that the following &quot;wildcard characters&quot; are interpreted in a special way: ? * Matches one character. Matches any number of characters up to the end of the filename, the next dot, or the next slash. * Two adjacent * used as a single pattern match all files and zero or more directories and subdirectories. [Character1,Character2,...] * Matches any of the characters listed. Two characters separated by a hyphen match a range of characters. Example: [A-Z] matches any uppercase letter. {Item,...} * Alternation. Matches one of the alternatives. Other characters represent themselves. Only filenames that have exactly the same character in the same position match. Matching is case-sensitive, for example, &quot;a&quot; does not match &quot;A&quot;. Directory separators must always be written as /, even on Windows. A character preceded by \\ loses its special meaning. Note that \\ must be written as \\\\ in a string literal. For example, &quot;\\?*&quot; will match any filename starting with ?. Notice that multiple &quot;*&quot; characters are allowed (as in Unix wildcards, but opposed to Windows/DOS wildcards). Examples: The following examples assume that the current directory is the top of an Erlang/OTP installation. To find all .beam files in all applications, use the following line: filelib:wildcard(&quot;lib/*/ebin/*.beam&quot;). To find .erl or .hrl in all applications src directories, use either of the following lines: filelib:wildcard(&quot;lib/*/src/*.?rl&quot;) filelib:wildcard(&quot;lib/*/src/*.{erl,hrl}&quot;) To find all .hrl files in src or include directories: filelib:wildcard(&quot;lib/*/{src,include}/*.hrl&quot;). To find all .erl or .hrl files in either src or include directories: filelib:wildcard(&quot;lib/*/{src,include}/*.{erl,hrl}&quot;) To find all .erl or .hrl files in any subdirectory: filelib:wildcard(&quot;lib/**/*.{erl,hrl}&quot;)"},{"ref":"filelib.html#wildcard/2","title":"filelib.wildcard/2","type":"function","doc":"Same as wildcard/1, except that Cwd is used instead of the working directory."},{"ref":"filename.html","title":"filename","type":"module","doc":"This module provides functions for analyzing and manipulating filenames. These functions are designed so that the Erlang code can work on many different platforms with different filename formats. With filename is meant all strings that can be used to denote a file. The filename can be a short relative name like foo.erl, a long absolute name including a drive designator, a directory name like D:\\usr/local\\bin\\erl/lib\\tools\\foo.erl, or any variations in between. In Windows, all functions return filenames with forward slashes only, even if the arguments contain backslashes. To normalize a filename by removing redundant directory separators, use join/1. The module supports raw filenames in the way that if a binary is present, or the filename cannot be interpreted according to the return value of file:native_name_encoding/0, a raw filename is also returned. For example, join/1 provided with a path component that is a binary (and cannot be interpreted under the current native filename encoding) results in a raw filename that is returned (the join operation is performed of course). For more information about raw filenames, see the file module. Functionality in this module generally assumes valid input and does not necessarily fail on input that does not use a valid encoding, but may instead very likely produce invalid output. File operations used to accept filenames containing null characters (integer value zero). This caused the name to be truncated and in some cases arguments to primitive operations to be mixed up. Filenames containing null characters inside the filename are now rejected and will cause primitive file operations to fail. Currently null characters at the end of the filename will be accepted by primitive file operations. Such filenames are however still documented as invalid. The implementation will also change in the future and reject such filenames."},{"ref":"filename.html#absname/1","title":"filename.absname/1","type":"function","doc":"Converts a relative Filename and returns an absolute name. No attempt is made to create the shortest absolute name, as this can give incorrect results on file systems that allow links. Unix examples: 1&gt; pwd(). &quot;/usr/local&quot; 2&gt; filename:absname(&quot;foo&quot;). &quot;/usr/local/foo&quot; 3&gt; filename:absname(&quot;../x&quot;). &quot;/usr/local/../x&quot; 4&gt; filename:absname(&quot;/&quot;). &quot;/&quot; Windows examples: 1&gt; pwd(). &quot;D:/usr/local&quot; 2&gt; filename:absname(&quot;foo&quot;). &quot;D:/usr/local/foo&quot; 3&gt; filename:absname(&quot;../x&quot;). &quot;D:/usr/local/../x&quot; 4&gt; filename:absname(&quot;/&quot;). &quot;D:/&quot;"},{"ref":"filename.html#absname/2","title":"filename.absname/2","type":"function","doc":"Same as absname/1, except that the directory to which the filename is to be made relative is specified in argument Dir."},{"ref":"filename.html#absname_join/2","title":"filename.absname_join/2","type":"function","doc":"Joins an absolute directory with a relative filename. Similar to join/2, but on platforms with tight restrictions on raw filename length and no support for symbolic links (read: VxWorks), leading parent directory components in Filename are matched against trailing directory components in Dir so they can be removed from the result - minimizing its length."},{"ref":"filename.html#basedirbasedir/22","title":"filename.basedirbasedir/22","type":"function","doc":"Equivalent to basedir(PathType, Application, \#{}) or basedir(PathsType, Application, \#{})."},{"ref":"filename.html#basedirbasedir/33","title":"filename.basedirbasedir/33","type":"function","doc":"Returns a suitable path, or paths, for a given type. If os is not set in Opts the function will default to the native option, that is &#39;linux&#39;, &#39;darwin&#39; or &#39;windows&#39;, as understood by os:type/0. Anything not recognized as &#39;darwin&#39; or &#39;windows&#39; is interpreted as &#39;linux&#39;. The options &#39;author&#39; and &#39;version&#39; are only used with &#39;windows&#39; option mode. * `user_cache` The path location is intended for transient data files on a local machine. On Linux: Respects the os environment variable XDG_CACHE_HOME. 1&gt; filename:basedir(user_cache, &quot;my_application&quot;, \#{os=&gt;linux}). &quot;/home/otptest/.cache/my_application&quot; On Darwin: 1&gt; filename:basedir(user_cache, &quot;my_application&quot;, \#{os=&gt;darwin}). &quot;/home/otptest/Library/Caches/my_application&quot; On Windows: 1&gt; filename:basedir(user_cache, &quot;My App&quot;). &quot;c:/Users/otptest/AppData/Local/My App/Cache&quot; 2&gt; filename:basedir(user_cache, &quot;My App&quot;). &quot;c:/Users/otptest/AppData/Local/My App/Cache&quot; 3&gt; filename:basedir(user_cache, &quot;My App&quot;, \#{author=&gt;&quot;Erlang&quot;}). &quot;c:/Users/otptest/AppData/Local/Erlang/My App/Cache&quot; 4&gt; filename:basedir(user_cache, &quot;My App&quot;, \#{version=&gt;&quot;1.2&quot;}). &quot;c:/Users/otptest/AppData/Local/My App/1.2/Cache&quot; 5&gt; filename:basedir(user_cache, &quot;My App&quot;, \#{author=&gt;&quot;Erlang&quot;,version=&gt;&quot;1.2&quot;}). &quot;c:/Users/otptest/AppData/Local/Erlang/My App/1.2/Cache&quot; * `user_config` The path location is intended for persistent configuration files. On Linux: Respects the os environment variable XDG_CONFIG_HOME. 2&gt; filename:basedir(user_config, &quot;my_application&quot;, \#{os=&gt;linux}). &quot;/home/otptest/.config/my_application&quot; On Darwin: 2&gt; filename:basedir(user_config, &quot;my_application&quot;, \#{os=&gt;darwin}). &quot;/home/otptest/Library/Application Support/my_application&quot; On Windows: 1&gt; filename:basedir(user_config, &quot;My App&quot;). &quot;c:/Users/otptest/AppData/Roaming/My App&quot; 2&gt; filename:basedir(user_config, &quot;My App&quot;, \#{author=&gt;&quot;Erlang&quot;, version=&gt;&quot;1.2&quot;}). &quot;c:/Users/otptest/AppData/Roaming/Erlang/My App/1.2&quot; * `user_data` The path location is intended for persistent data files. On Linux: Respects the os environment variable XDG_DATA_HOME. 3&gt; filename:basedir(user_data, &quot;my_application&quot;, \#{os=&gt;linux}). &quot;/home/otptest/.local/my_application&quot; On Darwin: 3&gt; filename:basedir(user_data, &quot;my_application&quot;, \#{os=&gt;darwin}). &quot;/home/otptest/Library/Application Support/my_application&quot; On Windows: 8&gt; filename:basedir(user_data, &quot;My App&quot;). &quot;c:/Users/otptest/AppData/Local/My App&quot; 9&gt; filename:basedir(user_data, &quot;My App&quot;,\#{author=&gt;&quot;Erlang&quot;,version=&gt;&quot;1.2&quot;}). &quot;c:/Users/otptest/AppData/Local/Erlang/My App/1.2&quot; * `user_log` The path location is intended for transient log files on a local machine. On Linux: Respects the os environment variable XDG_CACHE_HOME. 4&gt; filename:basedir(user_log, &quot;my_application&quot;, \#{os=&gt;linux}). &quot;/home/otptest/.cache/my_application/log&quot; On Darwin: 4&gt; filename:basedir(user_log, &quot;my_application&quot;, \#{os=&gt;darwin}). &quot;/home/otptest/Library/Caches/my_application&quot; On Windows: 12&gt; filename:basedir(user_log, &quot;My App&quot;). &quot;c:/Users/otptest/AppData/Local/My App/Logs&quot; 13&gt; filename:basedir(user_log, &quot;My App&quot;,\#{author=&gt;&quot;Erlang&quot;,version=&gt;&quot;1.2&quot;}). &quot;c:/Users/otptest/AppData/Local/Erlang/My App/1.2/Logs&quot; * `site_config` On Linux: Respects the os environment variable `XDG_CONFIG_DIRS`. 5&gt; filename:basedir(site_data, &quot;my_application&quot;, \#{os=&gt;linux}). [&quot;/usr/local/share/my_application&quot;, &quot;/usr/share/my_application&quot;] 6&gt; os:getenv(&quot;XDG_CONFIG_DIRS&quot;). &quot;/etc/xdg/xdg-ubuntu:/usr/share/upstart/xdg:/etc/xdg&quot; 7&gt; filename:basedir(site_config, &quot;my_application&quot;, \#{os=&gt;linux}). [&quot;/etc/xdg/xdg-ubuntu/my_application&quot;, &quot;/usr/share/upstart/xdg/my_application&quot;, &quot;/etc/xdg/my_application&quot;] 8&gt; os:unsetenv(&quot;XDG_CONFIG_DIRS&quot;). true 9&gt; filename:basedir(site_config, &quot;my_application&quot;, \#{os=&gt;linux}). [&quot;/etc/xdg/my_application&quot;] On Darwin: 5&gt; filename:basedir(site_config, &quot;my_application&quot;, \#{os=&gt;darwin}). [&quot;/Library/Application Support/my_application&quot;] * `site_data` On Linux: Respects the os environment variable `XDG_DATA_DIRS`. 10&gt; os:getenv(&quot;XDG_DATA_DIRS&quot;). &quot;/usr/share/ubuntu:/usr/share/gnome:/usr/local/share/:/usr/share/&quot; 11&gt; filename:basedir(site_data, &quot;my_application&quot;, \#{os=&gt;linux}). [&quot;/usr/share/ubuntu/my_application&quot;, &quot;/usr/share/gnome/my_application&quot;, &quot;/usr/local/share/my_application&quot;, &quot;/usr/share/my_application&quot;] 12&gt; os:unsetenv(&quot;XDG_DATA_DIRS&quot;). true 13&gt; filename:basedir(site_data, &quot;my_application&quot;, \#{os=&gt;linux}). [&quot;/usr/local/share/my_application&quot;, &quot;/usr/share/my_application&quot;] On Darwin: 5&gt; filename:basedir(site_data, &quot;my_application&quot;, \#{os=&gt;darwin}). [&quot;/Library/Application Support/my_application&quot;]"},{"ref":"filename.html#basename/1","title":"filename.basename/1","type":"function","doc":"Returns the last component of Filename, or Filename itself if it does not contain any directory separators. Examples: 5&gt; filename:basename(&quot;foo&quot;). &quot;foo&quot; 6&gt; filename:basename(&quot;/usr/foo&quot;). &quot;foo&quot; 7&gt; filename:basename(&quot;/&quot;). []"},{"ref":"filename.html#basename/2","title":"filename.basename/2","type":"function","doc":"Returns the last component of Filename with extension Ext stripped. This function is to be used to remove a (possible) specific extension. To remove an existing extension when you are unsure which one it is, use rootname(basename(Filename)). Examples: 8&gt; filename:basename(&quot;~/src/kalle.erl&quot;, &quot;.erl&quot;). &quot;kalle&quot; 9&gt; filename:basename(&quot;~/src/kalle.beam&quot;, &quot;.erl&quot;). &quot;kalle.beam&quot; 10&gt; filename:basename(&quot;~/src/kalle.old.erl&quot;, &quot;.erl&quot;). &quot;kalle.old&quot; 11&gt; filename:rootname(filename:basename(&quot;~/src/kalle.erl&quot;)). &quot;kalle&quot; 12&gt; filename:rootname(filename:basename(&quot;~/src/kalle.beam&quot;)). &quot;kalle&quot;"},{"ref":"filename.html#dirname/1","title":"filename.dirname/1","type":"function","doc":"Returns the directory part of Filename. Examples: 13&gt; filename:dirname(&quot;/usr/src/kalle.erl&quot;). &quot;/usr/src&quot; 14&gt; filename:dirname(&quot;kalle.erl&quot;). &quot;.&quot; 5&gt; filename:dirname(&quot;\\\\usr\\\\src/kalle.erl&quot;). % Windows &quot;/usr/src&quot;"},{"ref":"filename.html#extension/1","title":"filename.extension/1","type":"function","doc":"Returns the file extension of Filename, including the period. Returns an empty string if no extension exists. Examples: 15&gt; filename:extension(&quot;foo.erl&quot;). &quot;.erl&quot; 16&gt; filename:extension(&quot;beam.src/kalle&quot;). []"},{"ref":"filename.html#find_srcfind_src/12","title":"filename.find_srcfind_src/12","type":"function","doc":"Finds the source filename and compiler options for a module. The result can be fed to compile:file/2 to compile the file again. This function is deprecated. Use filelib:find_source/1 instead for finding source files. If possible, use the beam_lib(3) module to extract the compiler options and the abstract code format from the Beam file and compile that instead. Argument Beam, which can be a string or an atom, specifies either the module name or the path to the source code, with or without extension &quot;.erl&quot;. In either case, the module must be known by the code server, that is, code:which(``Module``) must succeed. Rules describes how the source directory can be found when the object code directory is known. It is a list of tuples {``BinSuffix``, ``SourceSuffix``} and is interpreted as follows: if the end of the directory name where the object is located matches BinSuffix, then the name created by replacing BinSuffix with SourceSuffix is expanded by calling filelib:wildcard/1. If a regular file is found among the matches, the function returns that location together with Options. Otherwise the next rule is tried, and so on. Rules defaults to: [{&quot;&quot;, &quot;&quot;}, {&quot;ebin&quot;, &quot;src&quot;}, {&quot;ebin&quot;, &quot;esrc&quot;}, {&quot;ebin&quot;, &quot;src/*&quot;}, {&quot;ebin&quot;, &quot;esrc/*&quot;}] The function returns {``SourceFile``, ``Options``} if it succeeds. SourceFile is the absolute path to the source file without extension &quot;.erl&quot;. Options includes the options that are necessary to recompile the file with compile:file/2, but excludes options such as report and verbose, which do not change the way code is generated. The paths in options {outdir, ``Path``} and {i, Path} are guaranteed to be absolute."},{"ref":"filename.html#flatten/1","title":"filename.flatten/1","type":"function","doc":"Converts a possibly deep list filename consisting of characters and atoms into the corresponding flat string filename."},{"ref":"filename.html#join/1","title":"filename.join/1","type":"function","doc":"Joins a list of filename Components with directory separators. If one of the elements of Components includes an absolute path, such as &quot;/xxx&quot;, the preceding elements, if any, are removed from the result. The result is &quot;normalized&quot;: * Redundant directory separators are removed. * In Windows, all directory separators are forward slashes and the drive letter is in lower case. Examples: 17&gt; filename:join([&quot;/usr&quot;, &quot;local&quot;, &quot;bin&quot;]). &quot;/usr/local/bin&quot; 18&gt; filename:join([&quot;a/b///c/&quot;]). &quot;a/b/c&quot; 6&gt; filename:join([&quot;B:a\\\\b///c/&quot;]). % Windows &quot;b:a/b/c&quot;"},{"ref":"filename.html#join/2","title":"filename.join/2","type":"function","doc":"Joins two filename components with directory separators. Equivalent to join([``Name1``, ``Name2``])."},{"ref":"filename.html#nativename/1","title":"filename.nativename/1","type":"function","doc":"Converts Path to a form accepted by the command shell and native applications on the current platform. On Windows, forward slashes are converted to backward slashes. On all platforms, the name is normalized as done by join/1. Examples: 19&gt; filename:nativename(&quot;/usr/local/bin/&quot;). % Unix &quot;/usr/local/bin&quot; 7&gt; filename:nativename(&quot;/usr/local/bin/&quot;). % Windows &quot;\\\\usr\\\\local\\\\bin&quot;"},{"ref":"filename.html#pathtype/1","title":"filename.pathtype/1","type":"function","doc":"Returns the path type, which is one of the following: absolute * The path name refers to a specific file on a specific volume. Unix example: /usr/local/bin Windows example: D:/usr/local/bin relative * The path name is relative to the current working directory on the current volume. Example: foo/bar, ../src volumerelative * The path name is relative to the current working directory on a specified volume, or it is a specific file on the current working volume. Windows example: D:bar.erl, /bar/foo.erl"},{"ref":"filename.html#rootnamerootname/12","title":"filename.rootnamerootname/12","type":"function","doc":"Removes a filename extension. rootname/2 works as rootname/1, except that the extension is removed only if it is Ext. Examples: 20&gt; filename:rootname(&quot;/beam.src/kalle&quot;). &quot;/beam.src/kalle&quot; 21&gt; filename:rootname(&quot;/beam.src/foo.erl&quot;). &quot;/beam.src/foo&quot; 22&gt; filename:rootname(&quot;/beam.src/foo.erl&quot;, &quot;.erl&quot;). &quot;/beam.src/foo&quot; 23&gt; filename:rootname(&quot;/beam.src/foo.beam&quot;, &quot;.erl&quot;). &quot;/beam.src/foo.beam&quot;"},{"ref":"filename.html#safe_relative_path/1","title":"filename.safe_relative_path/1","type":"function","doc":"Sanitizes the relative path by eliminating &quot;..&quot; and &quot;.&quot; components to protect against directory traversal attacks. Either returns the sanitized path name, or the atom unsafe if the path is unsafe. The path is considered unsafe in the following circumstances: * The path is not relative. A &quot;..&quot; component would climb up above the root of the relative path. Examples: 1&gt; filename:safe_relative_path(&quot;dir/sub_dir/..&quot;). &quot;dir&quot; 2&gt; filename:safe_relative_path(&quot;dir/..&quot;). [] 3&gt; filename:safe_relative_path(&quot;dir/../..&quot;). unsafe 4&gt; filename:safe_relative_path(&quot;/abs/path&quot;). unsafe"},{"ref":"filename.html#split/1","title":"filename.split/1","type":"function","doc":"Returns a list whose elements are the path components of Filename. Examples: 24&gt; filename:split(&quot;/usr/local/bin&quot;). [&quot;/&quot;,&quot;usr&quot;,&quot;local&quot;,&quot;bin&quot;] 25&gt; filename:split(&quot;foo/bar&quot;). [&quot;foo&quot;,&quot;bar&quot;] 26&gt; filename:split(&quot;a:\\\\msdev\\\\include&quot;). [&quot;a:/&quot;,&quot;msdev&quot;,&quot;include&quot;]"},{"ref":"gb_sets.html","title":"gb_sets","type":"module","doc":"This module provides ordered sets using Prof. Arne Andersson&#39;s General Balanced Trees. Ordered sets can be much more efficient than using ordered lists, for larger sets, but depends on the application. This module considers two elements as different if and only if they do not compare equal (==)."},{"ref":"gb_sets.html#addadd_element/22","title":"gb_sets.addadd_element/22","type":"function","doc":"Returns a new set formed from Set1 with Element inserted. If Element is already an element in Set1, nothing is changed."},{"ref":"gb_sets.html#balance/1","title":"gb_sets.balance/1","type":"function","doc":"Rebalances the tree representation of Set1. Notice that this is rarely necessary, but can be motivated when a large number of elements have been deleted from the tree without further insertions. Rebalancing can then be forced to minimise lookup times, as deletion does not rebalance the tree."},{"ref":"gb_sets.html#del_element/2","title":"gb_sets.del_element/2","type":"function","doc":"Returns a new set formed from Set1 with Element removed. If Element is not an element in Set1, nothing is changed."},{"ref":"gb_sets.html#delete/2","title":"gb_sets.delete/2","type":"function","doc":"Returns a new set formed from Set1 with Element removed. Assumes that Element is present in Set1."},{"ref":"gb_sets.html#delete_any/2","title":"gb_sets.delete_any/2","type":"function","doc":"Returns a new set formed from Set1 with Element removed. If Element is not an element in Set1, nothing is changed."},{"ref":"gb_sets.html#difference/2","title":"gb_sets.difference/2","type":"function","doc":"Returns only the elements of Set1 that are not also elements of Set2."},{"ref":"gb_sets.html#empty/0","title":"gb_sets.empty/0","type":"function","doc":"Returns a new empty set."},{"ref":"gb_sets.html#filter/2","title":"gb_sets.filter/2","type":"function","doc":"Filters elements in Set1 using predicate function Pred."},{"ref":"gb_sets.html#fold/3","title":"gb_sets.fold/3","type":"function","doc":"Folds Function over every element in Set returning the final value of the accumulator."},{"ref":"gb_sets.html#from_list/1","title":"gb_sets.from_list/1","type":"function","doc":"Returns a set of the elements in List, where List can be unordered and contain duplicates."},{"ref":"gb_sets.html#from_ordset/1","title":"gb_sets.from_ordset/1","type":"function","doc":"Turns an ordered-set list List into a set. The list must not contain duplicates."},{"ref":"gb_sets.html#insert/2","title":"gb_sets.insert/2","type":"function","doc":"Returns a new set formed from Set1 with Element inserted. Assumes that Element is not present in Set1."},{"ref":"gb_sets.html#intersection/1","title":"gb_sets.intersection/1","type":"function","doc":"Returns the intersection of the non-empty list of sets."},{"ref":"gb_sets.html#intersection/2","title":"gb_sets.intersection/2","type":"function","doc":"Returns the intersection of Set1 and Set2."},{"ref":"gb_sets.html#is_disjoint/2","title":"gb_sets.is_disjoint/2","type":"function","doc":"Returns true if Set1 and Set2 are disjoint (have no elements in common), otherwise false."},{"ref":"gb_sets.html#is_element/2","title":"gb_sets.is_element/2","type":"function","doc":"Returns true if Element is an element of Set, otherwise false."},{"ref":"gb_sets.html#is_empty/1","title":"gb_sets.is_empty/1","type":"function","doc":"Returns true if Set is an empty set, otherwise false."},{"ref":"gb_sets.html#is_member/2","title":"gb_sets.is_member/2","type":"function","doc":"Returns true if Element is an element of Set, otherwise false."},{"ref":"gb_sets.html#is_set/1","title":"gb_sets.is_set/1","type":"function","doc":"Returns true if Term appears to be a set, otherwise false."},{"ref":"gb_sets.html#is_subset/2","title":"gb_sets.is_subset/2","type":"function","doc":"Returns true when every element of Set1 is also a member of Set2, otherwise false."},{"ref":"gb_sets.html#iterator/1","title":"gb_sets.iterator/1","type":"function","doc":"Returns an iterator that can be used for traversing the entries of Set; see next/1. The implementation of this is very efficient; traversing the whole set using next/1 is only slightly slower than getting the list of all elements using to_list/1 and traversing that. The main advantage of the iterator approach is that it does not require the complete list of all elements to be built in memory at one time."},{"ref":"gb_sets.html#iterator_from/2","title":"gb_sets.iterator_from/2","type":"function","doc":"Returns an iterator that can be used for traversing the entries of Set; see next/1. The difference as compared to the iterator returned by iterator/1 is that the first element greater than or equal to Element is returned."},{"ref":"gb_sets.html#largest/1","title":"gb_sets.largest/1","type":"function","doc":"Returns the largest element in Set. Assumes that Set is not empty."},{"ref":"gb_sets.html#new/0","title":"gb_sets.new/0","type":"function","doc":"Returns a new empty set."},{"ref":"gb_sets.html#next/1","title":"gb_sets.next/1","type":"function","doc":"Returns {``Element``, ``Iter2``}, where Element is the smallest element referred to by iterator Iter1, and Iter2 is the new iterator to be used for traversing the remaining elements, or the atom none if no elements remain."},{"ref":"gb_sets.html#singleton/1","title":"gb_sets.singleton/1","type":"function","doc":"Returns a set containing only element Element."},{"ref":"gb_sets.html#size/1","title":"gb_sets.size/1","type":"function","doc":"Returns the number of elements in Set."},{"ref":"gb_sets.html#smallest/1","title":"gb_sets.smallest/1","type":"function","doc":"Returns the smallest element in Set. Assumes that Set is not empty."},{"ref":"gb_sets.html#subtract/2","title":"gb_sets.subtract/2","type":"function","doc":"Returns only the elements of Set1 that are not also elements of Set2."},{"ref":"gb_sets.html#take_largest/1","title":"gb_sets.take_largest/1","type":"function","doc":"Returns {``Element``, ``Set2``}, where Element is the largest element in Set1, and Set2 is this set with Element deleted. Assumes that Set1 is not empty."},{"ref":"gb_sets.html#take_smallest/1","title":"gb_sets.take_smallest/1","type":"function","doc":"Returns {``Element``, ``Set2``}, where Element is the smallest element in Set1, and Set2 is this set with Element deleted. Assumes that Set1 is not empty."},{"ref":"gb_sets.html#to_list/1","title":"gb_sets.to_list/1","type":"function","doc":"Returns the elements of Set as a list."},{"ref":"gb_sets.html#union/1","title":"gb_sets.union/1","type":"function","doc":"Returns the merged (union) set of the list of sets."},{"ref":"gb_sets.html#union/2","title":"gb_sets.union/2","type":"function","doc":"Returns the merged (union) set of Set1 and Set2."},{"ref":"gb_trees.html","title":"gb_trees","type":"module","doc":"This module provides Prof. Arne Andersson&#39;s General Balanced Trees. These have no storage overhead compared to unbalanced binary trees, and their performance is better than AVL trees. This module considers two keys as different if and only if they do not compare equal (==)."},{"ref":"gb_trees.html#balance/1","title":"gb_trees.balance/1","type":"function","doc":"Rebalances Tree1. Notice that this is rarely necessary, but can be motivated when many nodes have been deleted from the tree without further insertions. Rebalancing can then be forced to minimize lookup times, as deletion does not rebalance the tree."},{"ref":"gb_trees.html#delete/2","title":"gb_trees.delete/2","type":"function","doc":"Removes the node with key Key from Tree1 and returns the new tree. Assumes that the key is present in the tree, crashes otherwise."},{"ref":"gb_trees.html#delete_any/2","title":"gb_trees.delete_any/2","type":"function","doc":"Removes the node with key Key from Tree1 if the key is present in the tree, otherwise does nothing. Returns the new tree."},{"ref":"gb_trees.html#empty/0","title":"gb_trees.empty/0","type":"function","doc":"Returns a new empty tree."},{"ref":"gb_trees.html#enter/3","title":"gb_trees.enter/3","type":"function","doc":"Inserts Key with value Value into Tree1 if the key is not present in the tree, otherwise updates Key to value Value in Tree1. Returns the new tree."},{"ref":"gb_trees.html#from_orddict/1","title":"gb_trees.from_orddict/1","type":"function","doc":"Turns an ordered list List of key-value tuples into a tree. The list must not contain duplicate keys."},{"ref":"gb_trees.html#get/2","title":"gb_trees.get/2","type":"function","doc":"Retrieves the value stored with Key in Tree. Assumes that the key is present in the tree, crashes otherwise."},{"ref":"gb_trees.html#insert/3","title":"gb_trees.insert/3","type":"function","doc":"Inserts Key with value Value into Tree1 and returns the new tree. Assumes that the key is not present in the tree, crashes otherwise."},{"ref":"gb_trees.html#is_defined/2","title":"gb_trees.is_defined/2","type":"function","doc":"Returns true if Key is present in Tree, otherwise false."},{"ref":"gb_trees.html#is_empty/1","title":"gb_trees.is_empty/1","type":"function","doc":"Returns true if Tree is an empty tree, othwewise false."},{"ref":"gb_trees.html#iterator/1","title":"gb_trees.iterator/1","type":"function","doc":"Returns an iterator that can be used for traversing the entries of Tree; see next/1. The implementation of this is very efficient; traversing the whole tree using next/1 is only slightly slower than getting the list of all elements using to_list/1 and traversing that. The main advantage of the iterator approach is that it does not require the complete list of all elements to be built in memory at one time."},{"ref":"gb_trees.html#iterator_from/2","title":"gb_trees.iterator_from/2","type":"function","doc":"Returns an iterator that can be used for traversing the entries of Tree; see next/1. The difference as compared to the iterator returned by iterator/1 is that the first key greater than or equal to Key is returned."},{"ref":"gb_trees.html#keys/1","title":"gb_trees.keys/1","type":"function","doc":"Returns the keys in Tree as an ordered list."},{"ref":"gb_trees.html#largest/1","title":"gb_trees.largest/1","type":"function","doc":"Returns {``Key``, ``Value``}, where Key is the largest key in Tree, and Value is the value associated with this key. Assumes that the tree is not empty."},{"ref":"gb_trees.html#lookup/2","title":"gb_trees.lookup/2","type":"function","doc":"Looks up Key in Tree. Returns {value, ``Value``}, or none if Key is not present."},{"ref":"gb_trees.html#map/2","title":"gb_trees.map/2","type":"function","doc":"Maps function F(K, V1) -&gt; V2 to all key-value pairs of tree Tree1. Returns a new tree Tree2 with the same set of keys as Tree1 and the new set of values V2."},{"ref":"gb_trees.html#next/1","title":"gb_trees.next/1","type":"function","doc":"Returns {``Key``, ``Value``, ``Iter2``}, where Key is the smallest key referred to by iterator Iter1, and Iter2 is the new iterator to be used for traversing the remaining nodes, or the atom none if no nodes remain."},{"ref":"gb_trees.html#size/1","title":"gb_trees.size/1","type":"function","doc":"Returns the number of nodes in Tree."},{"ref":"gb_trees.html#smallest/1","title":"gb_trees.smallest/1","type":"function","doc":"Returns {``Key``, ``Value``}, where Key is the smallest key in Tree, and Value is the value associated with this key. Assumes that the tree is not empty."},{"ref":"gb_trees.html#take/2","title":"gb_trees.take/2","type":"function","doc":"Returns a value Value from node with key Key and new Tree2 without the node with this value. Assumes that the node with key is present in the tree, crashes otherwise."},{"ref":"gb_trees.html#take_any/2","title":"gb_trees.take_any/2","type":"function","doc":"Returns a value Value from node with key Key and new Tree2 without the node with this value. Returns error if the node with the key is not present in the tree."},{"ref":"gb_trees.html#take_largest/1","title":"gb_trees.take_largest/1","type":"function","doc":"Returns {``Key``, ``Value``, ``Tree2``}, where Key is the largest key in Tree1, Value is the value associated with this key, and Tree2 is this tree with the corresponding node deleted. Assumes that the tree is not empty."},{"ref":"gb_trees.html#take_smallest/1","title":"gb_trees.take_smallest/1","type":"function","doc":"Returns {``Key``, ``Value``, ``Tree2``}, where Key is the smallest key in Tree1, Value is the value associated with this key, and Tree2 is this tree with the corresponding node deleted. Assumes that the tree is not empty."},{"ref":"gb_trees.html#to_list/1","title":"gb_trees.to_list/1","type":"function","doc":"Converts a tree into an ordered list of key-value tuples."},{"ref":"gb_trees.html#update/3","title":"gb_trees.update/3","type":"function","doc":"Updates Key to value Value in Tree1 and returns the new tree. Assumes that the key is present in the tree."},{"ref":"gb_trees.html#values/1","title":"gb_trees.values/1","type":"function","doc":"Returns the values in Tree as an ordered list, sorted by their corresponding keys. Duplicates are not removed."},{"ref":"gen_event.html","title":"gen_event","type":"behaviour","doc":"This behavior module provides event handling functionality. It consists of a generic event manager process with any number of event handlers that are added and deleted dynamically. An event manager implemented using this module has a standard set of interface functions and includes functionality for tracing and error reporting. It also fits into an OTP supervision tree. For more information, see OTP Design Principles. Each event handler is implemented as a callback module exporting a predefined set of functions. The relationship between the behavior functions and the callback functions is as follows: gen_event module Callback module ---------------- --------------- gen_event:start gen_event:start_link -----&gt; - gen_event:add_handler gen_event:add_sup_handler -----&gt; Module:init/1 gen_event:notify gen_event:sync_notify -----&gt; Module:handle_event/2 gen_event:call -----&gt; Module:handle_call/2 - -----&gt; Module:handle_info/2 gen_event:delete_handler -----&gt; Module:terminate/2 gen_event:swap_handler gen_event:swap_sup_handler -----&gt; Module1:terminate/2 Module2:init/1 gen_event:which_handlers -----&gt; - gen_event:stop -----&gt; Module:terminate/2 - -----&gt; Module:code_change/3 As each event handler is one callback module, an event manager has many callback modules that are added and deleted dynamically. gen_event is therefore more tolerant of callback module errors than the other behaviors. If a callback function for an installed event handler fails with Reason, or returns a bad value Term, the event manager does not fail. It deletes the event handler by calling callback function Module:terminate/2, giving as argument {error,{&#39;EXIT&#39;,Reason}} or {error,Term}, respectively. No other event handler is affected. A gen_event process handles system messages as described in sys(3). The sys module can be used for debugging an event manager. Notice that an event manager does trap exit signals automatically. The gen_event process can go into hibernation (see erlang:hibernate/3) if a callback function in a handler module specifies hibernate in its return value. This can be useful if the server is expected to be idle for a long time. However, use this feature with care, as hibernation implies at least two garbage collections (when hibernating and shortly after waking up) and is not something you want to do between each event handled by a busy event manager. Notice that when multiple event handlers are invoked, it is sufficient that one single event handler returns a hibernate request for the whole event manager to go into hibernation. Unless otherwise stated, all functions in this module fail if the specified event manager does not exist or if bad arguments are specified."},{"ref":"gen_fsm.html","title":"gen_fsm","type":"behaviour","doc":"Deprecated and replaced by gen_statem"},{"ref":"gen_server.html","title":"gen_server","type":"behaviour","doc":"This behavior module provides the server of a client-server relation. A generic server process (gen_server) implemented using this module has a standard set of interface functions and includes functionality for tracing and error reporting. It also fits into an OTP supervision tree. For more information, see section gen_server Behaviour in OTP Design Principles. A gen_server process assumes all specific parts to be located in a callback module exporting a predefined set of functions. The relationship between the behavior functions and the callback functions is as follows: gen_server module Callback module ----------------- --------------- gen_server:start gen_server:start_link -----&gt; Module:init/1 gen_server:stop -----&gt; Module:terminate/2 gen_server:call gen_server:multi_call -----&gt; Module:handle_call/3 gen_server:cast gen_server:abcast -----&gt; Module:handle_cast/2 - -----&gt; Module:handle_info/2 - -----&gt; Module:handle_continue/2 - -----&gt; Module:terminate/2 - -----&gt; Module:code_change/3 If a callback function fails or returns a bad value, the gen_server process terminates. A gen_server process handles system messages as described in sys(3). The sys module can be used for debugging a gen_server process. Notice that a gen_server process does not trap exit signals automatically, this must be explicitly initiated in the callback module. Unless otherwise stated, all functions in this module fail if the specified gen_server process does not exist or if bad arguments are specified. The gen_server process can go into hibernation (see erlang:hibernate/3) if a callback function specifies &#39;hibernate&#39; instead of a time-out value. This can be useful if the server is expected to be idle for a long time. However, use this feature with care, as hibernation implies at least two garbage collections (when hibernating and shortly after waking up) and is not something you want to do between each call to a busy server. If the gen_server process needs to perform an action immediately after initialization or to break the execution of a callback into multiple steps, it can return {continue,Continue} in place of the time-out or hibernation value, which will immediately invoke the handle_continue/2 callback."},{"ref":"gen_statem.html","title":"gen_statem","type":"behaviour","doc":"gen_statem provides a generic state machine behaviour that for new code replaces its predecessor gen_fsm since Erlang/OTP 20.0. The gen_fsm behaviour remains in OTP &quot;as is&quot;. If you are new to gen_statem and want an overview of concepts and operation the section gen_statemBehaviour located in the User&#39;s Guide OTP Design Principles is recommended to read before this reference manual, possibly after the Description section you are reading here. This reference manual contains type descriptions generated from types in the gen_statem source code, so they are correct. However, the generated descriptions also reflect the type hierarchy, which sometimes makes it hard to get a good overview. If so, see the section gen_statemBehaviour in the OTP Design Principles User&#39;s Guide. * This behavior appeared in Erlang/OTP 19.0. * In OTP 19.1 a backwards incompatible change of the return tuple from `Module:init/1` was made and the mandatory callback function `Module:callback_mode/0` was introduced. * In OTP 20.0 generic time-outs were added. * In OTP 22.1 time-out content `update` and explicit time-out `cancel` were added. `gen_statem` has got the same features that `gen_fsm` had and adds some really useful: * Co-located state code * Arbitrary term state * Event postponing * Self-generated events * State time-out * Multiple generic named time-outs * Absolute time-out time * Automatic state enter calls * Reply from other state than the request, `sys` traceable * Multiple `sys` traceable replies Two callback modes are supported: * One for finite-state machines (`gen_fsm` like), which requires the state to be an atom and uses that state as the name of the current callback function * One without restriction on the state data type that uses one callback function for all states The callback model(s) for `gen_statem` differs from the one for `gen_fsm`, but it is still fairly easy to rewrite from `gen_fsm` to `gen_statem`. A generic state machine process (gen_statem) implemented using this module has a standard set of interface functions and includes functionality for tracing and error reporting. It also fits into an OTP supervision tree. For more information, see OTP Design Principles. A gen_statem assumes all specific parts to be located in a callback module exporting a predefined set of functions. The relationship between the behavior functions and the callback functions is as follows: gen_statem module Callback module ----------------- --------------- gen_statem:start gen_statem:start_link -----&gt; Module:init/1 Server start or code change -----&gt; Module:callback_mode/0 gen_statem:stop -----&gt; Module:terminate/3 gen_statem:call gen_statem:cast erlang:send erlang:&#39;!&#39; -----&gt; Module:StateName/3 Module:handle_event/4 - -----&gt; Module:terminate/3 - -----&gt; Module:code_change/4 Events are of different types, so the callback functions can know the origin of an event and how to respond. If a callback function fails or returns a bad value, the gen_statem terminates, unless otherwise stated. However, an exception of class throw is not regarded as an error but as a valid return from all callback functions. The state callback for a specific state in a gen_statem is the callback function that is called for all events in this state. It is selected depending on which callback mode that the callback module defines with the callback function Module:callback_mode/0. When the callback mode is state_functions, the state must be an atom and is used as the state callback name; see Module:StateName/3. This co-locates all code for a specific state in one function as the gen_statem engine branches depending on state name. Note the fact that the callback function Module:terminate/3 makes the state name terminate unusable in this mode. When the callback mode is handle_event_function, the state can be any term and the state callback name is Module:handle_event/4. This makes it easy to branch depending on state or event as you desire. Be careful about which events you handle in which states so that you do not accidentally postpone an event forever creating an infinite busy loop. When gen_statem receives a process message it is converted into an event and the state callback is called with the event as two arguments: type and content. When the state callback has processed the event it returns to gen_statem which does a state transition. If this state transition is to a different state, that is: NextState =/= State, it is a state change. The state callback may return transition actions for gen_statem to execute during the state transition, for example to reply to a gen_statem:call/2,3. One of the possible transition actions is to postpone the current event. Then it is not retried in the current state. The gen_statem engine keeps a queue of events divided into the postponed events and the events still to process. After a state change the queue restarts with the postponed events. The gen_statem event queue model is sufficient to emulate the normal process message queue with selective receive. Postponing an event corresponds to not matching it in a receive statement, and changing states corresponds to entering a new receive statement. The state callback can insert events using the transition actions next_event and such an event is inserted in the event queue as the next to call the state callback with. That is, as if it is the oldest incoming event. A dedicated event_type() internal can be used for such events making them impossible to mistake for external events. Inserting an event replaces the trick of calling your own state handling functions that you often would have to resort to in, for example, gen_fsm to force processing an inserted event before others. The gen_statem engine can automatically make a specialized call to the state callback whenever a new state is entered; see state_enter(). This is for writing code common to all state entries. Another way to do it is to explicitly insert an event at the state transition, and/or to use a dedicated state transition function, but that is something you will have to remember at every state transition to the state(s) that need it. If you in gen_statem, for example, postpone an event in one state and then call another state callback of yours, you have not done a state change and hence the postponed event is not retried, which is logical but can be confusing. For the details of a state transition, see type transition_option(). A gen_statem handles system messages as described in sys. The sys module can be used for debugging a gen_statem. Notice that a gen_statem does not trap exit signals automatically, this must be explicitly initiated in the callback module (by calling process_flag(trap_exit, true). Unless otherwise stated, all functions in this module fail if the specified gen_statem does not exist or if bad arguments are specified. The gen_statem process can go into hibernation; see proc_lib:hibernate/3. It is done when a state callback or Module:init/1 specifies hibernate in the returned Actions list. This feature can be useful to reclaim process heap memory while the server is expected to be idle for a long time. However, use this feature with care, as hibernation can be too costly to use after every event; see erlang:hibernate/3. There is also a server start option {hibernate_after, Timeout} for start/3,4, start_link/3,4 or enter_loop/4,5,6, that may be used to automatically hibernate the server."},{"ref":"gen_statem.html#callcall/23","title":"gen_statem.callcall/23","type":"function","doc":"Makes a synchronous call to the gen_statem ServerRef by sending a request and waiting until its reply arrives. The gen_statem calls the state callback with event_type() {call,From} and event content Request. A Reply is generated when a state callback returns with {reply,From,``Reply``} as one action(), and that Reply becomes the return value of this function. Timeout is an integer &gt; 0, which specifies how many milliseconds to wait for a reply, or the atom infinity to wait indefinitely, which is the default. If no reply is received within the specified time, the function call fails. For Timeout`` ``&lt; infinity, to avoid getting a late reply in the caller&#39;s inbox if the caller should catch exceptions, this function spawns a proxy process that does the call. A late reply gets delivered to the dead proxy process, hence gets discarded. This is less efficient than using Timeout`` == infinity. Timeout can also be a tuple {clean_timeout,``T``} or {dirty_timeout,``T``}, where T is the time-out time. {clean_timeout,``T``} works like just T described in the note above and uses a proxy process while {dirty_timeout,``T``} bypasses the proxy process which is more lightweight. If you combine catching exceptions from this function with {dirty_timeout,``T``} to avoid that the calling process dies when the call times out, you will have to be prepared to handle a late reply. Note that there is an odd chance to get a late reply even with {dirty_timeout,infinity} or infinity for example in the event of network problems. So why not just let the calling process die by not catching the exception? The call can also fail, for example, if the gen_statem dies before or during this function call."},{"ref":"gen_statem.html#cast/2","title":"gen_statem.cast/2","type":"function","doc":"Sends an asynchronous event to the gen_statem ServerRef and returns ok immediately, ignoring if the destination node or gen_statem does not exist. The gen_statem calls the state callback with event_type() cast and event content Msg."},{"ref":"gen_statem.html#enter_loop/4","title":"gen_statem.enter_loop/4","type":"function","doc":"The same as enter_loop/6 with Actions = [] except that no server_name() must have been registered. This creates an anonymous server."},{"ref":"gen_statem.html#enter_loop/5","title":"gen_statem.enter_loop/5","type":"function","doc":"If Server_or_Actions is a list(), the same as enter_loop/6 except that no server_name() must have been registered and Actions = ``Server_or_Actions. This creates an anonymous server. Otherwise the same as enter_loop/6 with Server = ``Server_or_Actions and Actions = []."},{"ref":"gen_statem.html#enter_loop/6","title":"gen_statem.enter_loop/6","type":"function","doc":"Makes the calling process become a gen_statem. Does not return, instead the calling process enters the gen_statem receive loop and becomes a gen_statem server. The process must have been started using one of the start functions in proc_lib. The user is responsible for any initialization of the process, including registering a name for it. This function is useful when a more complex initialization procedure is needed than the gen_statem behavior provides. Module, Opts have the same meaning as when calling start[_link]/3,4. If Server is self() an anonymous server is created just as when using start[_link]/3. If Server is a server_name() a named server is created just as when using start[_link]/4. However, the server_name() name must have been registered accordingly before this function is called. State, Data, and Actions have the same meanings as in the return value of Module:init/1. Also, the callback module does not need to export a Module:init/1 function. The function fails if the calling process was not started by a proc_lib start function, or if it is not registered according to server_name()."},{"ref":"gen_statem.html#replyreply/12","title":"gen_statem.replyreply/12","type":"function","doc":"This function can be used by a gen_statem to explicitly send a reply to a process that waits in call/2 when the reply cannot be defined in the return value of a state callback. From must be the term from argument {call,``From``} to the state callback. A reply or multiple replies canalso be sent using one or several reply_action()s from a state callback. A reply sent with this function is not visible in sys debug output."},{"ref":"gen_statem.html#start_linkstart_link/34","title":"gen_statem.start_linkstart_link/34","type":"function","doc":"Creates a gen_statem process according to OTP design principles (using proc_lib primitives) that is linked to the calling process. This is essential when the gen_statem must be part of a supervision tree so it gets linked to its supervisor. The gen_statem process calls Module:init/1 to initialize the server. To ensure a synchronized startup procedure, start_link/3,4 does not return until Module:init/1 has returned. ServerName specifies the server_name() to register for the gen_statem. If the gen_statem is started with start_link/3, no ServerName is provided and the gen_statem is not registered. Module is the name of the callback module. Args is an arbitrary term that is passed as the argument to Module:init/1. * If option `{timeout,Time}` is present in `Opts`, the `gen_statem` is allowed to spend [`Time`](https://hexdocs.pm/elixir/Time.html) milliseconds initializing or it terminates and the start function returns `{error,timeout}`. * If option `{hibernate_after,HibernateAfterTimeout}` is present, the `gen_statem` process awaits any message for `HibernateAfterTimeout` milliseconds and if no message is received, the process goes into hibernation automatically (by calling `proc_lib:hibernate/3`). * If option `{debug,Dbgs}` is present in `Opts`, debugging through `sys` is activated. * If option `{spawn_opt,SpawnOpts}` is present in `Opts`, `SpawnOpts` is passed as option list to `erlang:spawn_opt/2`, which is used to spawn the `gen_statem` process. Using spawn option `monitor` is not allowed, it causes this function to fail with reason `badarg`. If the gen_statem is successfully created and initialized, this function returns {ok,Pid}, where Pid is the pid() of the gen_statem. If a process with the specified ServerName exists already, this function returns {error,{already_started,Pid}}, where Pid is the pid() of that process. If Module:init/1 fails with Reason, this function returns {error,Reason}. If Module:init/1 returns {stop,Reason} or ignore, the process is terminated and this function returns {error,Reason} or ignore, respectively."},{"ref":"gen_statem.html#startstart/34","title":"gen_statem.startstart/34","type":"function","doc":"Creates a standalone gen_statem process according to OTP design principles (using proc_lib primitives). As it does not get linked to the calling process, this start function cannot be used by a supervisor to start a child. For a description of arguments and return values, see start_link/3,4."},{"ref":"gen_statem.html#stop/1","title":"gen_statem.stop/1","type":"function","doc":"The same as stop(``ServerRef``, normal, infinity)."},{"ref":"gen_statem.html#stop/3","title":"gen_statem.stop/3","type":"function","doc":"Orders the gen_statem ServerRef to exit with the specified Reason and waits for it to terminate. The gen_statem calls Module:terminate/3 before exiting. This function returns ok if the server terminates with the expected reason. Any other reason than normal, shutdown, or {shutdown,Term} causes an error report to be issued through logger(3). The default Reason is normal. Timeout is an integer &gt; 0, which specifies how many milliseconds to wait for the server to terminate, or the atom infinity to wait indefinitely. Defaults to infinity. If the server does not terminate within the specified time, a timeout exception is raised. If the process does not exist, a noproc exception is raised."},{"ref":"io.html","title":"io","type":"module","doc":"This module provides an interface to standard Erlang I/O servers. The output functions all return ok if they are successful, or exit if they are not. All functions in this module have an optional parameter IoDevice. If included, it must be the pid of a process that handles the I/O protocols. Normally, it is the IoDevice returned by file:open/2. For a description of the I/O protocols, see section The Erlang I/O Protocol in the User&#39;s Guide. As from Erlang/OTP R13A, data supplied to function put_chars/2 is to be in the unicode:chardata() format. This means that programs supplying binaries to this function must convert them to UTF-8 before trying to output the data on an I/O device. If an I/O device is set in binary mode, functions get_chars/2,3 and get_line/1,2 can return binaries instead of lists. The binaries are, as from Erlang/OTP R13A, encoded in UTF-8. To work with binaries in ISO Latin-1 encoding, use the file module instead. For conversion functions between character encodings, see the unicode module."},{"ref":"io.html#columnscolumns/1","title":"io.columnscolumns/1","type":"function","doc":"Retrieves the number of columns of the IoDevice (that is, the width of a terminal). The function succeeds for terminal devices and returns {error, enotsup} for all other I/O devices."},{"ref":"io.html#formatformatformatfwritefwritefwrite/123123","title":"io.formatformatformatfwritefwritefwrite/123123","type":"function","doc":"Writes the items in Data ([]) on the standard output (IoDevice) in accordance with Format. Format contains plain characters that are copied to the output device, and control sequences for formatting, see below. If Format is an atom or a binary, it is first converted to a list with the aid of atom_to_list/1 or binary_to_list/1. Example: 1&gt; io:fwrite(&quot;Hello world!~n&quot;, []). Hello world! ok The general format of a control sequence is ~F.P.PadModC. The character C determines the type of control sequence to be used. It is the only required field. All of F, P, Pad, and Mod are optional. For example, to use a # for Pad but use the default values for F and P, you can write ~..#C. * `F` is the `field width` of the printed argument. A negative value means that the argument is left-justified within the field, otherwise right-justified. If no field width is specified, the required print width is used. If the field width specified is too small, the whole field is filled with `*` characters. * `P` is the `precision` of the printed argument. A default value is used if no precision is specified. The interpretation of precision depends on the control sequences. Unless otherwise specified, argument `within` is used to determine print width. * `Pad` is the padding character. This is the character used to pad the printed representation of the argument so that it conforms to the specified field width and precision. Only one padding character can be specified and, whenever applicable, it is used for both the field width and precision. The default padding character is `&#39; &#39;` (space). * `Mod` is the control sequence modifier. This is one or more characters that change the interpretation of `Data`. The current modifiers are `t`, for Unicode translation, and `l`, for stopping `p` and `P` from detecting printable characters. If F, P, or Pad is a * character, the next argument in Data is used as the value. For example: 1&gt; io:fwrite(&quot;~*.*.0f~n&quot;,[9, 5, 3.14159265]). 003.14159 ok To use a literal * character as Pad, it must be passed as an argument: 2&gt; io:fwrite(&quot;~*.*.*f~n&quot;,[9, 5, $*, 3.14159265]). **3.14159 ok Available control sequences: ~ * Character ~ is written. c * The argument is a number that is interpreted as an ASCII code. The precision is the number of times the character is printed and defaults to the field width, which in turn defaults to 1. Example: 1&gt; io:fwrite(&quot;|~10.5c|~-10.5c|~5c|~n&quot;, [$a, $b, $c]). | aaaaa|bbbbb |ccccc| ok If the Unicode translation modifier (t) is in effect, the integer argument can be any number representing a valid Unicode codepoint, otherwise it is to be an integer less than or equal to 255, otherwise it is masked with 16#FF: 2&gt; io:fwrite(&quot;~tc~n&quot;,[1024]). \\x{400} ok 3&gt; io:fwrite(&quot;~c~n&quot;,[1024]). ^@ ok f * The argument is a float that is written as [-]ddd.ddd, where the precision is the number of digits after the decimal point. The default precision is 6 and it cannot be &lt; 1. e * The argument is a float that is written as [-]d.ddde+-ddd, where the precision is the number of digits written. The default precision is 6 and it cannot be &lt; 2. g * The argument is a float that is written as f, if it is &gt;= 0.1 and &lt; 10000.0. Otherwise, it is written in the e format. The precision is the number of significant digits. It defaults to 6 and is not to be &lt; 2. If the absolute value of the float does not allow it to be written in the f format with the desired number of significant digits, it is also written in the e format. s * Prints the argument with the string syntax. The argument is, if no Unicode translation modifier is present, an iolist(), a binary(), or an atom(). If the Unicode translation modifier (t) is in effect, the argument is unicode:chardata(), meaning that binaries are in UTF-8. The characters are printed without quotes. The string is first truncated by the specified precision and then padded and justified to the specified field width. The default precision is the field width. This format can be used for printing any object and truncating the output so it fits a specified field: 1&gt; io:fwrite(&quot;|~10w|~n&quot;, [{hey, hey, hey}]). |**********| ok 2&gt; io:fwrite(&quot;|~10s|~n&quot;, [io_lib:write({hey, hey, hey})]). |{hey,hey,h| 3&gt; io:fwrite(&quot;|~-10.8s|~n&quot;, [io_lib:write({hey, hey, hey})]). |{hey,hey | ok A list with integers &gt; 255 is considered an error if the Unicode translation modifier is not specified: 4&gt; io:fwrite(&quot;~ts~n&quot;,[[1024]]). \\x{400} ok 5&gt; io:fwrite(&quot;~s~n&quot;,[[1024]]). ** exception error: bad argument in function io:format/3 called as io:format(&lt;0.53.0&gt;,&quot;~s~n&quot;,[[1024]]) w * Writes data with the standard syntax. This is used to output Erlang terms. Atoms are printed within quotes if they contain embedded non-printable characters. Atom characters &gt; 255 are escaped unless the Unicode translation modifier (t) is used. Floats are printed accurately as the shortest, correctly rounded string. p * Writes the data with standard syntax in the same way as ~w, but breaks terms whose printed representation is longer than one line into many lines and indents each line sensibly. Left-justification is not supported. It also tries to detect flat lists of printable characters and output these as strings. For example: 1&gt; T = [{attributes,[[{id,age,1.50000},{mode,explicit}, {typename,&quot;INTEGER&quot;}], [{id,cho},{mode,explicit},{typename,&#39;Cho&#39;}]]}, {typename,&#39;Person&#39;},{tag,{&#39;PRIVATE&#39;,3}},{mode,implicit}]. ... 2&gt; io:fwrite(&quot;~w~n&quot;, [T]). [{attributes,[[{id,age,1.5},{mode,explicit},{typename, [73,78,84,69,71,69,82]}],[{id,cho},{mode,explicit},{typena me,&#39;Cho&#39;}]]},{typename,&#39;Person&#39;},{tag,{&#39;PRIVATE&#39;,3}},{mode ,implicit}] ok 3&gt; io:fwrite(&quot;~62p~n&quot;, [T]). [{attributes,[[{id,age,1.5}, {mode,explicit}, {typename,&quot;INTEGER&quot;}], [{id,cho},{mode,explicit},{typename,&#39;Cho&#39;}]]}, {typename,&#39;Person&#39;}, {tag,{&#39;PRIVATE&#39;,3}}, {mode,implicit}] ok The field width specifies the maximum line length. It defaults to 80. The precision specifies the initial indentation of the term. It defaults to the number of characters printed on this line in the same call to write/1 or format/1,2,3. For example, using T above: 4&gt; io:fwrite(&quot;Here T = ~62p~n&quot;, [T]). Here T = [{attributes,[[{id,age,1.5}, {mode,explicit}, {typename,&quot;INTEGER&quot;}], [{id,cho}, {mode,explicit}, {typename,&#39;Cho&#39;}]]}, {typename,&#39;Person&#39;}, {tag,{&#39;PRIVATE&#39;,3}}, {mode,implicit}] ok As from Erlang/OTP 21.0, a field width of value 0 can be used for specifying that a line is infinitely long, which means that no line breaks are inserted. For example: 5&gt; io:fwrite(&quot;~0p~n&quot;, [lists:seq(1, 30)]). [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30] ok When the modifier l is specified, no detection of printable character lists takes place, for example: 6&gt; S = [{a,&quot;a&quot;}, {b, &quot;b&quot;}], io:fwrite(&quot;~15p~n&quot;, [S]). [{a,&quot;a&quot;}, {b,&quot;b&quot;}] ok 7&gt; io:fwrite(&quot;~15lp~n&quot;, [S]). [{a,[97]}, {b,[98]}] ok The Unicode translation modifier t specifies how to treat characters outside the Latin-1 range of codepoints, in atoms, strings, and binaries. For example, printing an atom containing a character &gt; 255: 8&gt; io:fwrite(&quot;~p~n&quot;,[list_to_atom([1024])]). &#39;\\x{400}&#39; ok 9&gt; io:fwrite(&quot;~tp~n&quot;,[list_to_atom([1024])]). &#39;&#39; ok By default, Erlang only detects lists of characters in the Latin-1 range as strings, but the +pc unicode flag can be used to change this (see printable_range/0 for details). For example: 10&gt; io:fwrite(&quot;~p~n&quot;,[[214]]). &quot;&quot; ok 11&gt; io:fwrite(&quot;~p~n&quot;,[[1024]]). [1024] ok 12&gt; io:fwrite(&quot;~tp~n&quot;,[[1024]]). [1024] ok but if Erlang was started with +pc unicode: 13&gt; io:fwrite(&quot;~p~n&quot;,[[1024]]). [1024] ok 14&gt; io:fwrite(&quot;~tp~n&quot;,[[1024]]). &quot;&quot; ok Similarly, binaries that look like UTF-8 encoded strings are output with the binary string syntax if the t modifier is specified: 15&gt; io:fwrite(&quot;~p~n&quot;, [&lt;&lt;208,128&gt;&gt;]). &lt;&lt;208,128&gt;&gt; ok 16&gt; io:fwrite(&quot;~tp~n&quot;, [&lt;&lt;208,128&gt;&gt;]). &lt;&lt;&quot;&quot;/utf8&gt;&gt; ok 17&gt; io:fwrite(&quot;~tp~n&quot;, [&lt;&lt;128,128&gt;&gt;]). &lt;&lt;128,128&gt;&gt; ok W * Writes data in the same way as ~w, but takes an extra argument that is the maximum depth to which terms are printed. Anything below this depth is replaced with .... For example, using T above: 8&gt; io:fwrite(&quot;~W~n&quot;, [T,9]). [{attributes,[[{id,age,1.5},{mode,explicit},{typename,...}], [{id,cho},{mode,...},{...}]]},{typename,&#39;Person&#39;}, {tag,{&#39;PRIVATE&#39;,3}},{mode,implicit}] ok If the maximum depth is reached, it cannot be read in the resultant output. Also, the ,... form in a tuple denotes that there are more elements in the tuple but these are below the print depth. P * Writes data in the same way as ~p, but takes an extra argument that is the maximum depth to which terms are printed. Anything below this depth is replaced with ..., for example: 9&gt; io:fwrite(&quot;~62P~n&quot;, [T,9]). [{attributes,[[{id,age,1.5},{mode,explicit},{typename,...}], [{id,cho},{mode,...},{...}]]}, {typename,&#39;Person&#39;}, {tag,{&#39;PRIVATE&#39;,3}}, {mode,implicit}] ok B * Writes an integer in base 2-36, the default base is 10. A leading dash is printed for negative integers. The precision field selects base, for example: 1&gt; io:fwrite(&quot;~.16B~n&quot;, [31]). 1F ok 2&gt; io:fwrite(&quot;~.2B~n&quot;, [-19]). -10011 ok 3&gt; io:fwrite(&quot;~.36B~n&quot;, [5*36+35]). 5Z ok X * Like B, but takes an extra argument that is a prefix to insert before the number, but after the leading dash, if any. The prefix can be a possibly deep list of characters or an atom. Example: 1&gt; io:fwrite(&quot;~X~n&quot;, [31,&quot;10#&quot;]). 10#31 ok 2&gt; io:fwrite(&quot;~.16X~n&quot;, [-31,&quot;0x&quot;]). -0x1F ok # * Like B, but prints the number with an Erlang style #-separated base prefix. Example: 1&gt; io:fwrite(&quot;~.10#~n&quot;, [31]). 10#31 ok 2&gt; io:fwrite(&quot;~.16#~n&quot;, [-31]). -16#1F ok b * Like B, but prints lowercase letters. x * Like X, but prints lowercase letters. + * Like #, but prints lowercase letters. n * Writes a new line. i * Ignores the next term. The function returns: ok * The formatting succeeded. If an error occurs, there is no output. Example: 1&gt; io:fwrite(&quot;~s ~w ~i ~w ~c ~n&quot;,[&#39;abc def&#39;, &#39;abc def&#39;, {foo, 1},{foo, 1}, 65]). abc def &#39;abc def&#39; {foo,1} A ok 2&gt; io:fwrite(&quot;~s&quot;, [65]). ** exception error: bad argument in function io:format/3 called as io:format(&lt;0.53.0&gt;,&quot;~s&quot;,&quot;A&quot;) In this example, an attempt was made to output the single character 65 with the aid of the string formatting directive &quot;~s&quot;."},{"ref":"io.html#freadfread/23","title":"io.freadfread/23","type":"function","doc":"Reads characters from the standard input (IoDevice), prompting it with Prompt. Interprets the characters in accordance with Format. Format contains control sequences that directs the interpretation of the input. Format can contain the following: * Whitespace characters (Space, Tab, and Newline) that cause input to be read to the next non-whitespace character. * Ordinary characters that must match the next input character. * Control sequences, which have the general format `~*FMC`, where: * Character `*` is an optional return suppression character. It provides a method to specify a field that is to be omitted. * `F` is the `field width` of the input field. * `M` is an optional translation modifier (of which `t` is the only supported, meaning Unicode translation). * `C` determines the type of control sequence. Unless otherwise specified, leading whitespace is ignored for all control sequences. An input field cannot be more than one line wide. Available control sequences: ~ * A single ~ is expected in the input. d * A decimal integer is expected. u * An unsigned integer in base 2-36 is expected. The field width parameter is used to specify base. Leading whitespace characters are not skipped. - * An optional sign character is expected. A sign character - gives return value -1. Sign character + or none gives 1. The field width parameter is ignored. Leading whitespace characters are not skipped. # * An integer in base 2-36 with Erlang-style base prefix (for example, &quot;16#ffff&quot;) is expected. f * A floating point number is expected. It must follow the Erlang floating point number syntax. s * A string of non-whitespace characters is read. If a field width has been specified, this number of characters are read and all trailing whitespace characters are stripped. An Erlang string (list of characters) is returned. If Unicode translation is in effect (~ts), characters &gt; 255 are accepted, otherwise not. With the translation modifier, the returned list can as a consequence also contain integers &gt; 255: 1&gt; io:fread(&quot;Prompt&gt; &quot;,&quot;~s&quot;). Prompt&gt; &lt;Characters beyond latin1 range not printable in this medium&gt; {error,{fread,string}} 2&gt; io:fread(&quot;Prompt&gt; &quot;,&quot;~ts&quot;). Prompt&gt; &lt;Characters beyond latin1 range not printable in this medium&gt; {ok,[[1091,1085,1080,1094,1086,1076,1077]]} a * Similar to s, but the resulting string is converted into an atom. c * The number of characters equal to the field width are read (default is 1) and returned as an Erlang string. However, leading and trailing whitespace characters are not omitted as they are with s. All characters are returned. The Unicode translation modifier works as with s: 1&gt; io:fread(&quot;Prompt&gt; &quot;,&quot;~c&quot;). Prompt&gt; &lt;Character beyond latin1 range not printable in this medium&gt; {error,{fread,string}} 2&gt; io:fread(&quot;Prompt&gt; &quot;,&quot;~tc&quot;). Prompt&gt; &lt;Character beyond latin1 range not printable in this medium&gt; {ok,[[1091]]} l * Returns the number of characters that have been scanned up to that point, including whitespace characters. The function returns: {ok, ``Terms``} * The read was successful and Terms is the list of successfully matched and read items. eof * End of file was encountered. {error, ``FreadError``} * The reading failed and FreadError gives a hint about the error. {error, ``ErrorDescription``} * The read operation failed and parameter ErrorDescription gives a hint about the error. Examples: 20&gt; io:fread(&#39;enter&gt;&#39;, &quot;~f~f~f&quot;). enter&gt;1.9 35.5e3 15.0 {ok,[1.9,3.55e4,15.0]} 21&gt; io:fread(&#39;enter&gt;&#39;, &quot;~10f~d&quot;). enter&gt; 5.67899 {ok,[5.678,99]} 22&gt; io:fread(&#39;enter&gt;&#39;, &quot;:~10s:~10c:&quot;). enter&gt;: alan : joe : {ok, [&quot;alan&quot;, &quot; joe &quot;]}"},{"ref":"io.html#get_charsget_chars/23","title":"io.get_charsget_chars/23","type":"function","doc":"Reads Count characters from standard input (IoDevice), prompting it with Prompt. The function returns: Data * The input characters. If the I/O device supports Unicode, the data can represent codepoints &gt; 255 (the latin1 range). If the I/O server is set to deliver binaries, they are encoded in UTF-8 (regardless of whether the I/O device supports Unicode). eof * End of file was encountered. {error, ``ErrorDescription``} * Other (rare) error condition, such as {error, estale} if reading from an NFS file system."},{"ref":"io.html#get_lineget_line/12","title":"io.get_lineget_line/12","type":"function","doc":"Reads a line from the standard input (IoDevice), prompting it with Prompt. The function returns: Data * The characters in the line terminated by a line feed (or end of file). If the I/O device supports Unicode, the data can represent codepoints &gt; 255 (the latin1 range). If the I/O server is set to deliver binaries, they are encoded in UTF-8 (regardless of if the I/O device supports Unicode). eof * End of file was encountered. {error, ``ErrorDescription``} * Other (rare) error condition, such as {error, estale} if reading from an NFS file system."},{"ref":"io.html#getoptsgetopts/1","title":"io.getoptsgetopts/1","type":"function","doc":"Requests all available options and their current values for a specific I/O device, for example: 1&gt; {ok,F} = file:open(&quot;/dev/null&quot;,[read]). {ok,&lt;0.42.0&gt;} 2&gt; io:getopts(F). [{binary,false},{encoding,latin1}] Here the file I/O server returns all available options for a file, which are the expected ones, encoding and binary. However, the standard shell has some more options: 3&gt; io:getopts(). [{expand_fun,#Fun&lt;group.0.120017273&gt;}, {echo,true}, {binary,false}, {encoding,unicode}] This example is, as can be seen, run in an environment where the terminal supports Unicode input and output."},{"ref":"io.html#nlnl/1","title":"io.nlnl/1","type":"function","doc":"Writes new line to the standard output (IoDevice)."},{"ref":"io.html#parse_erl_exprsparse_erl_exprsparse_erl_exprsparse_erl_exprs/1234","title":"io.parse_erl_exprsparse_erl_exprsparse_erl_exprsparse_erl_exprs/1234","type":"function","doc":"Reads data from the standard input (IoDevice), prompting it with Prompt. Starts reading at location StartLocation (1). Argument Options is passed on as argument Options of function erl_scan:tokens/4. The data is tokenized and parsed as if it was a sequence of Erlang expressions until a final dot (.) is reached. The function returns: {ok, ExprList, EndLocation} * The parsing was successful. {eof, EndLocation} * End of file was encountered by the tokenizer. eof * End of file was encountered by the I/O server. {error, ErrorInfo, ErrorLocation} * An error occurred while tokenizing or parsing. {error, ``ErrorDescription``} * Other (rare) error condition, such as {error, estale} if reading from an NFS file system. Example: 25&gt; io:parse_erl_exprs(&#39;enter&gt;&#39;). enter&gt;abc(), &quot;hey&quot;. {ok, [{call,1,{atom,1,abc},[]},{string,1,&quot;hey&quot;}],2} 26&gt; io:parse_erl_exprs (&#39;enter&gt;&#39;). enter&gt;abc(&quot;hey&quot;. {error,{1,erl_parse,[&quot;syntax error before: &quot;,[&quot;&#39;.&#39;&quot;]]},2}"},{"ref":"io.html#parse_erl_formparse_erl_formparse_erl_formparse_erl_form/1234","title":"io.parse_erl_formparse_erl_formparse_erl_formparse_erl_form/1234","type":"function","doc":"Reads data from the standard input (IoDevice), prompting it with Prompt. Starts reading at location StartLocation (1). Argument Options is passed on as argument Options of function erl_scan:tokens/4. The data is tokenized and parsed as if it was an Erlang form (one of the valid Erlang expressions in an Erlang source file) until a final dot (.) is reached. The function returns: {ok, AbsForm, EndLocation} * The parsing was successful. {eof, EndLocation} * End of file was encountered by the tokenizer. eof * End of file was encountered by the I/O server. {error, ErrorInfo, ErrorLocation} * An error occurred while tokenizing or parsing. {error, ``ErrorDescription``} * Other (rare) error condition, such as {error, estale} if reading from an NFS file system."},{"ref":"io.html#printable_range/0","title":"io.printable_range/0","type":"function","doc":"Returns the user-requested range of printable Unicode characters. The user can request a range of characters that are to be considered printable in heuristic detection of strings by the shell and by the formatting functions. This is done by supplying +pc &lt;range&gt; when starting Erlang. The only valid values for &lt;range&gt; are latin1 and unicode. latin1 means that only code points &lt; 256 (except control characters, and so on) are considered printable. unicode means that all printable characters in all Unicode character ranges are considered printable by the I/O functions. By default, Erlang is started so that only the latin1 range of characters indicate that a list of integers is a string. The simplest way to use the setting is to call io_lib:printable_list/1, which uses the return value of this function to decide if a list is a string of printable characters. In a future release, this function may return more values and ranges. To avoid compatibility problems, it is recommended to use function io_lib:printable_list/1."},{"ref":"io.html#put_charsput_chars/12","title":"io.put_charsput_chars/12","type":"function","doc":"Writes the characters of CharData to the I/O server (IoDevice)."},{"ref":"io.html#readread/12","title":"io.readread/12","type":"function","doc":"Reads a term Term from the standard input (IoDevice), prompting it with Prompt. The function returns: {ok, ``Term``} * The parsing was successful. eof * End of file was encountered. {error, ``ErrorInfo``} * The parsing failed. {error, ``ErrorDescription``} * Other (rare) error condition, such as {error, estale} if reading from an NFS file system."},{"ref":"io.html#readread/34","title":"io.readread/34","type":"function","doc":"Reads a term Term from IoDevice, prompting it with Prompt. Reading starts at location StartLocation. Argument Options is passed on as argument Options of function erl_scan:tokens/4. The function returns: {ok, Term, ``EndLocation``} * The parsing was successful. {eof, ``EndLocation``} * End of file was encountered. {error, ``ErrorInfo``, ``ErrorLocation``} * The parsing failed. {error, ``ErrorDescription``} * Other (rare) error condition, such as {error, estale} if reading from an NFS file system."},{"ref":"io.html#rowsrows/1","title":"io.rowsrows/1","type":"function","doc":"Retrieves the number of rows of IoDevice (that is, the height of a terminal). The function only succeeds for terminal devices, for all other I/O devices the function returns {error, enotsup}."},{"ref":"io.html#scan_erl_exprsscan_erl_exprsscan_erl_exprsscan_erl_exprs/1234","title":"io.scan_erl_exprsscan_erl_exprsscan_erl_exprsscan_erl_exprs/1234","type":"function","doc":"Reads data from the standard input (IoDevice), prompting it with Prompt. Reading starts at location StartLocation (1). Argument Options is passed on as argument Options of function erl_scan:tokens/4. The data is tokenized as if it were a sequence of Erlang expressions until a final dot (.) is reached. This token is also returned. The function returns: {ok, Tokens, EndLocation} * The tokenization succeeded. {eof, EndLocation} * End of file was encountered by the tokenizer. eof * End of file was encountered by the I/O server. {error, ErrorInfo, ErrorLocation} * An error occurred while tokenizing. {error, ``ErrorDescription``} * Other (rare) error condition, such as {error, estale} if reading from an NFS file system. Example: 23&gt; io:scan_erl_exprs(&#39;enter&gt;&#39;). enter&gt;abc(), &quot;hey&quot;. {ok,[{atom,1,abc},{&#39;(&#39;,1},{&#39;)&#39;,1},{&#39;,&#39;,1},{string,1,&quot;hey&quot;},{dot,1}],2} 24&gt; io:scan_erl_exprs(&#39;enter&gt;&#39;). enter&gt;1.0er. {error,{1,erl_scan,{illegal,float}},2}"},{"ref":"io.html#scan_erl_formscan_erl_formscan_erl_formscan_erl_form/1234","title":"io.scan_erl_formscan_erl_formscan_erl_formscan_erl_form/1234","type":"function","doc":"Reads data from the standard input (IoDevice), prompting it with Prompt. Starts reading at location StartLocation (1). Argument Options is passed on as argument Options of function erl_scan:tokens/4. The data is tokenized as if it was an Erlang form (one of the valid Erlang expressions in an Erlang source file) until a final dot (.) is reached. This last token is also returned. The return values are the same as for scan_erl_exprs/1,2,3,4."},{"ref":"io.html#setoptssetopts/12","title":"io.setoptssetopts/12","type":"function","doc":"Set options for the standard I/O device (IoDevice). Possible options and values vary depending on the I/O device. For a list of supported options and their current values on a specific I/O device, use function getopts/1. The options and values supported by the OTP I/O devices are as follows: binary, list, or {binary, boolean()} * If set in binary mode (binary or {binary, true}), the I/O server sends binary data (encoded in UTF-8) as answers to the get_line, get_chars, and, if possible, get_until requests (for details, see section The Erlang I/O Protocol) in the User&#39;s Guide). The immediate effect is that get_chars/2,3 and get_line/1,2 return UTF-8 binaries instead of lists of characters for the affected I/O device. By default, all I/O devices in OTP are set in list mode. However, the I/O functions can handle any of these modes and so should other, user-written, modules behaving as clients to I/O servers. This option is supported by the standard shell (group.erl), the &#39;oldshell&#39; (user.erl), and the file I/O servers. {echo, boolean()} * Denotes if the terminal is to echo input. Only supported for the standard shell I/O server (group.erl) {expand_fun, expand_fun()} * Provides a function for tab-completion (expansion) like the Erlang shell. This function is called when the user presses the Tab key. The expansion is active when calling line-reading functions, such as get_line/1,2. The function is called with the current line, up to the cursor, as a reversed string. It is to return a three-tuple: {yes|no, string(), [string(), ...]}. The first element gives a beep if no, otherwise the expansion is silent; the second is a string that will be entered at the cursor position; the third is a list of possible expansions. If this list is not empty, it is printed and the current input line is written once again. Trivial example (beep on anything except empty line, which is expanded to &quot;quit&quot;): fun(&quot;&quot;) -&gt; {yes, &quot;quit&quot;, []}; (_) -&gt; {no, &quot;&quot;, [&quot;quit&quot;]} end This option is only supported by the standard shell (group.erl). {encoding, latin1 | unicode} * Specifies how characters are input or output from or to the I/O device, implying that, for example, a terminal is set to handle Unicode input and output or a file is set to handle UTF-8 data encoding. The option does not affect how data is returned from the I/O functions or how it is sent in the I/O protocol, it only affects how the I/O device is to handle Unicode characters to the &quot;physical&quot; device. The standard shell is set for unicode or latin1 encoding when the system is started. The encoding is set with the help of the LANG or LC_CTYPE environment variables on Unix-like system or by other means on other systems. So, the user can input Unicode characters and the I/O device is in {encoding, unicode} mode if the I/O device supports it. The mode can be changed, if the assumption of the runtime system is wrong, by setting this option. The I/O device used when Erlang is started with the &quot;-oldshell&quot; or &quot;-noshell&quot; flags is by default set to latin1 encoding, meaning that any characters &gt; codepoint 255 are escaped and that input is expected to be plain 8-bit ISO Latin-1. If the encoding is changed to Unicode, input and output from the standard file descriptors are in UTF-8 (regardless of operating system). Files can also be set in {encoding, unicode}, meaning that data is written and read as UTF-8. More encodings are possible for files, see below. {encoding, unicode | latin1} is supported by both the standard shell (group.erl including werl on Windows), the &#39;oldshell&#39; (user.erl), and the file I/O servers. `{encoding, utf8 | utf16 | utf32 | {utf16,big} | {utf16,little} | {utf32,big} | {utf32,little}}` * For disk files, the encoding can be set to various UTF variants. This has the effect that data is expected to be read as the specified encoding from the file, and the data is written in the specified encoding to the disk file. {encoding, utf8} has the same effect as {encoding, unicode} on files. The extended encodings are only supported on disk files (opened by function file:open/2)."},{"ref":"io.html#writewrite/12","title":"io.writewrite/12","type":"function","doc":"Writes term Term to the standard output (IoDevice)."},{"ref":"io_lib.html","title":"io_lib","type":"module","doc":"This module contains functions for converting to and from strings (lists of characters). They are used for implementing the functions in the io module. There is no guarantee that the character lists returned from some of the functions are flat, they can be deep lists. Function lists:flatten/1 can be used for flattening deep lists."},{"ref":"io_lib.html#build_text/1","title":"io_lib.build_text/1","type":"function","doc":"For details, see scan_format/2."},{"ref":"io_lib.html#char_list/1","title":"io_lib.char_list/1","type":"function","doc":"Returns true if Term is a flat list of characters in the Unicode range, otherwise false."},{"ref":"io_lib.html#deep_char_list/1","title":"io_lib.deep_char_list/1","type":"function","doc":"Returns true if Term is a, possibly deep, list of characters in the Unicode range, otherwise false."},{"ref":"io_lib.html#deep_latin1_char_list/1","title":"io_lib.deep_latin1_char_list/1","type":"function","doc":"Returns true if Term is a, possibly deep, list of characters in the ISO Latin-1 range, otherwise false."},{"ref":"io_lib.html#formatfwrite/22","title":"io_lib.formatfwrite/22","type":"function","doc":"Returns a character list that represents Data formatted in accordance with Format. For a detailed description of the available formatting options, see io:fwrite/1,2,3. If the format string or argument list contains an error, a fault is generated. If and only if the Unicode translation modifier is used in the format string (that is, ~ts or ~tc), the resulting list can contain characters beyond the ISO Latin-1 character range (that is, numbers &gt; 255). If so, the result is still an ordinary Erlang string(), and can well be used in any context where Unicode data is allowed."},{"ref":"io_lib.html#formatfwrite/33","title":"io_lib.formatfwrite/33","type":"function","doc":"Returns a character list that represents Data formatted in accordance with Format in the same way as fwrite/2 and format/2, but takes an extra argument, a list of options. Valid option: {chars_limit, ``CharsLimit``} * A soft limit on the number of characters returned. When the number of characters is reached, remaining structures are replaced by &quot;...&quot;. CharsLimit defaults to -1, which means no limit on the number of characters returned."},{"ref":"io_lib.html#fread/2","title":"io_lib.fread/2","type":"function","doc":"Tries to read String in accordance with the control sequences in Format. For a detailed description of the available formatting options, see io:fread/3. It is assumed that String contains whole lines. The function returns: {ok, ``InputList``, ``LeftOverChars``} * The string was read. InputList is the list of successfully matched and read items, and LeftOverChars are the input characters not used. {more, ``RestFormat``, ``Nchars``, ``InputStack``} * The string was read, but more input is needed to complete the original format string. RestFormat is the remaining format string, Nchars is the number of characters scanned, and InputStack is the reversed list of inputs matched up to that point. {error, ``What``} * The read operation failed and parameter What gives a hint about the error. Example: 3&gt; io_lib:fread(&quot;~f~f~f&quot;, &quot;15.6 17.3e-6 24.5&quot;). {ok,[15.6,1.73e-5,24.5],[]}"},{"ref":"io_lib.html#fread/3","title":"io_lib.fread/3","type":"function","doc":"This is the re-entrant formatted reader. The continuation of the first call to the functions must be []. For a complete description of how the re-entrant input scheme works, see Armstrong, Virding, Williams: &#39;Concurrent Programming in Erlang&#39;, Chapter 13. The function returns: {done, ``Result``, ``LeftOverChars``} * The input is complete. The result is one of the following: {ok, ``InputList``} * The string was read. InputList is the list of successfully matched and read items, and LeftOverChars are the remaining characters. eof * End of file was encountered. LeftOverChars are the input characters not used. {error, ``What``} * An error occurred and parameter What gives a hint about the error. `{more, ``Continuation``}` * More data is required to build a term. `Continuation` must be passed to [`fread/3`](#fread/3) when more data becomes available."},{"ref":"io_lib.html#indentation/2","title":"io_lib.indentation/2","type":"function","doc":"Returns the indentation if String has been printed, starting at StartIndent."},{"ref":"io_lib.html#latin1_char_list/1","title":"io_lib.latin1_char_list/1","type":"function","doc":"Returns true if Term is a flat list of characters in the ISO Latin-1 range, otherwise false."},{"ref":"io_lib.html#nl/0","title":"io_lib.nl/0","type":"function","doc":"Returns a character list that represents a new line character."},{"ref":"io_lib.html#printable_latin1_list/1","title":"io_lib.printable_latin1_list/1","type":"function","doc":"Returns true if Term is a flat list of printable ISO Latin-1 characters, otherwise false."},{"ref":"io_lib.html#printable_list/1","title":"io_lib.printable_list/1","type":"function","doc":"Returns true if Term is a flat list of printable characters, otherwise false. What is a printable character in this case is determined by startup flag +pc to the Erlang VM; see io:printable_range/0 and erl(1)."},{"ref":"io_lib.html#printable_unicode_list/1","title":"io_lib.printable_unicode_list/1","type":"function","doc":"Returns true if Term is a flat list of printable Unicode characters, otherwise false."},{"ref":"io_lib.html#printprint/14","title":"io_lib.printprint/14","type":"function","doc":"Returns a list of characters that represents Term, but breaks representations longer than one line into many lines and indents each line sensibly. Also tries to detect and output lists of printable characters as strings. * `Column` is the starting column; defaults to 1. * `LineLength` is the maximum line length; defaults to 80. * `Depth` is the maximum print depth; defaults to -1, which means no limitation."},{"ref":"io_lib.html#scan_format/2","title":"io_lib.scan_format/2","type":"function","doc":"Returns a list corresponding to the specified format string, where control sequences have been replaced with corresponding tuples. This list can be passed to: * [`build_text/1`](#build_text/1) to have the same effect as `format(Format, Args)` * [`unscan_format/1`](#unscan_format/1) to get the corresponding pair of `Format` and `Args` (with every `*` and corresponding argument expanded to numeric values) A typical use of this function is to replace unbounded-size control sequences like ~w and ~p with the depth-limited variants ~W and ~P before formatting to text in, for example, a logger."},{"ref":"io_lib.html#unscan_format/1","title":"io_lib.unscan_format/1","type":"function","doc":"For details, see scan_format/2."},{"ref":"io_lib.html#write_atom/1","title":"io_lib.write_atom/1","type":"function","doc":"Returns the list of characters needed to print atom Atom."},{"ref":"io_lib.html#write_atom_as_latin1/1","title":"io_lib.write_atom_as_latin1/1","type":"function","doc":"Returns the list of characters needed to print atom Atom. Non-Latin-1 characters are escaped."},{"ref":"io_lib.html#write_char/1","title":"io_lib.write_char/1","type":"function","doc":"Returns the list of characters needed to print a character constant in the Unicode character set."},{"ref":"io_lib.html#write_char_as_latin1/1","title":"io_lib.write_char_as_latin1/1","type":"function","doc":"Returns the list of characters needed to print a character constant in the Unicode character set. Non-Latin-1 characters are escaped."},{"ref":"io_lib.html#write_latin1_char/1","title":"io_lib.write_latin1_char/1","type":"function","doc":"Returns the list of characters needed to print a character constant in the ISO Latin-1 character set."},{"ref":"io_lib.html#write_latin1_string/1","title":"io_lib.write_latin1_string/1","type":"function","doc":"Returns the list of characters needed to print Latin1String as a string."},{"ref":"io_lib.html#write_string/1","title":"io_lib.write_string/1","type":"function","doc":"Returns the list of characters needed to print String as a string."},{"ref":"io_lib.html#write_string_as_latin1/1","title":"io_lib.write_string_as_latin1/1","type":"function","doc":"Returns the list of characters needed to print String as a string. Non-Latin-1 characters are escaped."},{"ref":"io_lib.html#writewritewrite/122","title":"io_lib.writewritewrite/122","type":"function","doc":"Returns a character list that represents Term. Option Depth controls the depth of the structures written. When the specified depth is reached, everything below this level is replaced by &quot;...&quot;. Depth defaults to -1, which means no limitation. Option CharsLimit puts a soft limit on the number of characters returned. When the number of characters is reached, remaining structures are replaced by &quot;...&quot;. CharsLimit defaults to -1, which means no limit on the number of characters returned. Example: 1&gt; lists:flatten(io_lib:write({1,[2],[3],[4,5],6,7,8,9})). &quot;{1,[2],[3],[4,5],6,7,8,9}&quot; 2&gt; lists:flatten(io_lib:write({1,[2],[3],[4,5],6,7,8,9}, 5)). &quot;{1,[2],[3],[...],...}&quot; 3&gt; lists:flatten(io_lib:write({[1,2,3],[4,5],6,7,8,9}, [{chars_limit,20}])). &quot;{[1,2|...],[4|...],...}&quot;"},{"ref":"lists.html","title":"lists","type":"module","doc":"This module contains functions for list processing. Unless otherwise stated, all functions assume that position numbering starts at 1. That is, the first element of a list is at position 1. Two terms T1 and T2 compare equal if T1==T2 evaluates to true. They match if T1=:=T2 evaluates to true. Whenever an ordering function F is expected as argument, it is assumed that the following properties hold of F for all x, y, and z: * If x `F` y and y `F` x, then x = y (`F` is antisymmetric). * If x `F` y and y `F` z, then x `F` z (`F` is transitive). * x `F` y or y `F` x (`F` is total). An example of a typical ordering function is less than or equal to: =&lt;/2."},{"ref":"lists.html#all/2","title":"lists.all/2","type":"function","doc":"Returns true if Pred``(``Elem``) returns true for all elements Elem in List, otherwise false."},{"ref":"lists.html#any/2","title":"lists.any/2","type":"function","doc":"Returns true if Pred``(``Elem``) returns true for at least one element Elem in List."},{"ref":"lists.html#append/1","title":"lists.append/1","type":"function","doc":"Returns a list in which all the sublists of ListOfLists have been appended. Example: &gt; lists:append([[1, 2, 3], [a, b], [4, 5, 6]]). [1,2,3,a,b,4,5,6]"},{"ref":"lists.html#append/2","title":"lists.append/2","type":"function","doc":"Returns a new list List3, which is made from the elements of List1 followed by the elements of List2. Example: &gt; lists:append(&quot;abc&quot;, &quot;def&quot;). &quot;abcdef&quot; lists:append(A, B) is equivalent to A ++ B."},{"ref":"lists.html#concat/1","title":"lists.concat/1","type":"function","doc":"Concatenates the text representation of the elements of Things. The elements of Things can be atoms, integers, floats, or strings. Example: &gt; lists:concat([doc, &#39;/&#39;, file, &#39;.&#39;, 3]). &quot;doc/file.3&quot;"},{"ref":"lists.html#delete/2","title":"lists.delete/2","type":"function","doc":"Returns a copy of List1 where the first element matching Elem is deleted, if there is such an element."},{"ref":"lists.html#droplast/1","title":"lists.droplast/1","type":"function","doc":"Drops the last element of a List. The list is to be non-empty, otherwise the function crashes with a function_clause."},{"ref":"lists.html#dropwhile/2","title":"lists.dropwhile/2","type":"function","doc":"Drops elements Elem from List1 while Pred``(``Elem``) returns true and returns the remaining list."},{"ref":"lists.html#duplicate/2","title":"lists.duplicate/2","type":"function","doc":"Returns a list containing N copies of term Elem. Example: &gt; lists:duplicate(5, xx). [xx,xx,xx,xx,xx]"},{"ref":"lists.html#filter/2","title":"lists.filter/2","type":"function","doc":"List2 is a list of all elements Elem in List1 for which Pred``(``Elem``) returns true."},{"ref":"lists.html#filtermap/2","title":"lists.filtermap/2","type":"function","doc":"Calls Fun``(``Elem``) on successive elements Elem of List1. Fun``/1 must return either a Boolean or a tuple {true, ``Value``}. The function returns the list of elements for which Fun returns a new value, where a value of true is synonymous with {true, ``Elem``}. That is, filtermap behaves as if it had been defined as follows: filtermap(Fun, List1) -&gt; lists:foldr(fun(Elem, Acc) -&gt; case Fun(Elem) of false -&gt; Acc; true -&gt; [Elem|Acc]; {true,Value} -&gt; [Value|Acc] end end, [], List1). Example: &gt; lists:filtermap(fun(X) -&gt; case X rem 2 of 0 -&gt; {true, X div 2}; _ -&gt; false end end, [1,2,3,4,5]). [1,2]"},{"ref":"lists.html#flatlength/1","title":"lists.flatlength/1","type":"function","doc":"Equivalent to length(flatten(``DeepList``)), but more efficient."},{"ref":"lists.html#flatmap/2","title":"lists.flatmap/2","type":"function","doc":"Takes a function from As to lists of Bs, and a list of As (List1) and produces a list of Bs by applying the function to every element in List1 and appending the resulting lists. That is, flatmap behaves as if it had been defined as follows: flatmap(Fun, List1) -&gt; append(map(Fun, List1)). Example: &gt; lists:flatmap(fun(X)-&gt;[X,X] end, [a,b,c]). [a,a,b,b,c,c]"},{"ref":"lists.html#flatten/1","title":"lists.flatten/1","type":"function","doc":"Returns a flattened version of DeepList."},{"ref":"lists.html#flatten/2","title":"lists.flatten/2","type":"function","doc":"Returns a flattened version of DeepList with tail Tail appended."},{"ref":"lists.html#foldl/3","title":"lists.foldl/3","type":"function","doc":"Calls Fun``(``Elem``, ``AccIn``) on successive elements A of List, starting with AccIn`` == ``Acc0. Fun``/2 must return a new accumulator, which is passed to the next call. The function returns the final value of the accumulator. Acc0 is returned if the list is empty. Example: &gt; lists:foldl(fun(X, Sum) -&gt; X + Sum end, 0, [1,2,3,4,5]). 15 &gt; lists:foldl(fun(X, Prod) -&gt; X * Prod end, 1, [1,2,3,4,5]). 120"},{"ref":"lists.html#foldr/3","title":"lists.foldr/3","type":"function","doc":"Like foldl/3, but the list is traversed from right to left. Example: &gt; P = fun(A, AccIn) -&gt; io:format(&quot;~p &quot;, [A]), AccIn end. #Fun&lt;erl_eval.12.2225172&gt; &gt; lists:foldl(P, void, [1,2,3]). 1 2 3 void &gt; lists:foldr(P, void, [1,2,3]). 3 2 1 void foldl/3 is tail recursive and is usually preferred to foldr/3."},{"ref":"lists.html#foreach/2","title":"lists.foreach/2","type":"function","doc":"Calls Fun``(``Elem``) for each element Elem in List. This function is used for its side effects and the evaluation order is defined to be the same as the order of the elements in the list."},{"ref":"lists.html#join/2","title":"lists.join/2","type":"function","doc":"Inserts Sep between each element in List1. Has no effect on the empty list and on a singleton list. For example: &gt; lists:join(x, [a,b,c]). [a,x,b,x,c] &gt; lists:join(x, [a]). [a] &gt; lists:join(x, []). []"},{"ref":"lists.html#keydelete/3","title":"lists.keydelete/3","type":"function","doc":"Returns a copy of TupleList1 where the first occurrence of a tuple whose Nth element compares equal to Key is deleted, if there is such a tuple."},{"ref":"lists.html#keyfind/3","title":"lists.keyfind/3","type":"function","doc":"Searches the list of tuples TupleList for a tuple whose Nth element compares equal to Key. Returns Tuple if such a tuple is found, otherwise false."},{"ref":"lists.html#keymap/3","title":"lists.keymap/3","type":"function","doc":"Returns a list of tuples where, for each tuple in TupleList1, the Nth element Term1 of the tuple has been replaced with the result of calling Fun``(``Term1``). Examples: &gt; Fun = fun(Atom) -&gt; atom_to_list(Atom) end. #Fun&lt;erl_eval.6.10732646&gt; 2&gt; lists:keymap(Fun, 2, [{name,jane,22},{name,lizzie,20},{name,lydia,15}]). [{name,&quot;jane&quot;,22},{name,&quot;lizzie&quot;,20},{name,&quot;lydia&quot;,15}]"},{"ref":"lists.html#keymember/3","title":"lists.keymember/3","type":"function","doc":"Returns true if there is a tuple in TupleList whose Nth element compares equal to Key, otherwise false."},{"ref":"lists.html#keymerge/3","title":"lists.keymerge/3","type":"function","doc":"Returns the sorted list formed by merging TupleList1 and TupleList2. The merge is performed on the Nth element of each tuple. Both TupleList1 and TupleList2 must be key-sorted before evaluating this function. When two tuples compare equal, the tuple from TupleList1 is picked before the tuple from TupleList2."},{"ref":"lists.html#keyreplace/4","title":"lists.keyreplace/4","type":"function","doc":"Returns a copy of TupleList1 where the first occurrence of a T tuple whose Nth element compares equal to Key is replaced with NewTuple, if there is such a tuple T."},{"ref":"lists.html#keysearch/3","title":"lists.keysearch/3","type":"function","doc":"Searches the list of tuples TupleList for a tuple whose Nth element compares equal to Key. Returns {value, ``Tuple``} if such a tuple is found, otherwise false. This function is retained for backward compatibility. Function keyfind/3 is usually more convenient."},{"ref":"lists.html#keysort/2","title":"lists.keysort/2","type":"function","doc":"Returns a list containing the sorted elements of list TupleList1. Sorting is performed on the Nth element of the tuples. The sort is stable."},{"ref":"lists.html#keystore/4","title":"lists.keystore/4","type":"function","doc":"Returns a copy of TupleList1 where the first occurrence of a tuple T whose Nth element compares equal to Key is replaced with NewTuple, if there is such a tuple T. If there is no such tuple T, a copy of TupleList1 where [NewTuple] has been appended to the end is returned."},{"ref":"lists.html#keytake/3","title":"lists.keytake/3","type":"function","doc":"Searches the list of tuples TupleList1 for a tuple whose Nth element compares equal to Key. Returns {value, ``Tuple``, ``TupleList2``} if such a tuple is found, otherwise false. TupleList2 is a copy of TupleList1 where the first occurrence of Tuple has been removed."},{"ref":"lists.html#last/1","title":"lists.last/1","type":"function","doc":"Returns the last element in List."},{"ref":"lists.html#map/2","title":"lists.map/2","type":"function","doc":"Takes a function from As to Bs, and a list of As and produces a list of Bs by applying the function to every element in the list. This function is used to obtain the return values. The evaluation order depends on the implementation."},{"ref":"lists.html#mapfoldl/3","title":"lists.mapfoldl/3","type":"function","doc":"Combines the operations of map/2 and foldl/3 into one pass. Example: Summing the elements in a list and double them at the same time: &gt; lists:mapfoldl(fun(X, Sum) -&gt; {2*X, X+Sum} end, 0, [1,2,3,4,5]). {[2,4,6,8,10],15}"},{"ref":"lists.html#mapfoldr/3","title":"lists.mapfoldr/3","type":"function","doc":"Combines the operations of map/2 and foldr/3 into one pass."},{"ref":"lists.html#max/1","title":"lists.max/1","type":"function","doc":"Returns the first element of List that compares greater than or equal to all other elements of List."},{"ref":"lists.html#member/2","title":"lists.member/2","type":"function","doc":"Returns true if Elem matches some element of List, otherwise false."},{"ref":"lists.html#merge/1","title":"lists.merge/1","type":"function","doc":"Returns the sorted list formed by merging all the sublists of ListOfLists. All sublists must be sorted before evaluating this function. When two elements compare equal, the element from the sublist with the lowest position in ListOfLists is picked before the other element."},{"ref":"lists.html#merge/2","title":"lists.merge/2","type":"function","doc":"Returns the sorted list formed by merging List1 and List2. Both List1 and List2 must be sorted before evaluating this function. When two elements compare equal, the element from List1 is picked before the element from List2."},{"ref":"lists.html#merge/3","title":"lists.merge/3","type":"function","doc":"Returns the sorted list formed by merging List1 and List2. Both List1 and List2 must be sorted according to the ordering function Fun before evaluating this function. Fun``(``A``, ``B``) is to return true if A compares less than or equal to B in the ordering, otherwise false. When two elements compare equal, the element from List1 is picked before the element from List2."},{"ref":"lists.html#merge3/3","title":"lists.merge3/3","type":"function","doc":"Returns the sorted list formed by merging List1, List2, and List3. All of List1, List2, and List3 must be sorted before evaluating this function. When two elements compare equal, the element from List1, if there is such an element, is picked before the other element, otherwise the element from List2 is picked before the element from List3."},{"ref":"lists.html#min/1","title":"lists.min/1","type":"function","doc":"Returns the first element of List that compares less than or equal to all other elements of List."},{"ref":"lists.html#nth/2","title":"lists.nth/2","type":"function","doc":"Returns the Nth element of List. Example: &gt; lists:nth(3, [a, b, c, d, e]). c"},{"ref":"lists.html#nthtail/2","title":"lists.nthtail/2","type":"function","doc":"Returns the Nth tail of List, that is, the sublist of List starting at N``+1 and continuing up to the end of the list. Example &gt; lists:nthtail(3, [a, b, c, d, e]). [d,e] &gt; tl(tl(tl([a, b, c, d, e]))). [d,e] &gt; lists:nthtail(0, [a, b, c, d, e]). [a,b,c,d,e] &gt; lists:nthtail(5, [a, b, c, d, e]). []"},{"ref":"lists.html#partition/2","title":"lists.partition/2","type":"function","doc":"Partitions List into two lists, where the first list contains all elements for which Pred``(``Elem``) returns true, and the second list contains all elements for which Pred``(``Elem``) returns false. Examples: &gt; lists:partition(fun(A) -&gt; A rem 2 == 1 end, [1,2,3,4,5,6,7]). {[1,3,5,7],[2,4,6]} &gt; lists:partition(fun(A) -&gt; is_atom(A) end, [a,b,1,c,d,2,3,4,e]). {[a,b,c,d,e],[1,2,3,4]} For a different way to partition a list, see splitwith/2."},{"ref":"lists.html#prefix/2","title":"lists.prefix/2","type":"function","doc":"Returns true if List1 is a prefix of List2, otherwise false."},{"ref":"lists.html#reverse/1","title":"lists.reverse/1","type":"function","doc":"Returns a list with the elements in List1 in reverse order."},{"ref":"lists.html#reverse/2","title":"lists.reverse/2","type":"function","doc":"Returns a list with the elements in List1 in reverse order, with tail Tail appended. Example: &gt; lists:reverse([1, 2, 3, 4], [a, b, c]). [4,3,2,1,a,b,c]"},{"ref":"lists.html#search/2","title":"lists.search/2","type":"function","doc":"If there is a Value in List such that Pred``(``Value``) returns true, returns {value, ``Value``} for the first such Value, otherwise returns false."},{"ref":"lists.html#seqseq/23","title":"lists.seqseq/23","type":"function","doc":"Returns a sequence of integers that starts with From and contains the successive results of adding Incr to the previous element, until To is reached or passed (in the latter case, To is not an element of the sequence). Incr defaults to 1. Failures: * If `To`` ``&lt; ``From`` - ``Incr` and `Incr`` ``&gt; 0`. * If `To`` ``&gt; ``From`` - ``Incr` and `Incr`` ``&lt; 0`. * If `Incr`` =:= 0` and `From`` =/= ``To`. The following equalities hold for all sequences: length(lists:seq(From, To)) =:= To - From + 1 length(lists:seq(From, To, Incr)) =:= (To - From + Incr) div Incr Examples: &gt; lists:seq(1, 10). [1,2,3,4,5,6,7,8,9,10] &gt; lists:seq(1, 20, 3). [1,4,7,10,13,16,19] &gt; lists:seq(1, 0, 1). [] &gt; lists:seq(10, 6, 4). [] &gt; lists:seq(1, 1, 0). [1]"},{"ref":"lists.html#sort/1","title":"lists.sort/1","type":"function","doc":"Returns a list containing the sorted elements of List1."},{"ref":"lists.html#sort/2","title":"lists.sort/2","type":"function","doc":"Returns a list containing the sorted elements of List1, according to the ordering function Fun. Fun``(``A``, ``B``) is to return true if A compares less than or equal to B in the ordering, otherwise false."},{"ref":"lists.html#split/2","title":"lists.split/2","type":"function","doc":"Splits List1 into List2 and List3. List2 contains the first N elements and List3 the remaining elements (the Nth tail)."},{"ref":"lists.html#splitwith/2","title":"lists.splitwith/2","type":"function","doc":"Partitions List into two lists according to Pred. splitwith/2 behaves as if it is defined as follows: splitwith(Pred, List) -&gt; {takewhile(Pred, List), dropwhile(Pred, List)}. Examples: &gt; lists:splitwith(fun(A) -&gt; A rem 2 == 1 end, [1,2,3,4,5,6,7]). {[1],[2,3,4,5,6,7]} &gt; lists:splitwith(fun(A) -&gt; is_atom(A) end, [a,b,1,c,d,2,3,4,e]). {[a,b],[1,c,d,2,3,4,e]} For a different way to partition a list, see partition/2."},{"ref":"lists.html#sublist/2","title":"lists.sublist/2","type":"function","doc":"Returns the sublist of List1 starting at position 1 and with (maximum) Len elements. It is not an error for Len to exceed the length of the list, in that case the whole list is returned."},{"ref":"lists.html#sublist/3","title":"lists.sublist/3","type":"function","doc":"Returns the sublist of List1 starting at Start and with (maximum) Len elements. It is not an error for Start``+``Len to exceed the length of the list. Examples: &gt; lists:sublist([1,2,3,4], 2, 2). [2,3] &gt; lists:sublist([1,2,3,4], 2, 5). [2,3,4] &gt; lists:sublist([1,2,3,4], 5, 2). []"},{"ref":"lists.html#subtract/2","title":"lists.subtract/2","type":"function","doc":"Returns a new list List3 that is a copy of List1, subjected to the following procedure: for each element in List2, its first occurrence in List1 is deleted. Example: &gt; lists:subtract(&quot;123212&quot;, &quot;212&quot;). &quot;312&quot;. lists:subtract(A, B) is equivalent to A -- B."},{"ref":"lists.html#suffix/2","title":"lists.suffix/2","type":"function","doc":"Returns true if List1 is a suffix of List2, otherwise false."},{"ref":"lists.html#sum/1","title":"lists.sum/1","type":"function","doc":"Returns the sum of the elements in List."},{"ref":"lists.html#takewhile/2","title":"lists.takewhile/2","type":"function","doc":"Takes elements Elem from List1 while Pred``(``Elem``) returns true, that is, the function returns the longest prefix of the list for which all elements satisfy the predicate."},{"ref":"lists.html#ukeymerge/3","title":"lists.ukeymerge/3","type":"function","doc":"Returns the sorted list formed by merging TupleList1 and TupleList2. The merge is performed on the Nth element of each tuple. Both TupleList1 and TupleList2 must be key-sorted without duplicates before evaluating this function. When two tuples compare equal, the tuple from TupleList1 is picked and the one from TupleList2 is deleted."},{"ref":"lists.html#ukeysort/2","title":"lists.ukeysort/2","type":"function","doc":"Returns a list containing the sorted elements of list TupleList1 where all except the first tuple of the tuples comparing equal have been deleted. Sorting is performed on the Nth element of the tuples."},{"ref":"lists.html#umerge/1","title":"lists.umerge/1","type":"function","doc":"Returns the sorted list formed by merging all the sublists of ListOfLists. All sublists must be sorted and contain no duplicates before evaluating this function. When two elements compare equal, the element from the sublist with the lowest position in ListOfLists is picked and the other is deleted."},{"ref":"lists.html#umerge/2","title":"lists.umerge/2","type":"function","doc":"Returns the sorted list formed by merging List1 and List2. Both List1 and List2 must be sorted and contain no duplicates before evaluating this function. When two elements compare equal, the element from List1 is picked and the one from List2 is deleted."},{"ref":"lists.html#umerge/3","title":"lists.umerge/3","type":"function","doc":"Returns the sorted list formed by merging List1 and List2. Both List1 and List2 must be sorted according to the ordering function Fun and contain no duplicates before evaluating this function. Fun``(``A``, ``B``) is to return true if A compares less than or equal to B in the ordering, otherwise false. When two elements compare equal, the element from List1 is picked and the one from List2 is deleted."},{"ref":"lists.html#umerge3/3","title":"lists.umerge3/3","type":"function","doc":"Returns the sorted list formed by merging List1, List2, and List3. All of List1, List2, and List3 must be sorted and contain no duplicates before evaluating this function. When two elements compare equal, the element from List1 is picked if there is such an element, otherwise the element from List2 is picked, and the other is deleted."},{"ref":"lists.html#unzip/1","title":"lists.unzip/1","type":"function","doc":"&quot;Unzips&quot; a list of two-tuples into two lists, where the first list contains the first element of each tuple, and the second list contains the second element of each tuple."},{"ref":"lists.html#unzip3/1","title":"lists.unzip3/1","type":"function","doc":"&quot;Unzips&quot; a list of three-tuples into three lists, where the first list contains the first element of each tuple, the second list contains the second element of each tuple, and the third list contains the third element of each tuple."},{"ref":"lists.html#usort/1","title":"lists.usort/1","type":"function","doc":"Returns a list containing the sorted elements of List1 where all except the first element of the elements comparing equal have been deleted."},{"ref":"lists.html#usort/2","title":"lists.usort/2","type":"function","doc":"Returns a list containing the sorted elements of List1 where all except the first element of the elements comparing equal according to the ordering function Fun have been deleted. Fun``(A, B) is to return true if A compares less than or equal to B in the ordering, otherwise false."},{"ref":"lists.html#zip/2","title":"lists.zip/2","type":"function","doc":"&quot;Zips&quot; two lists of equal length into one list of two-tuples, where the first element of each tuple is taken from the first list and the second element is taken from the corresponding element in the second list."},{"ref":"lists.html#zip3/3","title":"lists.zip3/3","type":"function","doc":"&quot;Zips&quot; three lists of equal length into one list of three-tuples, where the first element of each tuple is taken from the first list, the second element is taken from the corresponding element in the second list, and the third element is taken from the corresponding element in the third list."},{"ref":"lists.html#zipwith/3","title":"lists.zipwith/3","type":"function","doc":"Combines the elements of two lists of equal length into one list. For each pair X``, ``Y of list elements from the two lists, the element in the result list is Combine``(``X``, ``Y``). zipwith(fun(X, Y) -&gt; {X,Y} end, List1, List2) is equivalent to zip(List1, List2). Example: &gt; lists:zipwith(fun(X, Y) -&gt; X+Y end, [1,2,3], [4,5,6]). [5,7,9]"},{"ref":"lists.html#zipwith3/4","title":"lists.zipwith3/4","type":"function","doc":"Combines the elements of three lists of equal length into one list. For each triple X``, ``Y``, ``Z of list elements from the three lists, the element in the result list is Combine``(``X``, ``Y``, ``Z``). zipwith3(fun(X, Y, Z) -&gt; {X,Y,Z} end, List1, List2, List3) is equivalent to zip3(List1, List2, List3). Examples: &gt; lists:zipwith3(fun(X, Y, Z) -&gt; X+Y+Z end, [1,2,3], [4,5,6], [7,8,9]). [12,15,18] &gt; lists:zipwith3(fun(X, Y, Z) -&gt; [X,Y,Z] end, [a,b,c], [x,y,z], [1,2,3]). [[a,x,1],[b,y,2],[c,z,3]]"},{"ref":"log_mf_h.html","title":"log_mf_h","type":"module","doc":"This module is a gen_event handler module that can be installed in any gen_event process. It logs onto disk all events that are sent to an event manager. Each event is written as a binary, which makes the logging very fast. However, a tool such as the Report Browser (rb(3)) must be used to read the files. The events are written to multiple files. When all files have been used, the first one is reused and overwritten. The directory location, the number of files, and the size of each file are configurable. The directory will include one file called index, and report files 1, 2, ...."},{"ref":"log_mf_h.html#initinit/34","title":"log_mf_h.initinit/34","type":"function","doc":"Initiates the event handler. Returns Args, which is to be used in a call to gen_event:add_handler(EventMgr, log_mf_h, ``Args``). Dir specifies which directory to use for the log files. MaxBytes specifies the size of each individual file. MaxFiles specifies how many files are used. Pred is a predicate function used to filter the events. If no predicate function is specified, all events are logged."},{"ref":"maps.html","title":"maps","type":"module","doc":"This module contains functions for maps processing."},{"ref":"maps.html#filter/2","title":"maps.filter/2","type":"function","doc":"Returns a map Map for which predicate Pred holds true in MapOrIter. The call fails with a {badmap,Map} exception if MapOrIter is not a map or valid iterator, or with badarg if Pred is not a function of arity 2. Example: &gt; M = \#{a =&gt; 2, b =&gt; 3, c=&gt; 4, &quot;a&quot; =&gt; 1, &quot;b&quot; =&gt; 2, &quot;c&quot; =&gt; 4}, Pred = fun(K,V) -&gt; is_atom(K) andalso (V rem 2) =:= 0 end, maps:filter(Pred,M). \#{a =&gt; 2,c =&gt; 4}"},{"ref":"maps.html#find/2","title":"maps.find/2","type":"function","doc":"Returns a tuple {ok, Value}, where Value is the value associated with Key, or error if no value is associated with Key in Map. The call fails with a {badmap,Map} exception if Map is not a map. Example: &gt; Map = \#{&quot;hi&quot; =&gt; 42}, Key = &quot;hi&quot;, maps:find(Key,Map). {ok,42}"},{"ref":"maps.html#fold/3","title":"maps.fold/3","type":"function","doc":"Calls F(Key, Value, AccIn) for every Key to value Value association in MapOrIter in any order. Function fun F/3 must return a new accumulator, which is passed to the next successive call. This function returns the final value of the accumulator. The initial accumulator value Init is returned if the map is empty. The call fails with a {badmap,Map} exception if MapOrIter is not a map or valid iterator, or with badarg if Fun is not a function of arity 3. Example: &gt; Fun = fun(K,V,AccIn) when is_list(K) -&gt; AccIn + V end, Map = \#{&quot;k1&quot; =&gt; 1, &quot;k2&quot; =&gt; 2, &quot;k3&quot; =&gt; 3}, maps:fold(Fun,0,Map). 6"},{"ref":"maps.html#from_list/1","title":"maps.from_list/1","type":"function","doc":"Takes a list of key-value tuples elements and builds a map. The associations can be in any order, and both keys and values in the association can be of any term. If the same key appears more than once, the latter (right-most) value is used and the previous values are ignored. Example: &gt; List = [{&quot;a&quot;,ignored},{1337,&quot;value two&quot;},{42,value_three},{&quot;a&quot;,1}], maps:from_list(List). \#{42 =&gt; value_three,1337 =&gt; &quot;value two&quot;,&quot;a&quot; =&gt; 1}"},{"ref":"maps.html#get/2","title":"maps.get/2","type":"function","doc":"Returns value Value associated with Key if Map contains Key. The call fails with a {badmap,Map} exception if Map is not a map, or with a {badkey,Key} exception if no value is associated with Key. Example: &gt; Key = 1337, Map = \#{42 =&gt; value_two,1337 =&gt; &quot;value one&quot;,&quot;a&quot; =&gt; 1}, maps:get(Key,Map). &quot;value one&quot;"},{"ref":"maps.html#get/3","title":"maps.get/3","type":"function","doc":"Returns value Value associated with Key if Map contains Key. If no value is associated with Key, Default is returned. The call fails with a {badmap,Map} exception if Map is not a map. Example: &gt; Map = \#{ key1 =&gt; val1, key2 =&gt; val2 }. \#{key1 =&gt; val1,key2 =&gt; val2} &gt; maps:get(key1, Map, &quot;Default value&quot;). val1 &gt; maps:get(key3, Map, &quot;Default value&quot;). &quot;Default value&quot;"},{"ref":"maps.html#is_key/2","title":"maps.is_key/2","type":"function","doc":"Returns true if map Map contains Key and returns false if it does not contain the Key. The call fails with a {badmap,Map} exception if Map is not a map. Example: &gt; Map = \#{&quot;42&quot; =&gt; value}. \#{&quot;42&quot; =&gt; value} &gt; maps:is_key(&quot;42&quot;,Map). true &gt; maps:is_key(value,Map). false"},{"ref":"maps.html#iterator/1","title":"maps.iterator/1","type":"function","doc":"Returns a map iterator Iterator that can be used by maps:next/1 to traverse the key-value associations in a map. When iterating over a map, the memory usage is guaranteed to be bounded no matter the size of the map. The call fails with a {badmap,Map} exception if Map is not a map. Example: &gt; M = \#{ a =&gt; 1, b =&gt; 2 }. \#{a =&gt; 1,b =&gt; 2} &gt; I = maps:iterator(M), ok. ok &gt; {K1, V1, I2} = maps:next(I), {K1, V1}. {a,1} &gt; {K2, V2, I3} = maps:next(I2),{K2, V2}. {b,2} &gt; maps:next(I3). none"},{"ref":"maps.html#keys/1","title":"maps.keys/1","type":"function","doc":"Returns a complete list of keys, in any order, which resides within Map. The call fails with a {badmap,Map} exception if Map is not a map. Example: &gt; Map = \#{42 =&gt; value_three,1337 =&gt; &quot;value two&quot;,&quot;a&quot; =&gt; 1}, maps:keys(Map). [42,1337,&quot;a&quot;]"},{"ref":"maps.html#map/2","title":"maps.map/2","type":"function","doc":"Produces a new map Map by calling function fun F(Key, Value1) for every Key to value Value1 association in MapOrIter in any order. Function fun Fun/2 must return value Value2 to be associated with key Key for the new map Map. The call fails with a {badmap,Map} exception if MapOrIter is not a map or valid iterator, or with badarg if Fun is not a function of arity 2. Example: &gt; Fun = fun(K,V1) when is_list(K) -&gt; V1*2 end, Map = \#{&quot;k1&quot; =&gt; 1, &quot;k2&quot; =&gt; 2, &quot;k3&quot; =&gt; 3}, maps:map(Fun,Map). \#{&quot;k1&quot; =&gt; 2,&quot;k2&quot; =&gt; 4,&quot;k3&quot; =&gt; 6}"},{"ref":"maps.html#merge/2","title":"maps.merge/2","type":"function","doc":"Merges two maps into a single map Map3. If two keys exist in both maps, the value in Map1 is superseded by the value in Map2. The call fails with a {badmap,Map} exception if Map1 or Map2 is not a map. Example: &gt; Map1 = \#{a =&gt; &quot;value_one&quot;, b =&gt; &quot;value_two&quot;}, Map2 = \#{a =&gt; 1, c =&gt; 2}, maps:merge(Map1,Map2). \#{a =&gt; 1,b =&gt; &quot;value_two&quot;,c =&gt; 2}"},{"ref":"maps.html#new/0","title":"maps.new/0","type":"function","doc":"Returns a new empty map. Example: &gt; maps:new(). \#{}"},{"ref":"maps.html#next/1","title":"maps.next/1","type":"function","doc":"Returns the next key-value association in Iterator and a new iterator for the remaining associations in the iterator. If there are no more associations in the iterator, none is returned. Example: &gt; Map = \#{a =&gt; 1, b =&gt; 2, c =&gt; 3}. \#{a =&gt; 1,b =&gt; 2,c =&gt; 3} &gt; I = maps:iterator(Map), ok. ok &gt; {K1, V1, I1} = maps:next(I), {K1, V1}. {a,1} &gt; {K2, V2, I2} = maps:next(I1), {K2, V2}. {b,2} &gt; {K3, V3, I3} = maps:next(I2), {K3, V3}. {c,3} &gt; maps:next(I3). none"},{"ref":"maps.html#put/3","title":"maps.put/3","type":"function","doc":"Associates Key with value Value and inserts the association into map Map2. If key Key already exists in map Map1, the old associated value is replaced by value Value. The function returns a new map Map2 containing the new association and the old associations in Map1. The call fails with a {badmap,Map} exception if Map1 is not a map. Example: &gt; Map = \#{&quot;a&quot; =&gt; 1}. \#{&quot;a&quot; =&gt; 1} &gt; maps:put(&quot;a&quot;, 42, Map). \#{&quot;a&quot; =&gt; 42} &gt; maps:put(&quot;b&quot;, 1337, Map). \#{&quot;a&quot; =&gt; 1,&quot;b&quot; =&gt; 1337}"},{"ref":"maps.html#remove/2","title":"maps.remove/2","type":"function","doc":"Removes the Key, if it exists, and its associated value from Map1 and returns a new map Map2 without key Key. The call fails with a {badmap,Map} exception if Map1 is not a map. Example: &gt; Map = \#{&quot;a&quot; =&gt; 1}. \#{&quot;a&quot; =&gt; 1} &gt; maps:remove(&quot;a&quot;,Map). \#{} &gt; maps:remove(&quot;b&quot;,Map). \#{&quot;a&quot; =&gt; 1}"},{"ref":"maps.html#size/1","title":"maps.size/1","type":"function","doc":"Returns the number of key-value associations in Map. This operation occurs in constant time. Example: &gt; Map = \#{42 =&gt; value_two,1337 =&gt; &quot;value one&quot;,&quot;a&quot; =&gt; 1}, maps:size(Map). 3"},{"ref":"maps.html#take/2","title":"maps.take/2","type":"function","doc":"The function removes the Key, if it exists, and its associated value from Map1 and returns a tuple with the removed Value and the new map Map2 without key Key. If the key does not exist error is returned. The call will fail with a {badmap,Map} exception if Map1 is not a map. Example: &gt; Map = \#{&quot;a&quot; =&gt; &quot;hello&quot;, &quot;b&quot; =&gt; &quot;world&quot;}. \#{&quot;a&quot; =&gt; &quot;hello&quot;, &quot;b&quot; =&gt; &quot;world&quot;} &gt; maps:take(&quot;a&quot;,Map). {&quot;hello&quot;,\#{&quot;b&quot; =&gt; &quot;world&quot;}} &gt; maps:take(&quot;does not exist&quot;,Map). error"},{"ref":"maps.html#to_list/1","title":"maps.to_list/1","type":"function","doc":"Returns a list of pairs representing the key-value associations of Map, where the pairs [{K1,V1}, ..., {Kn,Vn}] are returned in arbitrary order. The call fails with a {badmap,Map} exception if Map is not a map. Example: &gt; Map = \#{42 =&gt; value_three,1337 =&gt; &quot;value two&quot;,&quot;a&quot; =&gt; 1}, maps:to_list(Map). [{42,value_three},{1337,&quot;value two&quot;},{&quot;a&quot;,1}]"},{"ref":"maps.html#update/3","title":"maps.update/3","type":"function","doc":"If Key exists in Map1, the old associated value is replaced by value Value. The function returns a new map Map2 containing the new associated value. The call fails with a {badmap,Map} exception if Map1 is not a map, or with a {badkey,Key} exception if no value is associated with Key. Example: &gt; Map = \#{&quot;a&quot; =&gt; 1}. \#{&quot;a&quot; =&gt; 1} &gt; maps:update(&quot;a&quot;, 42, Map). \#{&quot;a&quot; =&gt; 42}"},{"ref":"maps.html#update_with/3","title":"maps.update_with/3","type":"function","doc":"Update a value in a Map1 associated with Key by calling Fun on the old value to get a new value. An exception {badkey,``Key``} is generated if Key is not present in the map. Example: &gt; Map = \#{&quot;counter&quot; =&gt; 1}, Fun = fun(V) -&gt; V + 1 end, maps:update_with(&quot;counter&quot;,Fun,Map). \#{&quot;counter&quot; =&gt; 2}"},{"ref":"maps.html#update_with/4","title":"maps.update_with/4","type":"function","doc":"Update a value in a Map1 associated with Key by calling Fun on the old value to get a new value. If Key is not present in Map1 then Init will be associated with Key. Example: &gt; Map = \#{&quot;counter&quot; =&gt; 1}, Fun = fun(V) -&gt; V + 1 end, maps:update_with(&quot;new counter&quot;,Fun,42,Map). \#{&quot;counter&quot; =&gt; 1,&quot;new counter&quot; =&gt; 42}"},{"ref":"maps.html#values/1","title":"maps.values/1","type":"function","doc":"Returns a complete list of values, in arbitrary order, contained in map Map. The call fails with a {badmap,Map} exception if Map is not a map. Example: &gt; Map = \#{42 =&gt; value_three,1337 =&gt; &quot;value two&quot;,&quot;a&quot; =&gt; 1}, maps:values(Map). [value_three,&quot;value two&quot;,1]"},{"ref":"maps.html#with/2","title":"maps.with/2","type":"function","doc":"Returns a new map Map2 with the keys K1 through Kn and their associated values from map Map1. Any key in Ks that does not exist in Map1 is ignored. Example: &gt; Map = \#{42 =&gt; value_three,1337 =&gt; &quot;value two&quot;,&quot;a&quot; =&gt; 1}, Ks = [&quot;a&quot;,42,&quot;other key&quot;], maps:with(Ks,Map). \#{42 =&gt; value_three,&quot;a&quot; =&gt; 1}"},{"ref":"maps.html#without/2","title":"maps.without/2","type":"function","doc":"Returns a new map Map2 without keys K1 through Kn and their associated values from map Map1. Any key in Ks that does not exist in Map1 is ignored Example: &gt; Map = \#{42 =&gt; value_three,1337 =&gt; &quot;value two&quot;,&quot;a&quot; =&gt; 1}, Ks = [&quot;a&quot;,42,&quot;other key&quot;], maps:without(Ks,Map). \#{1337 =&gt; &quot;value two&quot;}"},{"ref":"math.html","title":"math","type":"module","doc":"This module provides an interface to a number of mathematical functions. Not all functions are provided on all platforms. In particular, the erf/1 and erfc/1 functions are not provided on Windows."},{"ref":"math.html#acosacoshasinasinhatanatan2atanhceilcoscoshexpfloorfmodloglog10log2powsinsinhsqrttantanh/1111121111112111211111","title":"math.acosacoshasinasinhatanatan2atanhceilcoscoshexpfloorfmodloglog10log2powsinsinhsqrttantanh/1111121111112111211111","type":"function","doc":"A collection of mathematical functions that return floats. Arguments are numbers."},{"ref":"math.html#erf/1","title":"math.erf/1","type":"function","doc":"Returns the error function of X, where: erf(X) = 2/sqrt(pi)*integral from 0 to X of exp(-t*t) dt."},{"ref":"math.html#erfc/1","title":"math.erfc/1","type":"function","doc":"erfc(X) returns 1.0 - erf(X), computed by methods that avoid cancellation for large X."},{"ref":"math.html#pi/0","title":"math.pi/0","type":"function","doc":"A useful number."},{"ref":"ms_transform.html","title":"ms_transform","type":"module","doc":"This module provides the parse transformation that makes calls to ets and dbg:fun2ms/1 translate into literal match specifications. It also provides the back end for the same functions when called from the Erlang shell. The translation from funs to match specifications is accessed through the two &quot;pseudo functions&quot; ets:fun2ms/1 and dbg:fun2ms/1. As everyone trying to use ets:select/2 or dbg seems to end up reading this manual page, this description is an introduction to the concept of match specifications. Read the whole manual page if it is the first time you are using the transformations. Match specifications are used more or less as filters. They resemble usual Erlang matching in a list comprehension or in a fun used with lists:foldl/3, and so on. However, the syntax of pure match specifications is awkward, as they are made up purely by Erlang terms, and the language has no syntax to make the match specifications more readable. As the execution and structure of the match specifications are like that of a fun, it is more straightforward to write it using the familiar fun syntax and to have that translated into a match specification automatically. A real fun is clearly more powerful than the match specifications allow, but bearing the match specifications in mind, and what they can do, it is still more convenient to write it all as a fun. This module contains the code that translates the fun syntax into match specification terms."},{"ref":"ms_transform.html#format_error/1","title":"ms_transform.format_error/1","type":"function","doc":"Takes an error code returned by one of the other functions in the module and creates a textual description of the error."},{"ref":"ms_transform.html#parse_transform/2","title":"ms_transform.parse_transform/2","type":"function","doc":"Implements the transformation at compile time. This function is called by the compiler to do the source code transformation if and when header file ms_transform.hrl is included in the source code. For information about how to use this parse transformation, see ets and dbg:fun2ms/1. For a description of match specifications, see section Match Specification in Erlang in ERTS User&#39;s Guide."},{"ref":"ms_transform.html#transform_from_shell/3","title":"ms_transform.transform_from_shell/3","type":"function","doc":"Implements the transformation when the fun2ms/1 functions are called from the shell. In this case, the abstract form is for one single fun (parsed by the Erlang shell). All imported variables are to be in the key-value list passed as BoundEnvironment. The result is a term, normalized, that is, not in abstract format."},{"ref":"orddict.html","title":"orddict","type":"module","doc":"This module provides a Key-Value dictionary. An orddict is a representation of a dictionary, where a list of pairs is used to store the keys and values. The list is ordered after the keys in the Erlang term order. This module provides the same interface as the dict(3) module but with a defined representation. One difference is that while dict considers two keys as different if they do not match (=:=), this module considers two keys as different if and only if they do not compare equal (==)."},{"ref":"orddict.html#append/3","title":"orddict.append/3","type":"function","doc":"Appends a new Value to the current list of values associated with Key. An exception is generated if the initial value associated with Key is not a list of values. See also section Notes."},{"ref":"orddict.html#append_list/3","title":"orddict.append_list/3","type":"function","doc":"Appends a list of values ValList to the current list of values associated with Key. An exception is generated if the initial value associated with Key is not a list of values. See also section Notes."},{"ref":"orddict.html#erase/2","title":"orddict.erase/2","type":"function","doc":"Erases all items with a specified key from a dictionary."},{"ref":"orddict.html#fetch/2","title":"orddict.fetch/2","type":"function","doc":"Returns the value associated with Key in dictionary Orddict. This function assumes that the Key is present in the dictionary. An exception is generated if Key is not in the dictionary. See also section Notes."},{"ref":"orddict.html#fetch_keys/1","title":"orddict.fetch_keys/1","type":"function","doc":"Returns a list of all keys in a dictionary."},{"ref":"orddict.html#filter/2","title":"orddict.filter/2","type":"function","doc":"Orddict2 is a dictionary of all keys and values in Orddict1 for which Pred``(``Key``, ``Value``) is true."},{"ref":"orddict.html#find/2","title":"orddict.find/2","type":"function","doc":"Searches for a key in a dictionary. Returns {ok, ``Value``}, where Value is the value associated with Key, or error if the key is not present in the dictionary. See also section Notes."},{"ref":"orddict.html#fold/3","title":"orddict.fold/3","type":"function","doc":"Calls Fun on successive keys and values of Orddict together with an extra argument Acc (short for accumulator). Fun must return a new accumulator that is passed to the next call. Acc0 is returned if the list is empty."},{"ref":"orddict.html#from_list/1","title":"orddict.from_list/1","type":"function","doc":"Converts the Key-Value list List to a dictionary."},{"ref":"orddict.html#is_empty/1","title":"orddict.is_empty/1","type":"function","doc":"Returns true if Orddict has no elements, otherwise false."},{"ref":"orddict.html#is_key/2","title":"orddict.is_key/2","type":"function","doc":"Tests if Key is contained in dictionary Orddict."},{"ref":"orddict.html#map/2","title":"orddict.map/2","type":"function","doc":"Calls Fun on successive keys and values of Orddict1 tvo return a new value for each key."},{"ref":"orddict.html#merge/3","title":"orddict.merge/3","type":"function","doc":"Merges two dictionaries, Orddict1 and Orddict2, to create a new dictionary. All the Key-Value pairs from both dictionaries are included in the new dictionary. If a key occurs in both dictionaries, Fun is called with the key and both values to return a new value. merge/3 can be defined as follows, but is faster: merge(Fun, D1, D2) -&gt; fold(fun (K, V1, D) -&gt; update(K, fun (V2) -&gt; Fun(K, V1, V2) end, V1, D) end, D2, D1)."},{"ref":"orddict.html#new/0","title":"orddict.new/0","type":"function","doc":"Creates a new dictionary."},{"ref":"orddict.html#size/1","title":"orddict.size/1","type":"function","doc":"Returns the number of elements in an Orddict."},{"ref":"orddict.html#store/3","title":"orddict.store/3","type":"function","doc":"Stores a Key-Value pair in a dictionary. If the Key already exists in Orddict1, the associated value is replaced by Value."},{"ref":"orddict.html#take/2","title":"orddict.take/2","type":"function","doc":"This function returns value from dictionary and new dictionary without this value. Returns error if the key is not present in the dictionary."},{"ref":"orddict.html#to_list/1","title":"orddict.to_list/1","type":"function","doc":"Converts a dictionary to a list representation."},{"ref":"orddict.html#update/3","title":"orddict.update/3","type":"function","doc":"Updates a value in a dictionary by calling Fun on the value to get a new value. An exception is generated if Key is not present in the dictionary."},{"ref":"orddict.html#update/4","title":"orddict.update/4","type":"function","doc":"Updates a value in a dictionary by calling Fun on the value to get a new value. If Key is not present in the dictionary, Initial is stored as the first value. For example, append/3 can be defined as follows: append(Key, Val, D) -&gt; update(Key, fun (Old) -&gt; Old ++ [Val] end, [Val], D)."},{"ref":"orddict.html#update_counter/3","title":"orddict.update_counter/3","type":"function","doc":"Adds Increment to the value associated with Key and store this value. If Key is not present in the dictionary, Increment is stored as the first value. This can be defined as follows, but is faster: update_counter(Key, Incr, D) -&gt; update(Key, fun (Old) -&gt; Old + Incr end, Incr, D)."},{"ref":"ordsets.html","title":"ordsets","type":"module","doc":"Sets are collections of elements with no duplicate elements. An ordset is a representation of a set, where an ordered list is used to store the elements of the set. An ordered list is more efficient than an unordered list. Elements are ordered according to the Erlang term order. This module provides the same interface as the sets(3) module but with a defined representation. One difference is that while sets considers two elements as different if they do not match (=:=), this module considers two elements as different if and only if they do not compare equal (==)."},{"ref":"ordsets.html#add_element/2","title":"ordsets.add_element/2","type":"function","doc":"Returns a new ordered set formed from Ordset1 with Element inserted."},{"ref":"ordsets.html#del_element/2","title":"ordsets.del_element/2","type":"function","doc":"Returns Ordset1, but with Element removed."},{"ref":"ordsets.html#filter/2","title":"ordsets.filter/2","type":"function","doc":"Filters elements in Ordset1 with boolean function Pred."},{"ref":"ordsets.html#fold/3","title":"ordsets.fold/3","type":"function","doc":"Folds Function over every element in Ordset and returns the final value of the accumulator."},{"ref":"ordsets.html#from_list/1","title":"ordsets.from_list/1","type":"function","doc":"Returns an ordered set of the elements in List."},{"ref":"ordsets.html#intersection/1","title":"ordsets.intersection/1","type":"function","doc":"Returns the intersection of the non-empty list of sets."},{"ref":"ordsets.html#intersection/2","title":"ordsets.intersection/2","type":"function","doc":"Returns the intersection of Ordset1 and Ordset2."},{"ref":"ordsets.html#is_disjoint/2","title":"ordsets.is_disjoint/2","type":"function","doc":"Returns true if Ordset1 and Ordset2 are disjoint (have no elements in common), otherwise false."},{"ref":"ordsets.html#is_element/2","title":"ordsets.is_element/2","type":"function","doc":"Returns true if Element is an element of Ordset, otherwise false."},{"ref":"ordsets.html#is_empty/1","title":"ordsets.is_empty/1","type":"function","doc":"Returns true if Ordset is an empty set, otherwise false."},{"ref":"ordsets.html#is_set/1","title":"ordsets.is_set/1","type":"function","doc":"Returns true if Ordset is an ordered set of elements, otherwise false."},{"ref":"ordsets.html#is_subset/2","title":"ordsets.is_subset/2","type":"function","doc":"Returns true when every element of Ordset1 is also a member of Ordset2, otherwise false."},{"ref":"ordsets.html#new/0","title":"ordsets.new/0","type":"function","doc":"Returns a new empty ordered set."},{"ref":"ordsets.html#size/1","title":"ordsets.size/1","type":"function","doc":"Returns the number of elements in Ordset."},{"ref":"ordsets.html#subtract/2","title":"ordsets.subtract/2","type":"function","doc":"Returns only the elements of Ordset1 that are not also elements of Ordset2."},{"ref":"ordsets.html#to_list/1","title":"ordsets.to_list/1","type":"function","doc":"Returns the elements of Ordset as a list."},{"ref":"ordsets.html#union/1","title":"ordsets.union/1","type":"function","doc":"Returns the merged (union) set of the list of sets."},{"ref":"ordsets.html#union/2","title":"ordsets.union/2","type":"function","doc":"Returns the merged (union) set of Ordset1 and Ordset2."},{"ref":"pool.html","title":"pool","type":"module","doc":"This module can be used to run a set of Erlang nodes as a pool of computational processors. It is organized as a master and a set of slave nodes and includes the following features: * The slave nodes send regular reports to the master about their current load. * Queries can be sent to the master to determine which node will have the least load. The BIF `statistics(run_queue)` is used for estimating future loads. It returns the length of the queue of ready to run processes in the Erlang runtime system. The slave nodes are started with the slave(3) module. This effects terminal I/O, file I/O, and code loading. If the master node fails, the entire pool exits."},{"ref":"pool.html#attach/1","title":"pool.attach/1","type":"function","doc":"Ensures that a pool master is running and includes Node in the pool master&#39;s pool of nodes."},{"ref":"pool.html#get_node/0","title":"pool.get_node/0","type":"function","doc":"Returns the node with the expected lowest future load."},{"ref":"pool.html#get_nodes/0","title":"pool.get_nodes/0","type":"function","doc":"Returns a list of the current member nodes of the pool."},{"ref":"pool.html#pspawn/3","title":"pool.pspawn/3","type":"function","doc":"Spawns a process on the pool node that is expected to have the lowest future load."},{"ref":"pool.html#pspawn_link/3","title":"pool.pspawn_link/3","type":"function","doc":"Spawns and links to a process on the pool node that is expected to have the lowest future load."},{"ref":"pool.html#startstart/12","title":"pool.startstart/12","type":"function","doc":"Starts a new pool. The file .hosts.erlang is read to find host names where the pool nodes can be started; see section Files. The startup procedure fails if the file is not found. The slave nodes are started with slave:start/2,3, passing along Name and, if provided, Args. Name is used as the first part of the node names, Args is used to specify command-line arguments. Access rights must be set so that all nodes in the pool have the authority to access each other. The function is synchronous and all the nodes, and all the system servers, are running when it returns a value."},{"ref":"pool.html#stop/0","title":"pool.stop/0","type":"function","doc":"Stops the pool and kills all the slave nodes."},{"ref":"proc_lib.html","title":"proc_lib","type":"module","doc":"This module is used to start processes adhering to the OTP Design Principles. Specifically, the functions in this module are used by the OTP standard behaviors (for example, gen_server and gen_statem) when starting new processes. The functions can also be used to start special processes, user-defined processes that comply to the OTP design principles. For an example, see section sys and proc_lib in OTP Design Principles. Some useful information is initialized when a process starts. The registered names, or the process identifiers, of the parent process, and the parent ancestors, are stored together with information about the function initially called in the process. While in &quot;plain Erlang&quot;, a process is said to terminate normally only for exit reason normal, a process started using proc_lib is also said to terminate normally if it exits with reason shutdown or {shutdown,Term}. shutdown is the reason used when an application (supervision tree) is stopped. When a process that is started using proc_lib terminates abnormally (that is, with another exit reason than normal, shutdown, or {shutdown,Term}), a crash report is generated, which is written to terminal by the default logger handler setup by Kernel. For more information about how crash reports were logged prior to Erlang/OTP 21.0, see SASL Error Logging in the SASL User&#39;s Guide. Unlike in &quot;plain Erlang&quot;, proc_lib processes will not generate error reports, which are written to the terminal by the emulator. All exceptions are converted to exits which are ignored by the default logger handler. The crash report contains the previously stored information, such as ancestors and initial function, the termination reason, and information about other processes that terminate as a result of this process terminating."},{"ref":"proc_lib.html#format/1","title":"proc_lib.format/1","type":"function","doc":"Equivalent to format(``CrashReport``, latin1)."},{"ref":"proc_lib.html#format/2","title":"proc_lib.format/2","type":"function","doc":"This function is deprecated in the sense that the error_logger is no longer the preferred interface for logging in Erlang/OTP. A new logging API was added in Erlang/OTP 21.0, but legacy error_logger handlers can still be used. New Logger handlers do not need to use this function, since the formatting callback (report_cb) is included as metadata in the log event. This function can be used by a user-defined legacy error_logger event handler to format a crash report. The crash report is sent using logger(3), and the event to be handled is of the format {error_report, GL, {Pid, crash_report, ``CrashReport``}}, where GL is the group leader pid of process Pid that sent the crash report."},{"ref":"proc_lib.html#format/3","title":"proc_lib.format/3","type":"function","doc":"This function is deprecated in the sense that the error_logger is no longer the preferred interface for logging in Erlang/OTP. A new logging API was added in Erlang/OTP 21.0, but legacy error_logger handlers can still be used. New Logger handlers do not need to used this function, since the formatting callback (report_cb) is included as metadata in the log event. This function can be used by a user-defined legacy error_logger event handler to format a crash report. When Depth is specified as a positive integer, it is used in the format string to limit the output as follows: io_lib:format(&quot;~P&quot;, [Term,``Depth``])."},{"ref":"proc_lib.html#hibernate/3","title":"proc_lib.hibernate/3","type":"function","doc":"This function does the same as (and does call) the hibernate/3 BIF, but ensures that exception handling and logging continues to work as expected when the process wakes up. Always use this function instead of the BIF for processes started using proc_lib functions."},{"ref":"proc_lib.html#init_ackinit_ack/12","title":"proc_lib.init_ackinit_ack/12","type":"function","doc":"This function must be used by a process that has been started by a start[_link]/3,4,5 function. It tells Parent that the process has initialized itself, has started, or has failed to initialize itself. Function init_ack/1 uses the parent value previously stored by the start function used. If this function is not called, the start function returns an error tuple (if a link and/or a time-out is used) or hang otherwise. The following example illustrates how this function and proc_lib:start_link/3 are used: -module(my_proc). -export([start_link/0]). -export([init/1]). start_link() -&gt; proc_lib:start_link(my_proc, init, [self()]). init(Parent) -&gt; case do_initialization() of ok -&gt; proc_lib:init_ack(Parent, {ok, self()}); {error, Reason} -&gt; exit(Reason) end, loop(). ..."},{"ref":"proc_lib.html#initial_call/1","title":"proc_lib.initial_call/1","type":"function","doc":"Extracts the initial call of a process that was started using one of the spawn or start functions in this module. Process can either be a pid, an integer tuple (from which a pid can be created), or the process information of a process Pid fetched through an erlang:process_info(Pid) function call. The list Args no longer contains the arguments, but the same number of atoms as the number of arguments; the first atom is &#39;Argument__1&#39;, the second &#39;Argument__2&#39;, and so on. The reason is that the argument list could waste a significant amount of memory, and if the argument list contained funs, it could be impossible to upgrade the code for the module. If the process was spawned using a fun, initial_call/1 no longer returns the fun, but the module, function for the local function implementing the fun, and the arity, for example, {some_module,-work/3-fun-0-,0} (meaning that the fun was created in function some_module:work/3). The reason is that keeping the fun would prevent code upgrade for the module, and that a significant amount of memory could be wasted."},{"ref":"proc_lib.html#spawn_linkspawn_linkspawn_linkspawn_link/1234","title":"proc_lib.spawn_linkspawn_linkspawn_linkspawn_link/1234","type":"function","doc":"Spawns a new process and initializes it as described in the beginning of this manual page. The process is spawned using the spawn_link BIFs."},{"ref":"proc_lib.html#spawn_optspawn_optspawn_optspawn_opt/2345","title":"proc_lib.spawn_optspawn_optspawn_optspawn_opt/2345","type":"function","doc":"Spawns a new process and initializes it as described in the beginning of this manual page. The process is spawned using the spawn_opt BIFs. Using spawn option monitor is not allowed. It causes the function to fail with reason badarg."},{"ref":"proc_lib.html#spawnspawnspawnspawn/1234","title":"proc_lib.spawnspawnspawnspawn/1234","type":"function","doc":"Spawns a new process and initializes it as described in the beginning of this manual page. The process is spawned using the spawn BIFs."},{"ref":"proc_lib.html#startstartstartstart_linkstart_linkstart_link/345345","title":"proc_lib.startstartstartstart_linkstart_linkstart_link/345345","type":"function","doc":"Starts a new process synchronously. Spawns the process and waits for it to start. When the process has started, it must call init_ack(Parent, Ret) or init_ack(Ret), where Parent is the process that evaluates this function. At this time, Ret is returned. If function start_link/3,4,5 is used and the process crashes before it has called init_ack/1,2, {error, ``Reason``} is returned if the calling process traps exits. If Time is specified as an integer, this function waits for Time milliseconds for the new process to call init_ack, or {error, timeout} is returned, and the process is killed. Argument SpawnOpts, if specified, is passed as the last argument to the spawn_opt/2,3,4,5 BIF. Using spawn option monitor is not allowed. It causes the function to fail with reason badarg."},{"ref":"proc_lib.html#stop/1","title":"proc_lib.stop/1","type":"function","doc":"Equivalent to stop(Process, normal, infinity)."},{"ref":"proc_lib.html#stop/3","title":"proc_lib.stop/3","type":"function","doc":"Orders the process to exit with the specified Reason and waits for it to terminate. Returns ok if the process exits with the specified Reason within Timeout milliseconds. If the call times out, a timeout exception is raised. If the process does not exist, a noproc exception is raised. The implementation of this function is based on the terminate system message, and requires that the process handles system messages correctly. For information about system messages, see sys(3) and section sys and proc_lib in OTP Design Principles."},{"ref":"proc_lib.html#translate_initial_call/1","title":"proc_lib.translate_initial_call/1","type":"function","doc":"This function is used by functions c:i/0 and c:regs/0 to present process information. This function extracts the initial call of a process that was started using one of the spawn or start functions in this module, and translates it to more useful information. Process can either be a pid, an integer tuple (from which a pid can be created), or the process information of a process Pid fetched through an erlang:process_info(Pid) function call. If the initial call is to one of the system-defined behaviors such as gen_server or gen_event, it is translated to more useful information. If a gen_server is spawned, the returned Module is the name of the callback module and Function is init (the function that initiates the new server). A supervisor and a supervisor_bridge are also gen_server processes. To return information that this process is a supervisor and the name of the callback module, Module is supervisor and Function is the name of the supervisor callback module. Arity is 1, as the init/1 function is called initially in the callback module. By default, {proc_lib,init_p,5} is returned if no information about the initial call can be found. It is assumed that the caller knows that the process has been spawned with the proc_lib module."},{"ref":"proplists.html","title":"proplists","type":"module","doc":"Property lists are ordinary lists containing entries in the form of either tuples, whose first elements are keys used for lookup and insertion, or atoms, which work as shorthand for tuples {Atom, true}. (Other terms are allowed in the lists, but are ignored by this module.) If there is more than one entry in a list for a certain key, the first occurrence normally overrides any later (irrespective of the arity of the tuples). Property lists are useful for representing inherited properties, such as options passed to a function where a user can specify options overriding the default settings, object properties, annotations, and so on. Two keys are considered equal if they match (=:=). That is, numbers are compared literally rather than by value, so that, for example, 1 and 1.0 are different keys."},{"ref":"proplists.html#append_values/2","title":"proplists.append_values/2","type":"function","doc":"Similar to get_all_values/2, but each value is wrapped in a list unless it is already itself a list. The resulting list of lists is concatenated. This is often useful for &quot;incremental&quot; options. Example: append_values(a, [{a, [1,2]}, {b, 0}, {a, 3}, {c, -1}, {a, [4]}]) returns: [1,2,3,4]"},{"ref":"proplists.html#compact/1","title":"proplists.compact/1","type":"function","doc":"Minimizes the representation of all entries in the list. This is equivalent to [property(P) || P &lt;- ListIn]. See also property/1, unfold/1."},{"ref":"proplists.html#delete/2","title":"proplists.delete/2","type":"function","doc":"Deletes all entries associated with Key from List."},{"ref":"proplists.html#expand/2","title":"proplists.expand/2","type":"function","doc":"Expands particular properties to corresponding sets of properties (or other terms). For each pair {``Property``, ``Expansion``} in Expansions: if E is the first entry in ListIn with the same key as Property, and E and Property have equivalent normal forms, then E is replaced with the terms in Expansion, and any following entries with the same key are deleted from ListIn. For example, the following expressions all return [fie, bar, baz, fum]: expand([{foo, [bar, baz]}], [fie, foo, fum]) expand([{{foo, true}, [bar, baz]}], [fie, foo, fum]) expand([{{foo, false}, [bar, baz]}], [fie, {foo, false}, fum]) However, no expansion is done in the following call because {foo, false} shadows foo: expand([{{foo, true}, [bar, baz]}], [{foo, false}, fie, foo, fum]) Notice that if the original property term is to be preserved in the result when expanded, it must be included in the expansion list. The inserted terms are not expanded recursively. If Expansions contains more than one property with the same key, only the first occurrence is used. See also normalize/2."},{"ref":"proplists.html#get_all_values/2","title":"proplists.get_all_values/2","type":"function","doc":"Similar to get_value/2, but returns the list of values for all entries {Key, Value} in List. If no such entry exists, the result is the empty list."},{"ref":"proplists.html#get_bool/2","title":"proplists.get_bool/2","type":"function","doc":"Returns the value of a boolean key/value option. If lookup(``Key``, ``List``) would yield {``Key``, true}, this function returns true, otherwise false. See also get_value/2, lookup/2."},{"ref":"proplists.html#get_keys/1","title":"proplists.get_keys/1","type":"function","doc":"Returns an unordered list of the keys used in List, not containing duplicates."},{"ref":"proplists.html#get_value/2","title":"proplists.get_value/2","type":"function","doc":"Equivalent to get_value(``Key``, ``List``, undefined)."},{"ref":"proplists.html#get_value/3","title":"proplists.get_value/3","type":"function","doc":"Returns the value of a simple key/value property in List. If lookup(``Key``, ``List``) would yield {``Key``, Value}, this function returns the corresponding Value, otherwise Default. See also get_all_values/2, get_bool/2, get_value/2, lookup/2."},{"ref":"proplists.html#is_defined/2","title":"proplists.is_defined/2","type":"function","doc":"Returns true if List contains at least one entry associated with Key, otherwise false."},{"ref":"proplists.html#lookup/2","title":"proplists.lookup/2","type":"function","doc":"Returns the first entry associated with Key in List, if one exists, otherwise returns none. For an atom A in the list, the tuple {A, true} is the entry associated with A. See also get_bool/2, get_value/2, lookup_all/2."},{"ref":"proplists.html#lookup_all/2","title":"proplists.lookup_all/2","type":"function","doc":"Returns the list of all entries associated with Key in List. If no such entry exists, the result is the empty list. See also lookup/2."},{"ref":"proplists.html#normalize/2","title":"proplists.normalize/2","type":"function","doc":"Passes ListIn through a sequence of substitution/expansion stages. For an aliases operation, function substitute_aliases/2 is applied using the specified list of aliases: * For a `negations` operation, [`substitute_negations/2`](#substitute_negations/2) is applied using the specified negation list. * For an `expand` operation, function [`expand/2`](#expand/2) is applied using the specified list of expansions. The final result is automatically compacted (compare compact/1). Typically you want to substitute negations first, then aliases, then perform one or more expansions (sometimes you want to pre-expand particular entries before doing the main expansion). You might want to substitute negations and/or aliases repeatedly, to allow such forms in the right-hand side of aliases and expansion lists. See also substitute_negations/2."},{"ref":"proplists.html#property/1","title":"proplists.property/1","type":"function","doc":"Creates a normal form (minimal) representation of a property. If PropertyIn is {Key, true}, where Key is an atom, Key is returned, otherwise the whole term PropertyIn is returned. See also property/2."},{"ref":"proplists.html#property/2","title":"proplists.property/2","type":"function","doc":"Creates a normal form (minimal) representation of a simple key/value property. Returns Key if Value is true and Key is an atom, otherwise a tuple {``Key``, ``Value``} is returned. See also property/1."},{"ref":"proplists.html#split/2","title":"proplists.split/2","type":"function","doc":"Partitions List into a list of sublists and a remainder. Lists contains one sublist for each key in Keys, in the corresponding order. The relative order of the elements in each sublist is preserved from the original List. Rest contains the elements in List that are not associated with any of the specified keys, also with their original relative order preserved. Example: split([{c, 2}, {e, 1}, a, {c, 3, 4}, d, {b, 5}, b], [a, b, c]) returns: {[[a], [{b, 5}, b],[{c, 2}, {c, 3, 4}]], [{e, 1}, d]}"},{"ref":"proplists.html#substitute_aliases/2","title":"proplists.substitute_aliases/2","type":"function","doc":"Substitutes keys of properties. For each entry in ListIn, if it is associated with some key K1 such that {K1, K2} occurs in Aliases, the key of the entry is changed to K2. If the same K1 occurs more than once in Aliases, only the first occurrence is used. For example, substitute_aliases([{color, colour}], L) replaces all tuples {color, ...} in L with {colour, ...}, and all atoms color with colour. See also normalize/2, substitute_negations/2."},{"ref":"proplists.html#substitute_negations/2","title":"proplists.substitute_negations/2","type":"function","doc":"Substitutes keys of boolean-valued properties and simultaneously negates their values. For each entry in ListIn, if it is associated with some key K1 such that {K1, K2} occurs in Negations: if the entry was {K1, true}, it is replaced with {K2, false}, otherwise with {K2, true}, thus changing the name of the option and simultaneously negating the value specified by get_bool(Key, ``ListIn``). If the same K1 occurs more than once in Negations, only the first occurrence is used. For example, substitute_negations([{no_foo, foo}], L) replaces any atom no_foo or tuple {no_foo, true} in L with {foo, false}, and any other tuple {no_foo, ...} with {foo, true}. See also get_bool/2, normalize/2, substitute_aliases/2."},{"ref":"proplists.html#unfold/1","title":"proplists.unfold/1","type":"function","doc":"Unfolds all occurrences of atoms in ListIn to tuples {Atom, true}."},{"ref":"qlc.html","title":"qlc","type":"module","doc":"This module provides a query interface to Mnesia, ETS, Dets, and other data structures that provide an iterator style traversal of objects."},{"ref":"qlc.html#append/1","title":"qlc.append/1","type":"function","doc":"Returns a query handle. When evaluating query handle QH, all answers to the first query handle in QHL are returned, followed by all answers to the remaining query handles in QHL."},{"ref":"qlc.html#append/2","title":"qlc.append/2","type":"function","doc":"Returns a query handle. When evaluating query handle QH3, all answers to QH1 are returned, followed by all answers to QH2. append(QH1,QH2) is equivalent to append([QH1,QH2])."},{"ref":"qlc.html#cursorcursor/12","title":"qlc.cursorcursor/12","type":"function","doc":"Creates a query cursor and makes the calling process the owner of the cursor. The cursor is to be used as argument to next_answers/1,2 and (eventually) delete_cursor/1. Calls erlang:spawn_opt/2 to spawn and link to a process that evaluates the query handle. The value of option spawn_options is used as last argument when calling spawn_opt/2. Defaults to [link]. Example: 1&gt; QH = qlc:q([{X,Y} || X &lt;- [a,b], Y &lt;- [1,2]]), QC = qlc:cursor(QH), qlc:next_answers(QC, 1). [{a,1}] 2&gt; qlc:next_answers(QC, 1). [{a,2}] 3&gt; qlc:next_answers(QC, all_remaining). [{b,1},{b,2}] 4&gt; qlc:delete_cursor(QC). ok cursor(``QH``) is equivalent to cursor(``QH``, [])."},{"ref":"qlc.html#delete_cursor/1","title":"qlc.delete_cursor/1","type":"function","doc":"Deletes a query cursor. Only the owner of the cursor can delete the cursor."},{"ref":"qlc.html#eeevaleval/1212","title":"qlc.eeevaleval/1212","type":"function","doc":"Evaluates a query handle in the calling process and collects all answers in a list. Example: 1&gt; QH = qlc:q([{X,Y} || X &lt;- [a,b], Y &lt;- [1,2]]), qlc:eval(QH). [{a,1},{a,2},{b,1},{b,2}] eval(``QH``) is equivalent to eval(``QH``, [])."},{"ref":"qlc.html#foldfold/34","title":"qlc.foldfold/34","type":"function","doc":"Calls Function on successive answers to the query handle together with an extra argument AccIn. The query handle and the function are evaluated in the calling process. Function must return a new accumulator, which is passed to the next call. Acc0 is returned if there are no answers to the query handle. Example: 1&gt; QH = [1,2,3,4,5,6], qlc:fold(fun(X, Sum) -&gt; X + Sum end, 0, QH). 21 fold(``Function``, ``Acc0``, ``QH``) is equivalent to fold(``Function``, ``Acc0``, ``QH``, [])."},{"ref":"qlc.html#format_error/1","title":"qlc.format_error/1","type":"function","doc":"Returns a descriptive string in English of an error tuple returned by some of the functions of the qlc module or the parse transform. This function is mainly used by the compiler invoking the parse transform."},{"ref":"qlc.html#infoinfo/12","title":"qlc.infoinfo/12","type":"function","doc":"Returns information about a query handle. The information describes the simplifications and optimizations that are the results of preparing the query for evaluation. This function is probably mainly useful during debugging. The information has the form of an Erlang expression where QLCs most likely occur. Depending on the format functions of mentioned QLC tables, it is not certain that the information is absolutely accurate. Options: * The default is to return a sequence of QLCs in a block, but if option `{flat,false}` is specified, one single QLC is returned. * The default is to return a string, but if option `{format,abstract_code}` is specified, abstract code is returned instead. In the abstract code, port identifiers, references, and pids are represented by strings. * The default is to return all elements in lists, but if option `{n_elements,NElements}` is specified, only a limited number of elements are returned. * The default is to show all parts of objects and match specifications, but if option `{depth,Depth}` is specified, parts of terms below a certain depth are replaced by `&#39;...&#39;`. info(``QH``) is equivalent to info(``QH``, []). Examples: In the following example two simple QLCs are inserted only to hold option {unique,true}: 1&gt; QH = qlc:q([{X,Y} || X &lt;- [x,y], Y &lt;- [a,b]]), io:format(&quot;~s~n&quot;, [qlc:info(QH, unique_all)]). begin V1 = qlc:q([ SQV || SQV &lt;- [x, y] ], [{unique, true}]), V2 = qlc:q([ SQV || SQV &lt;- [a, b] ], [{unique, true}]), qlc:q([ {X,Y} || X &lt;- V1, Y &lt;- V2 ], [{unique, true}]) end In the following example QLC V2 has been inserted to show the joined generators and the join method chosen. A convention is used for lookup join: the first generator (G2) is the one traversed, the second (G1) is the table where constants are looked up. 1&gt; E1 = ets:new(e1, []), E2 = ets:new(e2, []), true = ets:insert(E1, [{1,a},{2,b}]), true = ets:insert(E2, [{a,1},{b,2}]), Q = qlc:q([{X,Z,W} || {X, Z} &lt;- ets:table(E1), {W, Y} &lt;- ets:table(E2), X =:= Y]), io:format(&quot;~s~n&quot;, [qlc:info(Q)]). begin V1 = qlc:q([ P0 || P0 = {W, Y} &lt;- ets:table(#Ref&lt;0.3098908599.2283929601.256549&gt;) ]), V2 = qlc:q([ [G1 | G2] || G2 &lt;- V1, G1 &lt;- ets:table(#Ref&lt;0.3098908599.2283929601.256548&gt;), element(2, G1) =:= element(1, G2) ], [{join, lookup}]), qlc:q([ {X, Z, W} || [{X, Z} | {W, Y}] &lt;- V2 ]) end"},{"ref":"qlc.html#keysortkeysort/23","title":"qlc.keysortkeysort/23","type":"function","doc":"Returns a query handle. When evaluating query handle QH2, the answers to query handle QH1 are sorted by file_sorter:keysort/4 according to the options. The sorter uses temporary files only if QH1 does not evaluate to a list and the size of the binary representation of the answers exceeds Size bytes, where Size is the value of option size. keysort(``KeyPos``, ``QH1``) is equivalent to keysort(``KeyPos``, ``QH1``, [])."},{"ref":"qlc.html#next_answersnext_answers/12","title":"qlc.next_answersnext_answers/12","type":"function","doc":"Returns some or all of the remaining answers to a query cursor. Only the owner of QueryCursor can retrieve answers. Optional argument NumberOfAnswers determines the maximum number of answers returned. Defaults to 10. If less than the requested number of answers is returned, subsequent calls to next_answers return []."},{"ref":"qlc.html#qq/12","title":"qlc.qq/12","type":"function","doc":"Returns a query handle for a QLC. The QLC must be the first argument to this function, otherwise it is evaluated as an ordinary list comprehension. It is also necessary to add the following line to the source code: -include_lib(&quot;stdlib/include/qlc.hrl&quot;). This causes a parse transform to substitute a fun for the QLC. The (compiled) fun is called when the query handle is evaluated. When calling qlc:q/1,2 from the Erlang shell, the parse transform is automatically called. When this occurs, the fun substituted for the QLC is not compiled but is evaluated by erl_eval(3). This is also true when expressions are evaluated by file:eval/1,2 or in the debugger. To be explicit, this does not work: ... A = [X || {X} &lt;- [{1},{2}]], QH = qlc:q(A), ... Variable A is bound to the evaluated value of the list comprehension ([1,2]). The compiler complains with an error message (&quot;argument is not a query list comprehension&quot;); the shell process stops with a badarg reason. q(``QLC``) is equivalent to q(``QLC``, []). Options: * Option `{cache,ets}` can be used to cache the answers to a QLC. The answers are stored in one ETS table for each cached QLC. When a cached QLC is evaluated again, answers are fetched from the table without any further computations. Therefore, when all answers to a cached QLC have been found, the ETS tables used for caching answers to the qualifiers of the QLC can be emptied. Option `cache` is equivalent to `{cache,ets}`. * Option `{cache,list}` can be used to cache the answers to a QLC like `{cache,ets}`. The difference is that the answers are kept in a list (on the process heap). If the answers would occupy more than a certain amount of RAM memory, a temporary file is used for storing the answers. Option `max_list_size` sets the limit in bytes and the temporary file is put on the directory set by option `tmpdir`. Option cache has no effect if it is known that the QLC is to be evaluated at most once. This is always true for the top-most QLC and also for the list expression of the first generator in a list of qualifiers. Notice that in the presence of side effects in filters or callback functions, the answers to QLCs can be affected by option cache. * Option `{unique,true}` can be used to remove duplicate answers to a QLC. The unique answers are stored in one ETS table for each QLC. The table is emptied every time it is known that there are no more answers to the QLC. Option `unique` is equivalent to `{unique,true}`. If option `unique` is combined with option `{cache,ets}`, two ETS tables are used, but the full answers are stored in one table only. If option `unique` is combined with option `{cache,list}`, the answers are sorted twice using `keysort/3`; once to remove duplicates and once to restore the order. Options cache and unique apply not only to the QLC itself but also to the results of looking up constants, running match specifications, and joining handles. Example: In the following example the cached results of the merge join are traversed for each value of A. Notice that without option cache the join would have been carried out three times, once for each value of A. 1&gt; Q = qlc:q([{A,X,Z,W} || A &lt;- [a,b,c], {X,Z} &lt;- [{a,1},{b,4},{c,6}], {W,Y} &lt;- [{2,a},{3,b},{4,c}], X =:= Y], {cache, list}), io:format(&quot;~s~n&quot;, [qlc:info(Q)]). begin V1 = qlc:q([ P0 || P0 = {X, Z} &lt;- qlc:keysort(1, [{a, 1}, {b, 4}, {c, 6}], []) ]), V2 = qlc:q([ P0 || P0 = {W, Y} &lt;- qlc:keysort(2, [{2, a}, {3, b}, {4, c}], []) ]), V3 = qlc:q([ [G1 | G2] || G1 &lt;- V1, G2 &lt;- V2, element(1, G1) == element(2, G2) ], [{join, merge}, {cache, list}]), qlc:q([ {A, X, Z, W} || A &lt;- [a, b, c], [{X, Z} | {W, Y}] &lt;- V3, X =:= Y ]) end sort/1,2 and keysort/2,3 can also be used for caching answers and for removing duplicates. When sorting answers are cached in a list, possibly stored on a temporary file, and no ETS tables are used. Sometimes (see table/2) traversal of tables can be done by looking up key values, which is assumed to be fast. Under certain (rare) circumstances there can be too many key values to look up. Option {max_lookup,MaxLookup} can then be used to limit the number of lookups: if more than MaxLookup lookups would be required, no lookups are done but the table is traversed instead. Defaults to infinity, which means that there is no limit on the number of keys to look up. Example: In the following example, using the gb_table module from section Implementing a QLC Table, there are six keys to look up: {1,a}, {1,b}, {1,c}, {2,a}, {2,b}, and {2,c}. The reason is that the two elements of key {X,Y} are compared separately. 1&gt; T = gb_trees:empty(), QH = qlc:q([X || {{X,Y},_} &lt;- gb_table:table(T), ((X == 1) or (X == 2)) andalso ((Y == a) or (Y == b) or (Y == c))]), io:format(&quot;~s~n&quot;, [qlc:info(QH)]). ets:match_spec_run( lists:flatmap(fun(K) -&gt; case gb_trees:lookup(K, gb_trees:from_orddict([])) of {value, V} -&gt; [{K, V}]; none -&gt; [] end end, [{1, a}, {1, b}, {1, c}, {2, a}, {2, b}, {2, c}]), ets:match_spec_compile([{{{&#39;$1&#39;, &#39;$2&#39;}, &#39;_&#39;}, [], [&#39;$1&#39;]}])) Options: * Option `{lookup,true}` can be used to ensure that the `qlc` module looks up constants in some QLC table. If there are more than one QLC table among the list expressions of the generators, constants must be looked up in at least one of the tables. The evaluation of the query fails if there are no constants to look up. This option is useful when it would be unacceptable to traverse all objects in some table. Setting option `lookup` to `false` ensures that no constants are looked up (`{max_lookup,0}` has the same effect). Defaults to `any`, which means that constants are looked up whenever possible. * Option `{join,Join}` can be used to ensure that a certain join method is used: * `{join,lookup}` invokes the lookup join method. * `{join,merge}` invokes the merge join method. * `{join,nested_loop}` invokes the method of matching every pair of objects from two handles. This method is mostly very slow. The evaluation of the query fails if the `qlc` module cannot carry out the chosen join method. Defaults to `any`, which means that some fast join method is used if possible."},{"ref":"qlc.html#sortsort/12","title":"qlc.sortsort/12","type":"function","doc":"Returns a query handle. When evaluating query handle QH2, the answers to query handle QH1 are sorted by file_sorter:sort/3 according to the options. The sorter uses temporary files only if QH1 does not evaluate to a list and the size of the binary representation of the answers exceeds Size bytes, where Size is the value of option size. sort(``QH1``) is equivalent to sort(``QH1``, [])."},{"ref":"qlc.html#string_to_handlestring_to_handlestring_to_handle/123","title":"qlc.string_to_handlestring_to_handlestring_to_handle/123","type":"function","doc":"A string version of q/1,2. When the query handle is evaluated, the fun created by the parse transform is interpreted by erl_eval(3). The query string is to be one single QLC terminated by a period. Example: 1&gt; L = [1,2,3], Bs = erl_eval:add_binding(&#39;L&#39;, L, erl_eval:new_bindings()), QH = qlc:string_to_handle(&quot;[X+1 || X &lt;- L].&quot;, [], Bs), qlc:eval(QH). [2,3,4] string_to_handle(``QueryString``) is equivalent to string_to_handle(``QueryString``, []). string_to_handle(``QueryString``, ``Options``) is equivalent to string_to_handle(``QueryString``, ``Options``, erl_eval:new_bindings()). This function is probably mainly useful when called from outside of Erlang, for example from a driver written in C."},{"ref":"qlc.html#table/2","title":"qlc.table/2","type":"function","doc":"Returns a query handle for a QLC table. In Erlang/OTP there is support for ETS, Dets, and Mnesia tables, but many other data structures can be turned into QLC tables. This is accomplished by letting function(s) in the module implementing the data structure create a query handle by calling qlc:table/2. The different ways to traverse the table and properties of the table are handled by callback functions provided as options to qlc:table/2. * Callback function `TraverseFun` is used for traversing the table. It is to return a list of objects terminated by either `[]` or a nullary fun to be used for traversing the not yet traversed objects of the table. Any other return value is immediately returned as value of the query evaluation. Unary `TraverseFun`s are to accept a match specification as argument. The match specification is created by the parse transform by analyzing the pattern of the generator calling `qlc:table/2` and filters using variables introduced in the pattern. If the parse transform cannot find a match specification equivalent to the pattern and filters, `TraverseFun` is called with a match specification returning every object. * Modules that can use match specifications for optimized traversal of tables are to call `qlc:table/2` with an unary `TraverseFun`. An example is `ets:table/2`. * Other modules can provide a nullary `TraverseFun`. An example is `gb_table:table/1` in section Implementing a QLC Table. * Unary callback function `PreFun` is called once before the table is read for the first time. If the call fails, the query evaluation fails. Argument PreArgs is a list of tagged values. There are two tags, parent_value and stop_fun, used by Mnesia for managing transactions. * The value of `parent_value` is the value returned by `ParentFun`, or `undefined` if there is no `ParentFun`. `ParentFun` is called once just before the call of `PreFun` in the context of the process calling `eval/1,2`, `fold/3,4`, or `cursor/1,2`. * The value of `stop_fun` is a nullary fun that deletes the cursor if called from the parent, or `undefined` if there is no cursor. * Nullary callback function `PostFun` is called once after the table was last read. The return value, which is caught, is ignored. If `PreFun` has been called for a table, `PostFun` is guaranteed to be called for that table, even if the evaluation of the query fails for some reason. The pre (post) functions for different tables are evaluated in unspecified order. Other table access than reading, such as calling InfoFun, is assumed to be OK at any time. * Binary callback function `LookupFun` is used for looking up objects in the table. The first argument `Position` is the key position or an indexed position and the second argument `Keys` is a sorted list of unique values. The return value is to be a list of all objects (tuples), such that the element at `Position` is a member of `Keys`. Any other return value is immediately returned as value of the query evaluation. `LookupFun` is called instead of traversing the table if the parse transform at compile time can determine that the filters match and compare the element at `Position` in such a way that only `Keys` need to be looked up to find all potential answers. The key position is obtained by calling InfoFun``(keypos) and the indexed positions by calling InfoFun``(indices). If the key position can be used for lookup, it is always chosen, otherwise the indexed position requiring the least number of lookups is chosen. If there is a tie between two indexed positions, the one occurring first in the list returned by InfoFun is chosen. Positions requiring more than max_lookup lookups are ignored. * Unary callback function `InfoFun` is to return information about the table. `undefined` is to be returned if the value of some tag is unknown: indices Returns a list of indexed positions, a list of positive integers. is_unique_objects Returns true if the objects returned by TraverseFun are unique. keypos Returns the position of the table key, a positive integer. is_sorted_key Returns true if the objects returned by TraverseFun are sorted on the key. num_of_objects Returns the number of objects in the table, a non-negative integer. Unary callback function FormatFun is used by info/1,2 for displaying the call that created the query handle of the table. Defaults to undefined, which means that info/1,2 displays a call to &#39;$MOD&#39;:&#39;$FUN&#39;/0. It is up to FormatFun to present the selected objects of the table in a suitable way. However, if a character list is chosen for presentation, it must be an Erlang expression that can be scanned and parsed (a trailing dot is added by info/1,2 though). FormatFun is called with an argument that describes the selected objects based on optimizations done as a result of analyzing the filters of the QLC where the call to qlc:table/2 occurs. The argument can have the following values: {lookup, Position, Keys, NElements, DepthFun}. * LookupFun is used for looking up objects in the table. {match_spec, MatchExpression} * No way of finding all possible answers by looking up keys was found, but the filters could be transformed into a match specification. All answers are found by calling TraverseFun(MatchExpression). {all, NElements, DepthFun} * No optimization was found. A match specification matching all objects is used if TraverseFun is unary. NElements is the value of the info/1,2 option n_elements. DepthFun is a function that can be used for limiting the size of terms; calling DepthFun(Term) substitutes &#39;...&#39; for parts of Term below the depth specified by the info/1,2 option depth. If calling FormatFun with an argument including NElements and DepthFun fails, FormatFun is called once again with an argument excluding NElements and DepthFun ({lookup,Position,Keys} or all). * The value of option `key_equality` is to be `&#39;=:=&#39;` if the table considers two keys equal if they match, and to be `&#39;==&#39;` if two keys are equal if they compare equal. Defaults to `&#39;=:=&#39;`. For the various options recognized by table/1,2 in respective module, see ets(3), dets(3), and mnesia(3)."},{"ref":"queue.html","title":"queue","type":"module","doc":"This module provides (double-ended) FIFO queues in an efficient manner. All functions fail with reason badarg if arguments are of wrong type, for example, queue arguments are not queues, indexes are not integers, and list arguments are not lists. Improper lists cause internal crashes. An index out of range for a queue also causes a failure with reason badarg. Some functions, where noted, fail with reason empty for an empty queue. The data representing a queue as used by this module is to be regarded as opaque by other modules. Any code assuming knowledge of the format is running on thin ice. All operations has an amortized O(1) running time, except filter/2, join/2, len/1, member/2, split/2 that have O(n). To minimize the size of a queue minimizing the amount of garbage built by queue operations, the queues do not contain explicit length information, and that is why len/1 is O(n). If better performance for this particular operation is essential, it is easy for the caller to keep track of the length. Queues are double-ended. The mental picture of a queue is a line of people (items) waiting for their turn. The queue front is the end with the item that has waited the longest. The queue rear is the end an item enters when it starts to wait. If instead using the mental picture of a list, the front is called head and the rear is called tail. Entering at the front and exiting at the rear are reverse operations on the queue. This module has three sets of interface functions: the &quot;Original API&quot;, the &quot;Extended API&quot;, and the &quot;Okasaki API&quot;. The &quot;Original API&quot; and the &quot;Extended API&quot; both use the mental picture of a waiting line of items. Both have reverse operations suffixed &quot;_r&quot;. The &quot;Original API&quot; item removal functions return compound terms with both the removed item and the resulting queue. The &quot;Extended API&quot; contains alternative functions that build less garbage and functions for just inspecting the queue ends. Also the &quot;Okasaki API&quot; functions build less garbage. The &quot;Okasaki API&quot; is inspired by &quot;Purely Functional Data Structures&quot; by Chris Okasaki. It regards queues as lists. This API is by many regarded as strange and avoidable. For example, many reverse operations have lexically reversed names, some with more readable but perhaps less understandable aliases."},{"ref":"queue.html#cons/2","title":"queue.cons/2","type":"function","doc":"Inserts Item at the head of queue Q1. Returns the new queue Q2."},{"ref":"queue.html#daeh/1","title":"queue.daeh/1","type":"function","doc":"Returns the tail item of queue Q. Fails with reason empty if Q is empty."},{"ref":"queue.html#drop/1","title":"queue.drop/1","type":"function","doc":"Returns a queue Q2 that is the result of removing the front item from Q1. Fails with reason empty if Q1 is empty."},{"ref":"queue.html#drop_r/1","title":"queue.drop_r/1","type":"function","doc":"Returns a queue Q2 that is the result of removing the rear item from Q1. Fails with reason empty if Q1 is empty."},{"ref":"queue.html#filter/2","title":"queue.filter/2","type":"function","doc":"Returns a queue Q2 that is the result of calling Fun``(``Item``) on all items in Q1, in order from front to rear. If Fun``(``Item``) returns true, Item is copied to the result queue. If it returns false, Item is not copied. If it returns a list, the list elements are inserted instead of Item in the result queue. So, Fun``(``Item``) returning [``Item``] is thereby semantically equivalent to returning true, just as returning [] is semantically equivalent to returning false. But returning a list builds more garbage than returning an atom."},{"ref":"queue.html#from_list/1","title":"queue.from_list/1","type":"function","doc":"Returns a queue containing the items in L in the same order; the head item of the list becomes the front item of the queue."},{"ref":"queue.html#get/1","title":"queue.get/1","type":"function","doc":"Returns Item at the front of queue Q. Fails with reason empty if Q is empty."},{"ref":"queue.html#get_r/1","title":"queue.get_r/1","type":"function","doc":"Returns Item at the rear of queue Q. Fails with reason empty if Q is empty."},{"ref":"queue.html#head/1","title":"queue.head/1","type":"function","doc":"Returns Item from the head of queue Q. Fails with reason empty if Q is empty."},{"ref":"queue.html#in/2","title":"queue.in/2","type":"function","doc":"Inserts Item at the rear of queue Q1. Returns the resulting queue Q2."},{"ref":"queue.html#in_r/2","title":"queue.in_r/2","type":"function","doc":"Inserts Item at the front of queue Q1. Returns the resulting queue Q2."},{"ref":"queue.html#init/1","title":"queue.init/1","type":"function","doc":"Returns a queue Q2 that is the result of removing the tail item from Q1. Fails with reason empty if Q1 is empty."},{"ref":"queue.html#is_empty/1","title":"queue.is_empty/1","type":"function","doc":"Tests if Q is empty and returns true if so, otherwise false."},{"ref":"queue.html#is_queue/1","title":"queue.is_queue/1","type":"function","doc":"Tests if Term is a queue and returns true if so, otherwise false."},{"ref":"queue.html#join/2","title":"queue.join/2","type":"function","doc":"Returns a queue Q3 that is the result of joining Q1 and Q2 with Q1 in front of Q2."},{"ref":"queue.html#lait/1","title":"queue.lait/1","type":"function","doc":"Returns a queue Q2 that is the result of removing the tail item from Q1. Fails with reason empty if Q1 is empty. The name lait/1 is a misspelling - do not use it anymore."},{"ref":"queue.html#last/1","title":"queue.last/1","type":"function","doc":"Returns the tail item of queue Q. Fails with reason empty if Q is empty."},{"ref":"queue.html#len/1","title":"queue.len/1","type":"function","doc":"Calculates and returns the length of queue Q."},{"ref":"queue.html#liat/1","title":"queue.liat/1","type":"function","doc":"Returns a queue Q2 that is the result of removing the tail item from Q1. Fails with reason empty if Q1 is empty."},{"ref":"queue.html#member/2","title":"queue.member/2","type":"function","doc":"Returns true if Item matches some element in Q, otherwise false."},{"ref":"queue.html#new/0","title":"queue.new/0","type":"function","doc":"Returns an empty queue."},{"ref":"queue.html#out/1","title":"queue.out/1","type":"function","doc":"Removes the item at the front of queue Q1. Returns tuple {{value, ``Item``}, ``Q2``}, where Item is the item removed and Q2 is the resulting queue. If Q1 is empty, tuple {empty, ``Q1``} is returned."},{"ref":"queue.html#out_r/1","title":"queue.out_r/1","type":"function","doc":"Removes the item at the rear of queue Q1. Returns tuple {{value, ``Item``}, ``Q2``}, where Item is the item removed and Q2 is the new queue. If Q1 is empty, tuple {empty, ``Q1``} is returned."},{"ref":"queue.html#peek/1","title":"queue.peek/1","type":"function","doc":"Returns tuple {value, ``Item``}, where Item is the front item of Q, or empty if Q is empty."},{"ref":"queue.html#peek_r/1","title":"queue.peek_r/1","type":"function","doc":"Returns tuple {value, ``Item``}, where Item is the rear item of Q, or empty if Q is empty."},{"ref":"queue.html#reverse/1","title":"queue.reverse/1","type":"function","doc":"Returns a queue Q2 containing the items of Q1 in the reverse order."},{"ref":"queue.html#snoc/2","title":"queue.snoc/2","type":"function","doc":"Inserts Item as the tail item of queue Q1. Returns the new queue Q2."},{"ref":"queue.html#split/2","title":"queue.split/2","type":"function","doc":"Splits Q1 in two. The N front items are put in Q2 and the rest in Q3."},{"ref":"queue.html#tail/1","title":"queue.tail/1","type":"function","doc":"Returns a queue Q2 that is the result of removing the head item from Q1. Fails with reason empty if Q1 is empty."},{"ref":"queue.html#to_list/1","title":"queue.to_list/1","type":"function","doc":"Returns a list of the items in the queue in the same order; the front item of the queue becomes the head of the list."},{"ref":"rand.html","title":"rand","type":"module","doc":"This module provides a pseudo random number generator. The module contains a number of algorithms. The uniform distribution algorithms are based on the Xoroshiro and Xorshift algorithms by Sebastiano Vigna. The normal distribution algorithm uses the Ziggurat Method by Marsaglia and Tsang on top of the uniform distribution algorithm. For most algorithms, jump functions are provided for generating non-overlapping sequences for parallel computations. The jump functions perform calculations equivalent to perform a large number of repeated calls for calculating new states. The following algorithms are provided: exsss Xorshift116*, 58 bits precision and period of 2^116-1 Jump function: equivalent to 2^64 calls This is the Xorshift116 generator combined with the StarStar scrambler from the 2018 paper by David Blackman and Sebastiano Vigna: Scrambled Linear Pseudorandom Number Generators The generator does not need 58-bit rotates so it is faster than the Xoroshiro116 generator, and when combined with the StarStar scrambler it does not have any weak low bits like exrop (Xoroshiro116+). Alas, this combination is about 10% slower than exrop, but is despite that the default algorithm thanks to its statistical qualities. exro928ss Xoroshiro928*, 58 bits precision and a period of 2^928-1 Jump function: equivalent to 2^512 calls This is a 58 bit version of Xoroshiro1024**, from the 2018 paper by David Blackman and Sebastiano Vigna: Scrambled Linear Pseudorandom Number Generators that on a 64 bit Erlang system executes only about 40% slower than the default exsss algorithm but with much longer period and better statistical properties, and on the flip side a larger state. Many thanks to Sebastiano Vigna for his help with the 58 bit adaption. exrop * Xoroshiro116+, 58 bits precision and period of 2^116-1 Jump function: equivalent to 2^64 calls exs1024s Xorshift1024, 64 bits precision and a period of 2^1024-1 Jump function: equivalent to 2^512 calls exsp * Xorshift116+, 58 bits precision and period of 2^116-1 Jump function: equivalent to 2^64 calls This is a corrected version of the previous default algorithm, that now has been superseded by Xoroshiro116+ (exrop). Since there is no native 58 bit rotate instruction this algorithm executes a little (say &lt; 15%) faster than exrop. See the algorithms&#39; homepage. The default algorithm is `exsss` (Xorshift116**). If a specific algorithm is required, ensure to always use [`seed/1`](#seed/1) to initialize the state. Undocumented (old) algorithms are deprecated but still implemented so old code relying on them will produce the same pseudo random sequences as before. There were a number of problems in the implementation of the now undocumented algorithms, which is why they are deprecated. The new algorithms are a bit slower but do not have these problems: Uniform integer ranges had a skew in the probability distribution that was not noticable for small ranges but for large ranges less than the generator&#39;s precision the probability to produce a low number could be twice the probability for a high. Uniform integer ranges larger than or equal to the generator&#39;s precision used a floating point fallback that only calculated with 52 bits which is smaller than the requested range and therefore were not all numbers in the requested range even possible to produce. Uniform floats had a non-uniform density so small values i.e less than 0.5 had got smaller intervals decreasing as the generated value approached 0.0 although still uniformly distributed for sufficiently large subranges. The new algorithms produces uniformly distributed floats on the form N * 2.0^(-53) hence equally spaced. Every time a random number is requested, a state is used to calculate it and a new state is produced. The state can either be implicit or be an explicit argument and return value. The functions with implicit state use the process dictionary variable rand_seed to remember the current state. If a process calls uniform/0, uniform/1 or uniform_real/0 without setting a seed first, seed/1 is called automatically with the default algorithm and creates a non-constant seed. The functions with explicit state never use the process dictionary. Examples: Simple use; creates and seeds the default algorithm with a non-constant seed if not already done: R0 = rand:uniform(), R1 = rand:uniform(), Use a specified algorithm: _ = rand:seed(exs928ss), R2 = rand:uniform(), Use a specified algorithm with a constant seed: _ = rand:seed(exs928ss, {123, 123534, 345345}), R3 = rand:uniform(), Use the functional API with a non-constant seed: S0 = rand:seed_s(exsss), {R4, S1} = rand:uniform_s(S0), Textbook basic form Box-Muller standard normal deviate R5 = rand:uniform_real(), R6 = rand:uniform(), SND0 = math:sqrt(-2 * math:log(R5)) * math:cos(math:pi() * R6) Create a standard normal deviate: {SND1, S2} = rand:normal_s(S1), Create a normal deviate with mean -3 and variance 0.5: {ND0, S3} = rand:normal_s(-3, 0.5, S2), The builtin random number generator algorithms are not cryptographically strong. If a cryptographically strong random number generator is needed, use something like crypto:rand_seed/0. For all these generators except exro928ss and exsss the lowest bit(s) has got a slightly less random behaviour than all other bits. 1 bit for exrop (and exsp), and 3 bits for exs1024s. See for example the explanation in the Xoroshiro128+ generator source code: Beside passing BigCrush, this generator passes the PractRand test suite up to (and included) 16TB, with the exception of binary rank tests, which fail due to the lowest bit being an LFSR; all other bits pass all tests. We suggest to use a sign test to extract a random Boolean value. If this is a problem; to generate a boolean with these algorithms use something like this: (rand:uniform(16) &gt; 8) And for a general range, with N = 1 for exrop, and N = 3 for exs1024s: (((rand:uniform(Range bsl N) - 1) bsr N) + 1) The floating point generating functions in this module waste the lowest bits when converting from an integer so they avoid this snag."},{"ref":"rand.html#export_seed/0","title":"rand.export_seed/0","type":"function","doc":"Returns the random number state in an external format. To be used with seed/1."},{"ref":"rand.html#export_seed_s/1","title":"rand.export_seed_s/1","type":"function","doc":"Returns the random number generator state in an external format. To be used with seed/1."},{"ref":"rand.html#jump/0","title":"rand.jump/0","type":"function","doc":"Returns the state after performing jump calculation to the state in the process dictionary. This function generates a not_implemented error exception when the jump function is not implemented for the algorithm specified in the state in the process dictionary."},{"ref":"rand.html#jump/1","title":"rand.jump/1","type":"function","doc":"Returns the state after performing jump calculation to the given state. This function generates a not_implemented error exception when the jump function is not implemented for the algorithm specified in the state."},{"ref":"rand.html#normal/0","title":"rand.normal/0","type":"function","doc":"Returns a standard normal deviate float (that is, the mean is 0 and the standard deviation is 1) and updates the state in the process dictionary."},{"ref":"rand.html#normal/2","title":"rand.normal/2","type":"function","doc":"Returns a normal N(Mean, Variance) deviate float and updates the state in the process dictionary."},{"ref":"rand.html#normal_s/1","title":"rand.normal_s/1","type":"function","doc":"Returns, for a specified state, a standard normal deviate float (that is, the mean is 0 and the standard deviation is 1) and a new state."},{"ref":"rand.html#normal_s/3","title":"rand.normal_s/3","type":"function","doc":"Returns, for a specified state, a normal N(Mean, Variance) deviate float and a new state."},{"ref":"rand.html#seed/1","title":"rand.seed/1","type":"function","doc":"Seeds random number generation with the specifed algorithm and time-dependent data if AlgOrStateOrExpState is an algorithm. Otherwise recreates the exported seed in the process dictionary, and returns the state. See also export_seed/0."},{"ref":"rand.html#seed/2","title":"rand.seed/2","type":"function","doc":"Seeds random number generation with the specified algorithm and integers in the process dictionary and returns the state."},{"ref":"rand.html#seed_s/1","title":"rand.seed_s/1","type":"function","doc":"Seeds random number generation with the specifed algorithm and time-dependent data if AlgOrStateOrExpState is an algorithm. Otherwise recreates the exported seed and returns the state. See also export_seed/0."},{"ref":"rand.html#seed_s/2","title":"rand.seed_s/2","type":"function","doc":"Seeds random number generation with the specified algorithm and integers and returns the state."},{"ref":"rand.html#uniform/0","title":"rand.uniform/0","type":"function","doc":"Returns a random float uniformly distributed in the value range 0.0 =&lt; ``X`` ``&lt; 1.0 and updates the state in the process dictionary. The generated numbers are on the form N * 2.0^(-53), that is; equally spaced in the interval. This function may return exactly 0.0 which can be fatal for certain applications. If that is undesired you can use (1.0 - rand:uniform()) to get the interval 0.0 &lt; ``X`` =``&lt; 1.0, or instead use uniform_real/0. If neither endpoint is desired you can test and re-try like this: my_uniform() -&gt; case rand:uniform() of 0.0 -&gt; my_uniform(); X -&gt; X end end."},{"ref":"rand.html#uniform/1","title":"rand.uniform/1","type":"function","doc":"Returns, for a specified integer N`` &gt;= 1, a random integer uniformly distributed in the value range 1 =&lt; ``X`` =``&lt; ``N and updates the state in the process dictionary."},{"ref":"rand.html#uniform_real/0","title":"rand.uniform_real/0","type":"function","doc":"Returns a random float uniformly distributed in the value range DBL_MIN =&lt; ``X`` ``&lt; 1.0 and updates the state in the process dictionary. Conceptually, a random real number R is generated from the interval 0 =&lt; R &lt; 1 and then the closest rounded down normalized number in the IEEE 754 Double precision format is returned. The generated numbers from this function has got better granularity for small numbers than the regular uniform/0 because all bits in the mantissa are random. This property, in combination with the fact that exactly zero is never returned is useful for algoritms doing for example 1.0 / ``X or math:log(``X``). See uniform_real_s/1 for more explanation."},{"ref":"rand.html#uniform_real_s/1","title":"rand.uniform_real_s/1","type":"function","doc":"Returns, for a specified state, a random float uniformly distributed in the value range DBL_MIN =&lt; ``X`` ``&lt; 1.0 and updates the state in the process dictionary. Conceptually, a random real number R is generated from the interval 0 =&lt; R &lt; 1 and then the closest rounded down normalized number in the IEEE 754 Double precision format is returned. The generated numbers from this function has got better granularity for small numbers than the regular uniform_s/1 because all bits in the mantissa are random. This property, in combination with the fact that exactly zero is never returned is useful for algoritms doing for example 1.0 / ``X or math:log(``X``). The concept implicates that the probability to get exactly zero is extremely low; so low that this function is in fact guaranteed to never return zero. The smallest number that it might return is DBL_MIN, which is 2.0^(-1022). The value range stated at the top of this function description is technically correct, but 0.0 =&lt; ``X`` ``&lt; 1.0 is a better description of the generated numbers&#39; statistical distribution. Except that exactly 0.0 is never returned, which is not possible to observe statistically. For example; for all sub ranges N*2.0^(-53) =&lt; X &lt; (N+1)*2.0^(-53) where 0 =&lt; integer(N) &lt; 2.0^53 the probability is the same. Compare that with the form of the numbers generated by uniform_s/1. Having to generate extra random bits for small numbers costs a little performance. This function is about 20% slower than the regular uniform_s/1"},{"ref":"rand.html#uniform_s/1","title":"rand.uniform_s/1","type":"function","doc":"Returns, for a specified state, random float uniformly distributed in the value range 0.0 =&lt; ``X`` ``&lt; 1.0 and a new state. The generated numbers are on the form N * 2.0^(-53), that is; equally spaced in the interval. This function may return exactly 0.0 which can be fatal for certain applications. If that is undesired you can use (1.0 - rand:uniform(State)) to get the interval 0.0 &lt; ``X`` =``&lt; 1.0, or instead use uniform_real_s/1. If neither endpoint is desired you can test and re-try like this: my_uniform(State) -&gt; case rand:uniform(State) of {0.0, NewState} -&gt; my_uniform(NewState); Result -&gt; Result end end."},{"ref":"rand.html#uniform_s/2","title":"rand.uniform_s/2","type":"function","doc":"Returns, for a specified integer N`` &gt;= 1 and a state, a random integer uniformly distributed in the value range 1 =&lt; ``X`` =``&lt; ``N and a new state."},{"ref":"random.html","title":"random","type":"module","doc":"This module provides a random number generator. The method is attributed to B.A. Wichmann and I.D. Hill in &#39;An efficient and portable pseudo-random number generator&#39;, Journal of Applied Statistics. AS183. 1982. Also Byte March 1987. The algorithm is a modification of the version attributed to Richard A. O&#39;Keefe in the standard Prolog library. Every time a random number is requested, a state is used to calculate it, and a new state is produced. The state can either be implicit (kept in the process dictionary) or be an explicit argument and return value. In this implementation, the state (the type ran()) consists of a tuple of three integers. This random number generator is not cryptographically strong. If a strong cryptographic random number generator is needed, use one of functions in the crypto module, for example, crypto:strong_rand_bytes/1. The improved rand module is to be used instead of this module."},{"ref":"random.html#seed/0","title":"random.seed/0","type":"function","doc":"Seeds random number generation with default (fixed) values in the process dictionary and returns the old state."},{"ref":"random.html#seed/1","title":"random.seed/1","type":"function","doc":"seed({``A1``, ``A2``, ``A3``}) is equivalent to seed(``A1``, ``A2``, ``A3``)."},{"ref":"random.html#seed/3","title":"random.seed/3","type":"function","doc":"Seeds random number generation with integer values in the process dictionary and returns the old state. The following is an easy way of obtaining a unique value to seed with: random:seed(erlang:phash2([node()]), erlang:monotonic_time(), erlang:unique_integer()) For details, see erlang:phash2/1, erlang:node/0, erlang:monotonic_time/0, and erlang:unique_integer/0."},{"ref":"random.html#seed0/0","title":"random.seed0/0","type":"function","doc":"Returns the default state."},{"ref":"random.html#uniform/0","title":"random.uniform/0","type":"function","doc":"Returns a random float uniformly distributed between 0.0 and 1.0, updating the state in the process dictionary."},{"ref":"random.html#uniform/1","title":"random.uniform/1","type":"function","doc":"Returns, for a specified integer N`` &gt;= 1, a random integer uniformly distributed between 1 and N, updating the state in the process dictionary."},{"ref":"random.html#uniform_s/1","title":"random.uniform_s/1","type":"function","doc":"Returns, for a specified state, a random float uniformly distributed between 0.0 and 1.0, and a new state."},{"ref":"random.html#uniform_s/2","title":"random.uniform_s/2","type":"function","doc":"Returns, for a specified integer N`` &gt;= 1 and a state, a random integer uniformly distributed between 1 and N, and a new state."},{"ref":"re.html","title":"re","type":"module","doc":"This module contains regular expression matching functions for strings and binaries. The regular expression syntax and semantics resemble that of Perl. The matching algorithms of the library are based on the PCRE library, but not all of the PCRE library is interfaced and some parts of the library go beyond what PCRE offers. Currently PCRE version 8.40 (release date 2017-01-11) is used. The sections of the PCRE documentation that are relevant to this module are included here. The Erlang literal syntax for strings uses the &quot;\\&quot; (backslash) character as an escape code. You need to escape backslashes in literal strings, both in your code and in the shell, with an extra backslash, that is, &quot;\\&quot;."},{"ref":"re.html#compile/1","title":"re.compile/1","type":"function","doc":"The same as compile(``Regexp``,[])"},{"ref":"re.html#compile/2","title":"re.compile/2","type":"function","doc":"Compiles a regular expression, with the syntax described below, into an internal format to be used later as a parameter to run/2 and run/3. Compiling the regular expression before matching is useful if the same expression is to be used in matching against multiple subjects during the lifetime of the program. Compiling once and executing many times is far more efficient than compiling each time one wants to match. When option unicode is specified, the regular expression is to be specified as a valid Unicode charlist(), otherwise as any valid iodata(). Options: unicode * The regular expression is specified as a Unicode charlist() and the resulting regular expression code is to be run against a valid Unicode charlist() subject. Also consider option ucp when using Unicode characters. anchored * The pattern is forced to be &quot;anchored&quot;, that is, it is constrained to match only at the first matching point in the string that is searched (the &quot;subject string&quot;). This effect can also be achieved by appropriate constructs in the pattern itself. caseless * Letters in the pattern match both uppercase and lowercase letters. It is equivalent to Perl option /i and can be changed within a pattern by a (?i) option setting. Uppercase and lowercase letters are defined as in the ISO 8859-1 character set. dollar_endonly * A dollar metacharacter in the pattern matches only at the end of the subject string. Without this option, a dollar also matches immediately before a newline at the end of the string (but not before any other newlines). This option is ignored if option multiline is specified. There is no equivalent option in Perl, and it cannot be set within a pattern. dotall * A dot in the pattern matches all characters, including those indicating newline. Without it, a dot does not match when the current position is at a newline. This option is equivalent to Perl option /s and it can be changed within a pattern by a (?s) option setting. A negative class, such as [^a], always matches newline characters, independent of the setting of this option. extended * If this option is set, most white space characters in the pattern are totally ignored except when escaped or inside a character class. However, white space is not allowed within sequences such as (?&gt; that introduce various parenthesized subpatterns, nor within a numerical quantifier such as {1,3}. However, ignorable white space is permitted between an item and a following quantifier and between a quantifier and a following + that indicates possessiveness. White space did not used to include the VT character (code 11), because Perl did not treat this character as white space. However, Perl changed at release 5.18, so PCRE followed at release 8.34, and VT is now treated as white space. This also causes characters between an unescaped # outside a character class and the next newline, inclusive, to be ignored. This is equivalent to Perl&#39;s /x option, and it can be changed within a pattern by a (?x) option setting. With this option, comments inside complicated patterns can be included. However, notice that this applies only to data characters. Whitespace characters can never appear within special character sequences in a pattern, for example within sequence (?( that introduces a conditional subpattern. firstline * An unanchored pattern is required to match before or at the first newline in the subject string, although the matched text can continue over the newline. multiline * By default, PCRE treats the subject string as consisting of a single line of characters (even if it contains newlines). The &quot;start of line&quot; metacharacter (^) matches only at the start of the string, while the &quot;end of line&quot; metacharacter ($) matches only at the end of the string, or before a terminating newline (unless option dollar_endonly is specified). This is the same as in Perl. When this option is specified, the &quot;start of line&quot; and &quot;end of line&quot; constructs match immediately following or immediately before internal newlines in the subject string, respectively, as well as at the very start and end. This is equivalent to Perl option /m and can be changed within a pattern by a (?m) option setting. If there are no newlines in a subject string, or no occurrences of ^ or $ in a pattern, setting multiline has no effect. no_auto_capture * Disables the use of numbered capturing parentheses in the pattern. Any opening parenthesis that is not followed by ? behaves as if it is followed by ?:. Named parentheses can still be used for capturing (and they acquire numbers in the usual way). There is no equivalent option in Perl. dupnames * Names used to identify capturing subpatterns need not be unique. This can be helpful for certain types of pattern when it is known that only one instance of the named subpattern can ever be matched. More details of named subpatterns are provided below. ungreedy * Inverts the &quot;greediness&quot; of the quantifiers so that they are not greedy by default, but become greedy if followed by &quot;?&quot;. It is not compatible with Perl. It can also be set by a (?U) option setting within the pattern. {newline, NLSpec} * Overrides the default definition of a newline in the subject string, which is LF (ASCII 10) in Erlang. cr * Newline is indicated by a single character cr (ASCII 13). lf * Newline is indicated by a single character LF (ASCII 10), the default. crlf * Newline is indicated by the two-character CRLF (ASCII 13 followed by ASCII 10) sequence. anycrlf * Any of the three preceding sequences is to be recognized. any * Any of the newline sequences above, and the Unicode sequences VT (vertical tab, U+000B), FF (formfeed, U+000C), NEL (next line, U+0085), LS (line separator, U+2028), and PS (paragraph separator, U+2029). `bsr_anycrlf` * Specifies specifically that \\R is to match only the CR, LF, or CRLF sequences, not the Unicode-specific newline characters. bsr_unicode * Specifies specifically that \\R is to match all the Unicode newline characters (including CRLF, and so on, the default). no_start_optimize Disables optimization that can malfunction if &quot;Special start-of-pattern items&quot; are present in the regular expression. A typical example would be when matching &quot;DEFABC&quot; against &quot;(COMMIT)ABC&quot;, where the start optimization of PCRE would skip the subject up to &quot;A&quot; and never realize that the (*COMMIT) instruction is to have made the matching fail. This option is only relevant if you use &quot;start-of-pattern items&quot;, as discussed in section PCRE Regular Expression Details. ucp * Specifies that Unicode character properties are to be used when resolving \\B, \\b, \\D, \\d, \\S, \\s, \\W and \\w. Without this flag, only ISO Latin-1 properties are used. Using Unicode properties hurts performance, but is semantically correct when working with Unicode characters beyond the ISO Latin-1 range. never_utf Specifies that the (UTF) and/or (*UTF8) &quot;start-of-pattern items&quot; are forbidden. This flag cannot be combined with option unicode. Useful if ISO Latin-1 patterns from an external source are to be compiled."},{"ref":"re.html#inspect/2","title":"re.inspect/2","type":"function","doc":"Takes a compiled regular expression and an item, and returns the relevant data from the regular expression. The only supported item is namelist, which returns the tuple {namelist, [binary()]}, containing the names of all (unique) named subpatterns in the regular expression. For example: 1&gt; {ok,MP} = re:compile(&quot;(?&lt;A&gt;A)|(?&lt;B&gt;B)|(?&lt;C&gt;C)&quot;). {ok,{re_pattern,3,0,0, &lt;&lt;69,82,67,80,119,0,0,0,0,0,0,0,1,0,0,0,255,255,255,255, 255,255,...&gt;&gt;}} 2&gt; re:inspect(MP,namelist). {namelist,[&lt;&lt;&quot;A&quot;&gt;&gt;,&lt;&lt;&quot;B&quot;&gt;&gt;,&lt;&lt;&quot;C&quot;&gt;&gt;]} 3&gt; {ok,MPD} = re:compile(&quot;(?&lt;C&gt;A)|(?&lt;B&gt;B)|(?&lt;C&gt;C)&quot;,[dupnames]). {ok,{re_pattern,3,0,0, &lt;&lt;69,82,67,80,119,0,0,0,0,0,8,0,1,0,0,0,255,255,255,255, 255,255,...&gt;&gt;}} 4&gt; re:inspect(MPD,namelist). {namelist,[&lt;&lt;&quot;B&quot;&gt;&gt;,&lt;&lt;&quot;C&quot;&gt;&gt;]} Notice in the second example that the duplicate name only occurs once in the returned list, and that the list is in alphabetical order regardless of where the names are positioned in the regular expression. The order of the names is the same as the order of captured subexpressions if {capture, all_names} is specified as an option to run/3. You can therefore create a name-to-value mapping from the result of run/3 like this: 1&gt; {ok,MP} = re:compile(&quot;(?&lt;A&gt;A)|(?&lt;B&gt;B)|(?&lt;C&gt;C)&quot;). {ok,{re_pattern,3,0,0, &lt;&lt;69,82,67,80,119,0,0,0,0,0,0,0,1,0,0,0,255,255,255,255, 255,255,...&gt;&gt;}} 2&gt; {namelist, N} = re:inspect(MP,namelist). {namelist,[&lt;&lt;&quot;A&quot;&gt;&gt;,&lt;&lt;&quot;B&quot;&gt;&gt;,&lt;&lt;&quot;C&quot;&gt;&gt;]} 3&gt; {match,L} = re:run(&quot;AA&quot;,MP,[{capture,all_names,binary}]). {match,[&lt;&lt;&quot;A&quot;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;]} 4&gt; NameMap = lists:zip(N,L). [{&lt;&lt;&quot;A&quot;&gt;&gt;,&lt;&lt;&quot;A&quot;&gt;&gt;},{&lt;&lt;&quot;B&quot;&gt;&gt;,&lt;&lt;&gt;&gt;},{&lt;&lt;&quot;C&quot;&gt;&gt;,&lt;&lt;&gt;&gt;}]"},{"ref":"re.html#replace/3","title":"re.replace/3","type":"function","doc":"Same as replace(``Subject``, ``RE``, ``Replacement``, [])."},{"ref":"re.html#replace/4","title":"re.replace/4","type":"function","doc":"Replaces the matched part of the Subject string with the contents of Replacement. The permissible options are the same as for run/3, except that optioncapture is not allowed. Instead a {return, ``ReturnType``} is present. The default return type is iodata, constructed in a way to minimize copying. The iodata result can be used directly in many I/O operations. If a flat list() is desired, specify {return, list}. If a binary is desired, specify {return, binary}. As in function run/3, an mp() compiled with option unicode requires Subject to be a Unicode charlist(). If compilation is done implicitly and the unicode compilation option is specified to this function, both the regular expression and Subject are to specified as valid Unicode charlist()s. The replacement string can contain the special character &amp;, which inserts the whole matching expression in the result, and the special sequence \\N (where N is an integer &gt; 0), \\gN, or \\g{N}, resulting in the subexpression number N, is inserted in the result. If no subexpression with that number is generated by the regular expression, nothing is inserted. To insert an &amp; or a \\ in the result, precede it with a . Notice that Erlang already gives a special meaning to \\ in literal strings, so a single \\ must be written as &quot;\\\\&quot; and therefore a double \\ as &quot;\\\\\\\\&quot;. Example: re:replace(&quot;abcd&quot;,&quot;c&quot;,&quot;[&amp;]&quot;,[{return,list}]). gives &quot;ab[c]d&quot; while re:replace(&quot;abcd&quot;,&quot;c&quot;,&quot;[\\\\&amp;]&quot;,[{return,list}]). gives &quot;ab[&amp;]d&quot; As with run/3, compilation errors raise the badarg exception. compile/2 can be used to get more information about the error."},{"ref":"re.html#run/2","title":"re.run/2","type":"function","doc":"Same as run(``Subject``,``RE``,[])."},{"ref":"re.html#run/3","title":"re.run/3","type":"function","doc":"Executes a regular expression matching, and returns match/{match, ``Captured``} or nomatch. The regular expression can be specified either as iodata() in which case it is automatically compiled (as by compile/2) and executed, or as a precompiled mp() in which case it is executed against the subject directly. When compilation is involved, exception badarg is thrown if a compilation error occurs. Call compile/2 to get information about the location of the error in the regular expression. If the regular expression is previously compiled, the option list can only contain the following options: * `anchored` * `{capture, ``ValueSpec``}/{capture, ``ValueSpec``, ``Type``}` * `global` * `{match_limit, integer() &gt;= 0}` * `{match_limit_recursion, integer() &gt;= 0}` * `{newline, ``NLSpec``}` * `notbol` * `notempty` * `notempty_atstart` * `noteol` * `{offset, integer() &gt;= 0}` * `report_errors` Otherwise all options valid for function [`compile/2`](#compile/2) are also allowed. Options allowed both for compilation and execution of a match, namely `anchored` and `{newline, ``NLSpec``}`, affect both the compilation and execution if present together with a non-precompiled regular expression. If the regular expression was previously compiled with option unicode, Subject is to be provided as a valid Unicode charlist(), otherwise any iodata() will do. If compilation is involved and option unicode is specified, both Subject and the regular expression are to be specified as valid Unicode charlists(). {capture, ``ValueSpec``}/{capture, ``ValueSpec``, ``Type``} defines what to return from the function upon successful matching. The capture tuple can contain both a value specification, telling which of the captured substrings are to be returned, and a type specification, telling how captured substrings are to be returned (as index tuples, lists, or binaries). The options are described in detail below. If the capture options describe that no substring capturing is to be done ({capture, none}), the function returns the single atom match upon successful matching, otherwise the tuple {match, ``ValueList``}. Disabling capturing can be done either by specifying none or an empty list as ValueSpec. Option report_errors adds the possibility that an error tuple is returned. The tuple either indicates a matching error (match_limit or match_limit_recursion), or a compilation error, where the error tuple has the format {error, {compile, ``CompileErr``}}. Notice that if option report_errors is not specified, the function never returns error tuples, but reports compilation errors as a badarg exception and failed matches because of exceeded match limits simply as nomatch. The following options are relevant for execution: anchored * Limits run/3 to matching at the first matching position. If a pattern was compiled with anchored, or turned out to be anchored by virtue of its contents, it cannot be made unanchored at matching time, hence there is no unanchored option. global * Implements global (repetitive) search (flag g in Perl). Each match is returned as a separate list() containing the specific match and any matching subexpressions (or as specified by option capture. The Captured part of the return value is hence a list() of list()s when this option is specified. The interaction of option global with a regular expression that matches an empty string surprises some users. When option global is specified, run/3 handles empty matches in the same way as Perl: a zero-length match at any point is also retried with options [anchored, notempty_atstart]. If that search gives a result of length &gt; 0, the result is included. Example: re:run(&quot;cat&quot;,&quot;(|at)&quot;,[global]). The following matchings are performed: At offset 0 * The regular expression (|at) first match at the initial position of string cat, giving the result set [{0,0},{0,0}] (the second {0,0} is because of the subexpression marked by the parentheses). As the length of the match is 0, we do not advance to the next position yet. At offset 0 with [anchored, notempty_atstart] * The search is retried with options [anchored, notempty_atstart] at the same position, which does not give any interesting result of longer length, so the search position is advanced to the next character (a). At offset 1 * The search results in [{1,0},{1,0}], so this search is also repeated with the extra options. At offset 1 with [anchored, notempty_atstart] * Alternative ab is found and the result is [{1,2},{1,2}]. The result is added to the list of results and the position in the search string is advanced two steps. At offset 3 * The search once again matches the empty string, giving [{3,0},{3,0}]. At offset 1 with [anchored, notempty_atstart] * This gives no result of length &gt; 0 and we are at the last position, so the global search is complete. The result of the call is: {match,[[{0,0},{0,0}],[{1,0},{1,0}],[{1,2},{1,2}],[{3,0},{3,0}]]} notempty * An empty string is not considered to be a valid match if this option is specified. If alternatives in the pattern exist, they are tried. If all the alternatives match the empty string, the entire match fails. Example: If the following pattern is applied to a string not beginning with &quot;a&quot; or &quot;b&quot;, it would normally match the empty string at the start of the subject: a?b? With option notempty, this match is invalid, so run/3 searches further into the string for occurrences of &quot;a&quot; or &quot;b&quot;. notempty_atstart * Like notempty, except that an empty string match that is not at the start of the subject is permitted. If the pattern is anchored, such a match can occur only if the pattern contains \\K. Perl has no direct equivalent of notempty or notempty_atstart, but it does make a special case of a pattern match of the empty string within its split() function, and when using modifier /g. The Perl behavior can be emulated after matching a null string by first trying the match again at the same offset with notempty_atstart and anchored, and then, if that fails, by advancing the starting offset (see below) and trying an ordinary match again. notbol * Specifies that the first character of the subject string is not the beginning of a line, so the circumflex metacharacter is not to match before it. Setting this without multiline (at compile time) causes circumflex never to match. This option only affects the behavior of the circumflex metacharacter. It does not affect \\A. noteol * Specifies that the end of the subject string is not the end of a line, so the dollar metacharacter is not to match it nor (except in multiline mode) a newline immediately before it. Setting this without multiline (at compile time) causes dollar never to match. This option affects only the behavior of the dollar metacharacter. It does not affect \\Z or \\z. report_errors * Gives better control of the error handling in run/3. When specified, compilation errors (if the regular expression is not already compiled) and runtime errors are explicitly returned as an error tuple. The following are the possible runtime errors: match_limit * The PCRE library sets a limit on how many times the internal match function can be called. Defaults to 10,000,000 in the library compiled for Erlang. If {error, match_limit} is returned, the execution of the regular expression has reached this limit. This is normally to be regarded as a nomatch, which is the default return value when this occurs, but by specifying report_errors, you are informed when the match fails because of too many internal calls. match_limit_recursion * This error is very similar to match_limit, but occurs when the internal match function of PCRE is &quot;recursively&quot; called more times than the match_limit_recursion limit, which defaults to 10,000,000 as well. Notice that as long as the match_limit and match_limit_default values are kept at the default values, the match_limit_recursion error cannot occur, as the match_limit error occurs before that (each recursive call is also a call, but not conversely). Both limits can however be changed, either by setting limits directly in the regular expression string (see section PCRE Regular Eexpression Details) or by specifying options to run/3. It is important to understand that what is referred to as &quot;recursion&quot; when limiting matches is not recursion on the C stack of the Erlang machine or on the Erlang process stack. The PCRE version compiled into the Erlang VM uses machine &quot;heap&quot; memory to store values that must be kept over recursion in regular expression matches. {match_limit, integer() &gt;= 0} * Limits the execution time of a match in an implementation-specific way. It is described as follows by the PCRE documentation: The match_limit field provides a means of preventing PCRE from using up a vast amount of resources when running patterns that are not going to match, but which have a very large number of possibilities in their search trees. The classic example is a pattern that uses nested unlimited repeats. Internally, pcre_exec() uses a function called match(), which it calls repeatedly (sometimes recursively). The limit set by match_limit is imposed on the number of times this function is called during a match, which has the effect of limiting the amount of backtracking that can take place. For patterns that are not anchored, the count restarts from zero for each position in the subject string. This means that runaway regular expression matches can fail faster if the limit is lowered using this option. The default value 10,000,000 is compiled into the Erlang VM. This option does in no way affect the execution of the Erlang VM in terms of &quot;long running BIFs&quot;. run/3 always gives control back to the scheduler of Erlang processes at intervals that ensures the real-time properties of the Erlang system. {match_limit_recursion, integer() &gt;= 0} * Limits the execution time and memory consumption of a match in an implementation-specific way, very similar to match_limit. It is described as follows by the PCRE documentation: The match_limit_recursion field is similar to match_limit, but instead of limiting the total number of times that match() is called, it limits the depth of recursion. The recursion depth is a smaller number than the total number of calls, because not all calls to match() are recursive. This limit is of use only if it is set smaller than match_limit. Limiting the recursion depth limits the amount of machine stack that can be used, or, when PCRE has been compiled to use memory on the heap instead of the stack, the amount of heap memory that can be used. The Erlang VM uses a PCRE library where heap memory is used when regular expression match recursion occurs. This therefore limits the use of machine heap, not C stack. Specifying a lower value can result in matches with deep recursion failing, when they should have matched: 1&gt; re:run(&quot;aaaaaaaaaaaaaz&quot;,&quot;(a+)*z&quot;). {match,[{0,14},{0,13}]} 2&gt; re:run(&quot;aaaaaaaaaaaaaz&quot;,&quot;(a+)*z&quot;,[{match_limit_recursion,5}]). nomatch 3&gt; re:run(&quot;aaaaaaaaaaaaaz&quot;,&quot;(a+)*z&quot;,[{match_limit_recursion,5},report_errors]). {error,match_limit_recursion} This option and option match_limit are only to be used in rare cases. Understanding of the PCRE library internals is recommended before tampering with these limits. {offset, integer() &gt;= 0} * Start matching at the offset (position) specified in the subject string. The offset is zero-based, so that the default is {offset,0} (all of the subject string). {newline, ``NLSpec``} * Overrides the default definition of a newline in the subject string, which is LF (ASCII 10) in Erlang. cr * Newline is indicated by a single character CR (ASCII 13). lf * Newline is indicated by a single character LF (ASCII 10), the default. crlf * Newline is indicated by the two-character CRLF (ASCII 13 followed by ASCII 10) sequence. anycrlf * Any of the three preceding sequences is be recognized. any * Any of the newline sequences above, and the Unicode sequences VT (vertical tab, U+000B), FF (formfeed, U+000C), NEL (next line, U+0085), LS (line separator, U+2028), and PS (paragraph separator, U+2029). `bsr_anycrlf` * Specifies specifically that \\R is to match only the CR LF, or CRLF sequences, not the Unicode-specific newline characters. (Overrides the compilation option.) bsr_unicode * Specifies specifically that \\R is to match all the Unicode newline characters (including CRLF, and so on, the default). (Overrides the compilation option.) {capture, ``ValueSpec``}/{capture, ``ValueSpec``, ``Type``} * Specifies which captured substrings are returned and in what format. By default, run/3 captures all of the matching part of the substring and all capturing subpatterns (all of the pattern is automatically captured). The default return type is (zero-based) indexes of the captured parts of the string, specified as {Offset,Length} pairs (the index Type of capturing). As an example of the default behavior, the following call returns, as first and only captured string, the matching part of the subject (&quot;abcd&quot; in the middle) as an index pair {3,4}, where character positions are zero-based, just as in offsets: re:run(&quot;ABCabcdABC&quot;,&quot;abcd&quot;,[]). The return value of this call is: {match,[{3,4}]} Another (and quite common) case is where the regular expression matches all of the subject: re:run(&quot;ABCabcdABC&quot;,&quot;.*abcd.*&quot;,[]). Here the return value correspondingly points out all of the string, beginning at index 0, and it is 10 characters long: {match,[{0,10}]} If the regular expression contains capturing subpatterns, like in: re:run(&quot;ABCabcdABC&quot;,&quot;.*(abcd).*&quot;,[]). all of the matched subject is captured, as well as the captured substrings: {match,[{0,10},{3,4}]} The complete matching pattern always gives the first return value in the list and the remaining subpatterns are added in the order they occurred in the regular expression. The capture tuple is built up as follows: ValueSpec * Specifies which captured (sub)patterns are to be returned. ValueSpec can either be an atom describing a predefined set of return values, or a list containing the indexes or the names of specific subpatterns to return. The following are the predefined sets of subpatterns: all * All captured subpatterns including the complete matching string. This is the default. all_names * All named subpatterns in the regular expression, as if a list() of all the names in alphabetical order was specified. The list of all names can also be retrieved with inspect/2. first * Only the first captured subpattern, which is always the complete matching part of the subject. All explicitly captured subpatterns are discarded. all_but_first * All but the first matching subpattern, that is, all explicitly captured subpatterns, but not the complete matching part of the subject string. This is useful if the regular expression as a whole matches a large part of the subject, but the part you are interested in is in an explicitly captured subpattern. If the return type is list or binary, not returning subpatterns you are not interested in is a good way to optimize. none * Returns no matching subpatterns, gives the single atom match as the return value of the function when matching successfully instead of the {match, list()} return. Specifying an empty list gives the same behavior. The value list is a list of indexes for the subpatterns to return, where index 0 is for all of the pattern, and 1 is for the first explicit capturing subpattern in the regular expression, and so on. When using named captured subpatterns (see below) in the regular expression, one can use atom()s or string()s to specify the subpatterns to be returned. For example, consider the regular expression: &quot;.*(abcd).*&quot; matched against string &quot;ABCabcdABC&quot;, capturing only the &quot;abcd&quot; part (the first explicit subpattern): re:run(&quot;ABCabcdABC&quot;,&quot;.*(abcd).*&quot;,[{capture,[1]}]). The call gives the following result, as the first explicitly captured subpattern is &quot;(abcd)&quot;, matching &quot;abcd&quot; in the subject, at (zero-based) position 3, of length 4: {match,[{3,4}]} Consider the same regular expression, but with the subpattern explicitly named &#39;FOO&#39;: &quot;.*(?&lt;FOO&gt;abcd).*&quot; With this expression, we could still give the index of the subpattern with the following call: re:run(&quot;ABCabcdABC&quot;,&quot;.*(?&lt;FOO&gt;abcd).*&quot;,[{capture,[1]}]). giving the same result as before. But, as the subpattern is named, we can also specify its name in the value list: re:run(&quot;ABCabcdABC&quot;,&quot;.*(?&lt;FOO&gt;abcd).*&quot;,[{capture,[&#39;FOO&#39;]}]). This would give the same result as the earlier examples, namely: {match,[{3,4}]} The values list can specify indexes or names not present in the regular expression, in which case the return values vary depending on the type. If the type is index, the tuple {-1,0} is returned for values with no corresponding subpattern in the regular expression, but for the other types (binary and list), the values are the empty binary or list, respectively. Type * Optionally specifies how captured substrings are to be returned. If omitted, the default of index is used. Type can be one of the following: index * Returns captured substrings as pairs of byte indexes into the subject string and length of the matching string in the subject (as if the subject string was flattened with erlang:iolist_to_binary/1 or unicode:characters_to_binary/2 before matching). Notice that option unicode results in byte-oriented indexes in a (possibly virtual) UTF-8 encoded binary. A byte index tuple {0,2} can therefore represent one or two characters when unicode is in effect. This can seem counter-intuitive, but has been deemed the most effective and useful way to do it. To return lists instead can result in simpler code if that is desired. This return type is the default. list * Returns matching substrings as lists of characters (Erlang string()s). It option unicode is used in combination with the \\C sequence in the regular expression, a captured subpattern can contain bytes that are not valid UTF-8 (\\C matches bytes regardless of character encoding). In that case the list capturing can result in the same types of tuples that unicode:characters_to_list/2 can return, namely three-tuples with tag incomplete or error, the successfully converted characters and the invalid UTF-8 tail of the conversion as a binary. The best strategy is to avoid using the \\C sequence when capturing lists. binary * Returns matching substrings as binaries. If option unicode is used, these binaries are in UTF-8. If the \\C sequence is used together with unicode, the binaries can be invalid UTF-8. In general, subpatterns that were not assigned a value in the match are returned as the tuple `{-1,0}` when `type` is `index`. Unassigned subpatterns are returned as the empty binary or list, respectively, for other return types. Consider the following regular expression: &quot;.*((?&lt;FOO&gt;abdd)|a(..d)).*&quot; There are three explicitly capturing subpatterns, where the opening parenthesis position determines the order in the result, hence ((?&lt;FOO&gt;abdd)|a(..d)) is subpattern index 1, (?&lt;FOO&gt;abdd) is subpattern index 2, and (..d) is subpattern index 3. When matched against the following string: &quot;ABCabcdABC&quot; the subpattern at index 2 does not match, as &quot;abdd&quot; is not present in the string, but the complete pattern matches (because of the alternative a(..d)). The subpattern at index 2 is therefore unassigned and the default return value is: {match,[{0,10},{3,4},{-1,0},{4,3}]} Setting the capture Type to binary gives: {match,[&lt;&lt;&quot;ABCabcdABC&quot;&gt;&gt;,&lt;&lt;&quot;abcd&quot;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&quot;bcd&quot;&gt;&gt;]} Here the empty binary (&lt;&lt;&gt;&gt;) represents the unassigned subpattern. In the binary case, some information about the matching is therefore lost, as &lt;&lt;&gt;&gt; can also be an empty string captured. If differentiation between empty matches and non-existing subpatterns is necessary, use the type index and do the conversion to the final type in Erlang code. When option global is speciified, the capture specification affects each match separately, so that: re:run(&quot;cacb&quot;,&quot;c(a|b)&quot;,[global,{capture,[1],list}]). gives {match,[[&quot;a&quot;],[&quot;b&quot;]]} For a descriptions of options only affecting the compilation step, see compile/2."},{"ref":"re.html#split/2","title":"re.split/2","type":"function","doc":"Same as split(``Subject``, ``RE``, [])."},{"ref":"re.html#split/3","title":"re.split/3","type":"function","doc":"Splits the input into parts by finding tokens according to the regular expression supplied. The splitting is basically done by running a global regular expression match and dividing the initial string wherever a match occurs. The matching part of the string is removed from the output. As in run/3, an mp() compiled with option unicode requires Subject to be a Unicode charlist(). If compilation is done implicitly and the unicode compilation option is specified to this function, both the regular expression and Subject are to be specified as valid Unicode charlist()s. The result is given as a list of &quot;strings&quot;, the preferred data type specified in option return (default iodata). If subexpressions are specified in the regular expression, the matching subexpressions are returned in the resulting list as well. For example: re:split(&quot;Erlang&quot;,&quot;[ln]&quot;,[{return,list}]). gives [&quot;Er&quot;,&quot;a&quot;,&quot;g&quot;] while re:split(&quot;Erlang&quot;,&quot;([ln])&quot;,[{return,list}]). gives [&quot;Er&quot;,&quot;l&quot;,&quot;a&quot;,&quot;n&quot;,&quot;g&quot;] The text matching the subexpression (marked by the parentheses in the regular expression) is inserted in the result list where it was found. This means that concatenating the result of a split where the whole regular expression is a single subexpression (as in the last example) always results in the original string. As there is no matching subexpression for the last part in the example (the &quot;g&quot;), nothing is inserted after that. To make the group of strings and the parts matching the subexpressions more obvious, one can use option group, which groups together the part of the subject string with the parts matching the subexpressions when the string was split: re:split(&quot;Erlang&quot;,&quot;([ln])&quot;,[{return,list},group]). gives [[&quot;Er&quot;,&quot;l&quot;],[&quot;a&quot;,&quot;n&quot;],[&quot;g&quot;]] Here the regular expression first matched the &quot;l&quot;, causing &quot;Er&quot; to be the first part in the result. When the regular expression matched, the (only) subexpression was bound to the &quot;l&quot;, so the &quot;l&quot; is inserted in the group together with &quot;Er&quot;. The next match is of the &quot;n&quot;, making &quot;a&quot; the next part to be returned. As the subexpression is bound to substring &quot;n&quot; in this case, the &quot;n&quot; is inserted into this group. The last group consists of the remaining string, as no more matches are found. By default, all parts of the string, including the empty strings, are returned from the function, for example: re:split(&quot;Erlang&quot;,&quot;[lg]&quot;,[{return,list}]). gives [&quot;Er&quot;,&quot;an&quot;,[]] as the matching of the &quot;g&quot; in the end of the string leaves an empty rest, which is also returned. This behavior differs from the default behavior of the split function in Perl, where empty strings at the end are by default removed. To get the &quot;trimming&quot; default behavior of Perl, specify trim as an option: re:split(&quot;Erlang&quot;,&quot;[lg]&quot;,[{return,list},trim]). gives [&quot;Er&quot;,&quot;an&quot;] The &quot;trim&quot; option says; &quot;give me as many parts as possible except the empty ones&quot;, which sometimes can be useful. You can also specify how many parts you want, by specifying {parts,N}: re:split(&quot;Erlang&quot;,&quot;[lg]&quot;,[{return,list},{parts,2}]). gives [&quot;Er&quot;,&quot;ang&quot;] Notice that the last part is &quot;ang&quot;, not &quot;an&quot;, as splitting was specified into two parts, and the splitting stops when enough parts are given, which is why the result differs from that of trim. More than three parts are not possible with this indata, so re:split(&quot;Erlang&quot;,&quot;[lg]&quot;,[{return,list},{parts,4}]). gives the same result as the default, which is to be viewed as &quot;an infinite number of parts&quot;. Specifying 0 as the number of parts gives the same effect as option trim. If subexpressions are captured, empty subexpressions matched at the end are also stripped from the result if trim or {parts,0} is specified. The trim behavior corresponds exactly to the Perl default. {parts,N}, where N is a positive integer, corresponds exactly to the Perl behavior with a positive numerical third parameter. The default behavior of split/3 corresponds to the Perl behavior when a negative integer is specified as the third parameter for the Perl routine. Summary of options not previously described for function run/3: {return,``ReturnType``} * Specifies how the parts of the original string are presented in the result list. Valid types: iodata * The variant of iodata() that gives the least copying of data with the current implementation (often a binary, but do not depend on it). binary * All parts returned as binaries. list * All parts returned as lists of characters (&quot;strings&quot;). `group` * Groups together the part of the string with the parts of the string matching the subexpressions of the regular expression. The return value from the function is in this case a list() of list()s. Each sublist begins with the string picked out of the subject string, followed by the parts matching each of the subexpressions in order of occurrence in the regular expression. {parts,N} * Specifies the number of parts the subject string is to be split into. The number of parts is to be a positive integer for a specific maximum number of parts, and infinity for the maximum number of parts possible (the default). Specifying {parts,0} gives as many parts as possible disregarding empty parts at the end, the same as specifying trim. trim * Specifies that empty parts at the end of the result list are to be disregarded. The same as specifying {parts,0}. This corresponds to the default behavior of the split built-in function in Perl."},{"ref":"re.html#version/0","title":"re.version/0","type":"function","doc":"The return of this function is a string with the PCRE version of the system that was used in the Erlang/OTP compilation."},{"ref":"sets.html","title":"sets","type":"module","doc":"Sets are collections of elements with no duplicate elements. The representation of a set is undefined. This module provides the same interface as the ordsets(3) module but with an undefined representation. One difference is that while this module considers two elements as different if they do not match (=:=), ordsets considers two elements as different if and only if they do not compare equal (==)."},{"ref":"sets.html#add_element/2","title":"sets.add_element/2","type":"function","doc":"Returns a new set formed from Set1 with Element inserted."},{"ref":"sets.html#del_element/2","title":"sets.del_element/2","type":"function","doc":"Returns Set1, but with Element removed."},{"ref":"sets.html#filter/2","title":"sets.filter/2","type":"function","doc":"Filters elements in Set1 with boolean function Pred."},{"ref":"sets.html#fold/3","title":"sets.fold/3","type":"function","doc":"Folds Function over every element in Set and returns the final value of the accumulator. The evaluation order is undefined."},{"ref":"sets.html#from_list/1","title":"sets.from_list/1","type":"function","doc":"Returns a set of the elements in List."},{"ref":"sets.html#intersection/1","title":"sets.intersection/1","type":"function","doc":"Returns the intersection of the non-empty list of sets."},{"ref":"sets.html#intersection/2","title":"sets.intersection/2","type":"function","doc":"Returns the intersection of Set1 and Set2."},{"ref":"sets.html#is_disjoint/2","title":"sets.is_disjoint/2","type":"function","doc":"Returns true if Set1 and Set2 are disjoint (have no elements in common), otherwise false."},{"ref":"sets.html#is_element/2","title":"sets.is_element/2","type":"function","doc":"Returns true if Element is an element of Set, otherwise false."},{"ref":"sets.html#is_empty/1","title":"sets.is_empty/1","type":"function","doc":"Returns true if Set is an empty set, otherwise false."},{"ref":"sets.html#is_set/1","title":"sets.is_set/1","type":"function","doc":"Returns true if Set is a set of elements, otherwise false."},{"ref":"sets.html#is_subset/2","title":"sets.is_subset/2","type":"function","doc":"Returns true when every element of Set1 is also a member of Set2, otherwise false."},{"ref":"sets.html#new/0","title":"sets.new/0","type":"function","doc":"Returns a new empty set."},{"ref":"sets.html#size/1","title":"sets.size/1","type":"function","doc":"Returns the number of elements in Set."},{"ref":"sets.html#subtract/2","title":"sets.subtract/2","type":"function","doc":"Returns only the elements of Set1 that are not also elements of Set2."},{"ref":"sets.html#to_list/1","title":"sets.to_list/1","type":"function","doc":"Returns the elements of Set as a list. The order of the returned elements is undefined."},{"ref":"sets.html#union/1","title":"sets.union/1","type":"function","doc":"Returns the merged (union) set of the list of sets."},{"ref":"sets.html#union/2","title":"sets.union/2","type":"function","doc":"Returns the merged (union) set of Set1 and Set2."},{"ref":"shell.html","title":"shell","type":"module","doc":"This module provides an Erlang shell. The shell is a user interface program for entering expression sequences. The expressions are evaluated and a value is returned. A history mechanism saves previous commands and their values, which can then be incorporated in later commands. How many commands and results to save can be determined by the user, either interactively, by calling history/1 and results/1, or by setting the application configuration parameters shell_history_length and shell_saved_results for the STDLIB application. The shell uses a helper process for evaluating commands to protect the history mechanism from exceptions. By default the evaluator process is killed when an exception occurs, but by calling catch_exception/1 or by setting the application configuration parameter shell_catch_exception for the STDLIB application this behavior can be changed. See also the example below. Variable bindings, and local process dictionary changes that are generated in user expressions are preserved, and the variables can be used in later commands to access their values. The bindings can also be forgotten so the variables can be reused. The special shell commands all have the syntax of (local) function calls. They are evaluated as normal function calls and many commands can be used in one expression sequence. If a command (local function call) is not recognized by the shell, an attempt is first made to find the function in module user_default, where customized local commands can be placed. If found, the function is evaluated, otherwise an attempt is made to evaluate the function in module shell_default. Module user_default must be explicitly loaded. The shell also permits the user to start multiple concurrent jobs. A job can be regarded as a set of processes that can communicate with the shell. There is some support for reading and printing records in the shell. During compilation record expressions are translated to tuple expressions. In runtime it is not known whether a tuple represents a record, and the record definitions used by the compiler are unavailable at runtime. So, to read the record syntax and print tuples as records when possible, record definitions must be maintained by the shell itself. The shell commands for reading, defining, forgetting, listing, and printing records are described below. Notice that each job has its own set of record definitions. To facilitate matters, record definitions in modules shell_default and user_default (if loaded) are read each time a new job is started. For example, adding the following line to user_default makes the definition of file_info readily available in the shell: -include_lib(&quot;kernel/include/file.hrl&quot;). The shell runs in two modes: * `Normal (possibly restricted)` mode, in which commands can be edited and expressions evaluated * Job Control Mode, `JCL`, in which jobs can be started, killed, detached, and connected Only the currently connected job can &#39;talk&#39; to the shell."},{"ref":"shell.html#history/1","title":"shell.history/1","type":"function","doc":"Sets the number of previous commands to keep in the history list to N. The previous number is returned. Defaults to 20."},{"ref":"shell.html#prompt_func/1","title":"shell.prompt_func/1","type":"function","doc":"Sets the shell prompt function to PromptFunc. The previous prompt function is returned."},{"ref":"shell.html#results/1","title":"shell.results/1","type":"function","doc":"Sets the number of results from previous commands to keep in the history list to N. The previous number is returned. Defaults to 20."},{"ref":"shell.html#start_restricted/1","title":"shell.start_restricted/1","type":"function","doc":"Exits a normal shell and starts a restricted shell. Module specifies the callback module for the functions local_allowed/3 and non_local_allowed/3. The function is meant to be called from the shell. If the callback module cannot be loaded, an error tuple is returned. The Reason in the error tuple is the one returned by the code loader when trying to load the code of the callback module."},{"ref":"shell.html#stop_restricted/0","title":"shell.stop_restricted/0","type":"function","doc":"Exits a restricted shell and starts a normal shell. The function is meant to be called from the shell."},{"ref":"shell.html#strings/1","title":"shell.strings/1","type":"function","doc":"Sets pretty printing of lists to Strings. The previous value of the flag is returned. The flag can also be set by the STDLIB application variable shell_strings. Defaults to true, which means that lists of integers are printed using the string syntax, when possible. Value false means that no lists are printed using the string syntax."},{"ref":"shell_default.html","title":"shell_default","type":"module","doc":"The functions in this module are called when no module name is specified in a shell command. Consider the following shell dialog: 1&gt; lists:reverse(&quot;abc&quot;). &quot;cba&quot; 2&gt; c(foo). {ok, foo} In command one, module lists is called. In command two, no module name is specified. The shell searches module user_default followed by module shell_default for function c/1. shell_default is intended for &quot;system wide&quot; customizations to the shell. user_default is intended for &quot;local&quot; or individual user customizations."},{"ref":"slave.html","title":"slave","type":"module","doc":"This module provides functions for starting Erlang slave nodes. All slave nodes that are started by a master terminate automatically when the master terminates. All terminal output produced at the slave is sent back to the master node. File I/O is done through the master. Slave nodes on other hosts than the current one are started with the ssh program. The user must be allowed to ssh to the remote hosts without being prompted for a password. This can be arranged in a number of ways (for details, see the ssh documentation). A slave node started on the same host as the master inherits certain environment values from the master, such as the current directory and the environment variables. For what can be assumed about the environment when a slave is started on another host, see the documentation for the ssh program. An alternative to the ssh program can be specified on the command line to erl(1) as follows: -rsh Program Note that the command specified with the -rsh flag is treated as a file name which may contain spaces. It is thus not possible to include any command line options. The remote node will be launched as &quot;$RSH&quot; &quot;$REMOTE_HOSTNAME&quot; erl -detached -noinput ..., so the erl command must be found in the path on the remote host. The slave node is to use the same file system at the master. At least, Erlang/OTP is to be installed in the same place on both computers and the same version of Erlang is to be used. A node running on Windows can only start slave nodes on the host on which it is running. The master node must be alive."},{"ref":"slave.html#pseudo/2","title":"slave.pseudo/2","type":"function","doc":"Starts a number of pseudo servers. A pseudo server is a server with a registered name that does nothing but pass on all message to the real server that executes at a master node. A pseudo server is an intermediary that only has the same registered name as the real server. For example, if you have started a slave node N and want to execute pxw graphics code on this node, you can start server pxw_server as a pseudo server at the slave node. This is illustrated as follows: rpc:call(N, slave, pseudo, [node(), [pxw_server]])."},{"ref":"slave.html#relay/1","title":"slave.relay/1","type":"function","doc":"Runs a pseudo server. This function never returns any value and the process that executes the function receives messages. All messages received are simply passed on to Pid."},{"ref":"slave.html#start_linkstart_linkstart_link/123","title":"slave.start_linkstart_linkstart_link/123","type":"function","doc":"Starts a slave node in the same way as start/1,2,3, except that the slave node is linked to the currently executing process. If that process terminates, the slave node also terminates. For a description of arguments and return values, see start/1,2,3."},{"ref":"slave.html#startstartstart/123","title":"slave.startstartstart/123","type":"function","doc":"Starts a slave node on host Host. Host names need not necessarily be specified as fully qualified names; short names can also be used. This is the same condition that applies to names of distributed Erlang nodes. The name of the started node becomes Name``@``Host. If no name is provided, the name becomes the same as the node that executes the call (except the host name part of the node name). The slave node resets its user process so that all terminal I/O that is produced at the slave is automatically relayed to the master. Also, the file process is relayed to the master. Argument Args is used to set erl command-line arguments. If provided, it is passed to the new node and can be used for a variety of purposes; see erl(1). As an example, suppose that you want to start a slave node at host H with node name Name@H and want the slave node to have the following properties: * Directory `Dir` is to be added to the code path. * The Mnesia directory is to be set to `M`. * The Unix `DISPLAY` environment variable is to be set to the display of the master node. The following code is executed to achieve this: E = &quot; -env DISPLAY &quot; ++ net_adm:localhost() ++ &quot;:0 &quot;, Arg = &quot;-mnesia_dir &quot; ++ M ++ &quot; -pa &quot; ++ Dir ++ E, slave:start(H, Name, Arg). The function returns {ok, ``Node``}, where Node is the name of the new node, otherwise {error, ``Reason``}, where Reason can be one of: timeout * The master node failed to get in contact with the slave node. This can occur in a number of circumstances: * Erlang/OTP is not installed on the remote host. * The file system on the other host has a different structure to the the master. * The Erlang nodes have different cookies. `no_rsh` * No remote shell program was found on the computer. Note that `ssh` is used by default, but this can be overridden with the `-rsh` flag. {already_running, ``Node``} * A node with name Name``@``Host already exists."},{"ref":"slave.html#stop/1","title":"slave.stop/1","type":"function","doc":"Stops (kills) a node."},{"ref":"sofs.html","title":"sofs","type":"module","doc":"This module provides operations on finite sets and relations represented as sets. Intuitively, a set is a collection of elements; every element belongs to the set, and the set contains every element. Given a set A and a sentence S(x), where x is a free variable, a new set B whose elements are exactly those elements of A for which S(x) holds can be formed, this is denoted B= {xinA: S(x)}. Sentences are expressed using the logical operators &quot;for some&quot; (or &quot;there exists&quot;), &quot;for all&quot;, &quot;and&quot;, &quot;or&quot;, &quot;not&quot;. If the existence of a set containing all the specified elements is known (as is always the case in this module), this is denoted B= {x: S(x)}. * The unordered set containing the elements a, b, and c is denoted {a,b,c}. This notation is not to be confused with tuples. The ordered pair of a and b, with first coordinate a and second coordinate b, is denoted (a,b). An ordered pair is an ordered set of two elements. In this module, ordered sets can contain one, two, or more elements, and parentheses are used to enclose the elements. Unordered sets and ordered sets are orthogonal, again in this module; there is no unordered set equal to any ordered set. * The empty set contains no elements. Set A is equal to set B if they contain the same elements, which is denoted A=B. Two ordered sets are equal if they contain the same number of elements and have equal elements at each coordinate. Set B is a subset of set A if A contains all elements that B contains. The union of two sets A and B is the smallest set that contains all elements of A and all elements of B. The intersection of two sets A and B is the set that contains all elements of A that belong to B. Two sets are disjoint if their intersection is the empty set. The difference of two sets A and B is the set that contains all elements of A that do not belong to B. The symmetric difference of two sets is the set that contains those element that belong to either of the two sets, but not both. The union of a collection of sets is the smallest set that contains all the elements that belong to at least one set of the collection. The intersection of a non-empty collection of sets is the set that contains all elements that belong to every set of the collection. * The Cartesian product of two sets X and Y, denoted XY, is the set {a: a= (x,y) for some xinX and for some yinY}. A relation is a subset of XY. Let R be a relation. The fact that (x,y) belongs to R is written as xRy. As relations are sets, the definitions of the last item (subset, union, and so on) apply to relations as well. The domain of R is the set {x: xRy for some yinY}. The range of R is the set {y: xRy for some xinX}. The converse of R is the set {a: a= (y,x) for some (x,y)inR}. If A is a subset of X, the image of A under R is the set {y: xRy for some xinA}. If B is a subset of Y, the inverse image of B is the set {x: xRy for some yinB}. If R is a relation from X to Y, and S is a relation from Y to Z, the relative product of R and S is the relation T from X to Z defined so that xTz if and only if there exists an element y in Y such that xRy and ySz. The restriction of R to A is the set S defined so that xSy if and only if there exists an element x in A such that xRy. If S is a restriction of R to A, then R is an extension of S to X. If X=Y, then R is called a relation in X. The field of a relation R in X is the union of the domain of R and the range of R. If R is a relation in X, and if S is defined so that xSy if xRy and not x=y, then S is the strict relation corresponding to R. Conversely, if S is a relation in X, and if R is defined so that xRy if xSy or x=y, then R is the weak relation corresponding to S. A relation R in X is reflexive if xRx for every element x of X, it is symmetric if xRy implies that yRx, and it is transitive if xRy and yRz imply that xRz. * A function F is a relation, a subset of XY, such that the domain of F is equal to X and such that for every x in X there is a unique element y in Y with (x,y) in F. The latter condition can be formulated as follows: if xFy and xFz, then y=z. In this module, it is not required that the domain of F is equal to X for a relation to be considered a function. Instead of writing (x,y)inF or xFy, we write F(x)=y when F is a function, and say that F maps x onto y, or that the value of F at x is y. As functions are relations, the definitions of the last item (domain, range, and so on) apply to functions as well. If the converse of a function F is a function F&#39;, then F&#39; is called the inverse of F. The relative product of two functions F1 and F2 is called the composite of F1 and F2 if the range of F1 is a subset of the domain of F2. * Sometimes, when the range of a function is more important than the function itself, the function is called a family. The domain of a family is called the index set, and the range is called the indexed set. If x is a family from I to X, then x[i] denotes the value of the function at index i. The notation &quot;a family in X&quot; is used for such a family. When the indexed set is a set of subsets of a set X, we call x a family of subsets of X. If x is a family of subsets of X, the union of the range of x is called the union of the family x. If x is non-empty (the index set is non-empty), the intersection of the family x is the intersection of the range of x. In this module, the only families that are considered are families of subsets of some set X; in the following, the word &quot;family&quot; is used for such families of subsets. * A partition of a set X is a collection S of non-empty subsets of X whose union is X and whose elements are pairwise disjoint. A relation in a set is an equivalence relation if it is reflexive, symmetric, and transitive. If R is an equivalence relation in X, and x is an element of X, the equivalence class of x with respect to R is the set of all those elements y of X for which xRy holds. The equivalence classes constitute a partitioning of X. Conversely, if C is a partition of X, the relation that holds for any two elements of X if they belong to the same equivalence class, is an equivalence relation induced by the partition C. If R is an equivalence relation in X, the canonical map is the function that maps every element of X onto its equivalence class. * Relations as defined above (as sets of ordered pairs) are from now on referred to as binary relations. We call a set of ordered sets (x[1],...,x[n]) an (n-ary) relation, and say that the relation is a subset of the Cartesian product X[1]...X[n], where x[i] is an element of X[i], 1&lt;=i&lt;=n. The projection of an n-ary relation R onto coordinate i is the set {x[i]: (x[1],...,x[i],...,x[n]) in R for some x[j]inX[j], 1&lt;=j&lt;=n and not i=j}. The projections of a binary relation R onto the first and second coordinates are the domain and the range of R, respectively. The relative product of binary relations can be generalized to n-ary relations as follows. Let TR be an ordered set (R[1],...,R[n]) of binary relations from X to Y[i] and S a binary relation from (Y[1]...Y[n]) to Z. The relative product of TR and S is the binary relation T from X to Z defined so that xTz if and only if there exists an element y[i] in Y[i] for each 1&lt;=i&lt;=n such that xR[i]y[i] and (y[1],...,y[n])Sz. Now let TR be a an ordered set (R[1],...,R[n]) of binary relations from X[i] to Y[i] and S a subset of X[1]...X[n]. The multiple relative product of TR and S is defined to be the set {z: z= ((x[1],...,x[n]), (y[1],...,y[n])) for some (x[1],...,x[n])inS and for some (x[i],y[i]) in R[i], 1&lt;=i&lt;=n}. The natural join of an n-ary relation R and an m-ary relation S on coordinate i and j is defined to be the set {z: z= (x[1],...,x[n], y[1],...,y[j-1],y[j+1],...,y[m]) for some (x[1],...,x[n])inR and for some (y[1],...,y[m])inS such that x[i]=y[j]}. * The sets recognized by this module are represented by elements of the relation Sets, which is defined as the smallest set such that: * For every atom T, except &#39;_&#39;, and for every term X, (T,X) belongs to Sets (atomic sets). * ([&#39;_&#39;],[]) belongs to Sets (the untyped empty set). * For every tuple T= {T[1],...,T[n]} and for every tuple X= {X[1],...,X[n]}, if (T[i],X[i]) belongs to Sets for every 1&lt;=i&lt;=n, then (T,X) belongs to Sets (ordered sets). * For every term T, if X is the empty list or a non-empty sorted list [X[1],...,X[n]] without duplicates such that (T,X[i]) belongs to Sets for every 1&lt;=i&lt;=n, then ([T],X) belongs to Sets (typed unordered sets). An external set is an element of the range of Sets. A type is an element of the domain of Sets. If S is an element (T,X) of Sets, then T is a valid type of X, T is the type of S, and X is the external set of S. from_term/2 creates a set from a type and an Erlang term turned into an external set. The sets represented by Sets are the elements of the range of function Set from Sets to Erlang terms and sets of Erlang terms: * Set(T,Term)= Term, where T is an atom * Set({T[1],...,T[n]},{X[1],..., X[n]})= (Set(T[1],X[1]),..., Set(T[n],X[n])) * Set([T],[X[1],...,X[n]])= {Set(T,X[1]),...,Set(T,X[n])} * Set([T],[])= {} When there is no risk of confusion, elements of Sets are identified with the sets they represent. For example, if U is the result of calling [`union/2`](#union/2) with S1 and S2 as arguments, then U is said to be the union of S1 and S2. A more precise formulation is that Set(U) is the union of Set(S1) and Set(S2). The types are used to implement the various conditions that sets must fulfill. As an example, consider the relative product of two sets R and S, and recall that the relative product of R and S is defined if R is a binary relation to Y and S is a binary relation from Y. The function that implements the relative product, relative_product/2, checks that the arguments represent binary relations by matching [{A,B}] against the type of the first argument (Arg1 say), and [{C,D}] against the type of the second argument (Arg2 say). The fact that [{A,B}] matches the type of Arg1 is to be interpreted as Arg1 representing a binary relation from X to Y, where X is defined as all sets Set(x) for some element x in Sets the type of which is A, and similarly for Y. In the same way Arg2 is interpreted as representing a binary relation from W to Z. Finally it is checked that B matches C, which is sufficient to ensure that W is equal to Y. The untyped empty set is handled separately: its type, [&#39;_&#39;], matches the type of any unordered set. A few functions of this module (drestriction/3, family_projection/2, partition/2, partition_family/2, projection/2, restriction/3, substitution/2) accept an Erlang function as a means to modify each element of a given unordered set. Such a function, called SetFun in the following, can be specified as a functional object (fun), a tuple {external,Fun}, or an integer: * If SetFun is specified as a fun, the fun is applied to each element of the given set and the return value is assumed to be a set. * If SetFun is specified as a tuple `{external, Fun}`, Fun is applied to the external set of each element of the given set and the return value is assumed to be an external set. Selecting the elements of an unordered set as external sets and assembling a new unordered set from a list of external sets is in the present implementation more efficient than modifying each element as a set. However, this optimization can only be used when the elements of the unordered set are atomic or ordered sets. It must also be the case that the type of the elements matches some clause of Fun (the type of the created set is the result of applying Fun to the type of the given set), and that Fun does nothing but selecting, duplicating, or rearranging parts of the elements. * Specifying a SetFun as an integer I is equivalent to specifying `{external, fun(X)-&gt; element(I,X)end}`, but is to be preferred, as it makes it possible to handle this case even more efficiently. Examples of SetFuns: fun sofs:union/1 fun(S) -&gt; sofs:partition(1, S) end {external, fun(A) -&gt; A end} {external, fun({A,_,C}) -&gt; {C,A} end} {external, fun({_,{_,C}}) -&gt; C end} {external, fun({_,{_,{_,E}=C}}) -&gt; {E,{E,C}} end} 2 The order in which a SetFun is applied to the elements of an unordered set is not specified, and can change in future versions of this module. The execution time of the functions of this module is dominated by the time it takes to sort lists. When no sorting is needed, the execution time is in the worst case proportional to the sum of the sizes of the input arguments and the returned value. A few functions execute in constant time: from_external/2, is_empty_set/1, is_set/1, is_sofs_set/1, to_external/1 type/1. The functions of this module exit the process with a badarg, bad_function, or type_mismatch message when given badly formed arguments or sets the types of which are not compatible. When comparing external sets, operator ==/2 is used."},{"ref":"sofs.html#a_functiona_function/12","title":"sofs.a_functiona_function/12","type":"function","doc":"Creates a function. a_function(F,T) is equivalent to from_term(F,T) if the result is a function. If no type is explicitly specified, [{atom,atom}] is used as the function type."},{"ref":"sofs.html#canonical_relation/1","title":"sofs.canonical_relation/1","type":"function","doc":"Returns the binary relation containing the elements (E,Set) such that Set belongs to SetOfSets and E belongs to Set. If SetOfSets is a partition of a set X and R is the equivalence relation in X induced by SetOfSets, then the returned relation is the canonical map from X onto the equivalence classes with respect to R. 1&gt; Ss = sofs:from_term([[a,b],[b,c]]), CR = sofs:canonical_relation(Ss), sofs:to_external(CR). [{a,[a,b]},{b,[a,b]},{b,[b,c]},{c,[b,c]}]"},{"ref":"sofs.html#composite/2","title":"sofs.composite/2","type":"function","doc":"Returns the composite of the functions Function1 and Function2. 1&gt; F1 = sofs:a_function([{a,1},{b,2},{c,2}]), F2 = sofs:a_function([{1,x},{2,y},{3,z}]), F = sofs:composite(F1, F2), sofs:to_external(F). [{a,x},{b,y},{c,y}]"},{"ref":"sofs.html#constant_function/2","title":"sofs.constant_function/2","type":"function","doc":"Creates the function that maps each element of set Set onto AnySet. 1&gt; S = sofs:set([a,b]), E = sofs:from_term(1), R = sofs:constant_function(S, E), sofs:to_external(R). [{a,1},{b,1}]"},{"ref":"sofs.html#converse/1","title":"sofs.converse/1","type":"function","doc":"Returns the converse of the binary relation BinRel1. 1&gt; R1 = sofs:relation([{1,a},{2,b},{3,a}]), R2 = sofs:converse(R1), sofs:to_external(R2). [{a,1},{a,3},{b,2}]"},{"ref":"sofs.html#difference/2","title":"sofs.difference/2","type":"function","doc":"Returns the difference of the sets Set1 and Set2."},{"ref":"sofs.html#digraph_to_familydigraph_to_family/12","title":"sofs.digraph_to_familydigraph_to_family/12","type":"function","doc":"Creates a family from the directed graph Graph. Each vertex a of Graph is represented by a pair (a,{b[1],...,b[n]}), where the b[i]:s are the out-neighbors of a. If no type is explicitly specified, [{atom,[atom]}] is used as type of the family. It is assumed that Type is a valid type of the external set of the family. If G is a directed graph, it holds that the vertices and edges of G are the same as the vertices and edges of family_to_digraph(digraph_to_family(G))."},{"ref":"sofs.html#domain/1","title":"sofs.domain/1","type":"function","doc":"Returns the domain of the binary relation BinRel. 1&gt; R = sofs:relation([{1,a},{1,b},{2,b},{2,c}]), S = sofs:domain(R), sofs:to_external(S). [1,2]"},{"ref":"sofs.html#drestriction/2","title":"sofs.drestriction/2","type":"function","doc":"Returns the difference between the binary relation BinRel1 and the restriction of BinRel1 to Set. 1&gt; R1 = sofs:relation([{1,a},{2,b},{3,c}]), S = sofs:set([2,4,6]), R2 = sofs:drestriction(R1, S), sofs:to_external(R2). [{1,a},{3,c}] drestriction(R,S) is equivalent to difference(R,restriction(R,S))."},{"ref":"sofs.html#drestriction/3","title":"sofs.drestriction/3","type":"function","doc":"Returns a subset of Set1 containing those elements that do not give an element in Set2 as the result of applying SetFun. 1&gt; SetFun = {external, fun({_A,B,C}) -&gt; {B,C} end}, R1 = sofs:relation([{a,aa,1},{b,bb,2},{c,cc,3}]), R2 = sofs:relation([{bb,2},{cc,3},{dd,4}]), R3 = sofs:drestriction(SetFun, R1, R2), sofs:to_external(R3). [{a,aa,1}] drestriction(F,S1,S2) is equivalent to difference(S1,restriction(F,S1,S2))."},{"ref":"sofs.html#empty_set/0","title":"sofs.empty_set/0","type":"function","doc":"Returns the untyped empty set. empty_set() is equivalent to from_term([],[&#39;_&#39;])."},{"ref":"sofs.html#extension/3","title":"sofs.extension/3","type":"function","doc":"Returns the extension of BinRel1 such that for each element E in Set that does not belong to the domain of BinRel1, BinRel2 contains the pair (E,AnySet). 1&gt; S = sofs:set([b,c]), A = sofs:empty_set(), R = sofs:family([{a,[1,2]},{b,[3]}]), X = sofs:extension(R, S, A), sofs:to_external(X). [{a,[1,2]},{b,[3]},{c,[]}]"},{"ref":"sofs.html#family_difference/2","title":"sofs.family_difference/2","type":"function","doc":"If Family1 and Family2 are families, then Family3 is the family such that the index set is equal to the index set of Family1, and Family3[i] is the difference between Family1[i] and Family2[i] if Family2 maps i, otherwise Family1``[i]. 1&gt; F1 = sofs:family([{a,[1,2]},{b,[3,4]}]), F2 = sofs:family([{b,[4,5]},{c,[6,7]}]), F3 = sofs:family_difference(F1, F2), sofs:to_external(F3). [{a,[1,2]},{b,[3]}]"},{"ref":"sofs.html#family_domain/1","title":"sofs.family_domain/1","type":"function","doc":"If Family1 is a family and Family1[i] is a binary relation for every i in the index set of Family1, then Family2 is the family with the same index set as Family1 such that Family2[i] is the domain of Family1``[i]. 1&gt; FR = sofs:from_term([{a,[{1,a},{2,b},{3,c}]},{b,[]},{c,[{4,d},{5,e}]}]), F = sofs:family_domain(FR), sofs:to_external(F). [{a,[1,2,3]},{b,[]},{c,[4,5]}]"},{"ref":"sofs.html#family_field/1","title":"sofs.family_field/1","type":"function","doc":"If Family1 is a family and Family1[i] is a binary relation for every i in the index set of Family1, then Family2 is the family with the same index set as Family1 such that Family2[i] is the field of Family1[i]. 1&gt; FR = sofs:from_term([{a,[{1,a},{2,b},{3,c}]},{b,[]},{c,[{4,d},{5,e}]}]), F = sofs:family_field(FR), sofs:to_external(F). [{a,[1,2,3,a,b,c]},{b,[]},{c,[4,5,d,e]}] family_field(Family1) is equivalent to family_union(family_domain(Family1), family_range(Family1))."},{"ref":"sofs.html#family_intersection/1","title":"sofs.family_intersection/1","type":"function","doc":"If Family1 is a family and Family1[i] is a set of sets for every i in the index set of Family1, then Family2 is the family with the same index set as Family1 such that Family2[i] is the intersection of Family1[i]. If Family1[i] is an empty set for some i, the process exits with a badarg message. 1&gt; F1 = sofs:from_term([{a,[[1,2,3],[2,3,4]]},{b,[[x,y,z],[x,y]]}]), F2 = sofs:family_intersection(F1), sofs:to_external(F2). [{a,[2,3]},{b,[x,y]}]"},{"ref":"sofs.html#family_intersection/2","title":"sofs.family_intersection/2","type":"function","doc":"If Family1 and Family2 are families, then Family3 is the family such that the index set is the intersection of Family1:s and Family2:s index sets, and Family3[i] is the intersection of Family1[i] and Family2[i]. 1&gt; F1 = sofs:family([{a,[1,2]},{b,[3,4]},{c,[5,6]}]), F2 = sofs:family([{b,[4,5]},{c,[7,8]},{d,[9,10]}]), F3 = sofs:family_intersection(F1, F2), sofs:to_external(F3). [{b,[4]},{c,[]}]"},{"ref":"sofs.html#family_projection/2","title":"sofs.family_projection/2","type":"function","doc":"If Family1 is a family, then Family2 is the family with the same index set as Family1 such that Family2[i] is the result of calling SetFun with Family1[i] as argument. 1&gt; F1 = sofs:from_term([{a,[[1,2],[2,3]]},{b,[[]]}]), F2 = sofs:family_projection(fun sofs:union/1, F1), sofs:to_external(F2). [{a,[1,2,3]},{b,[]}]"},{"ref":"sofs.html#family_range/1","title":"sofs.family_range/1","type":"function","doc":"If Family1 is a family and Family1[i] is a binary relation for every i in the index set of Family1, then Family2 is the family with the same index set as Family1 such that Family2[i] is the range of Family1[i]. 1&gt; FR = sofs:from_term([{a,[{1,a},{2,b},{3,c}]},{b,[]},{c,[{4,d},{5,e}]}]), F = sofs:family_range(FR), sofs:to_external(F). [{a,[a,b,c]},{b,[]},{c,[d,e]}]"},{"ref":"sofs.html#family_specification/2","title":"sofs.family_specification/2","type":"function","doc":"If Family1 is a family, then Family2 is the restriction of Family1 to those elements i of the index set for which Fun applied to Family1[i] returns true. If Fun is a tuple {external,Fun2}, then Fun2 is applied to the external set of Family1[i], otherwise Fun is applied to Family1[i]. 1&gt; F1 = sofs:family([{a,[1,2,3]},{b,[1,2]},{c,[1]}]), SpecFun = fun(S) -&gt; sofs:no_elements(S) =:= 2 end, F2 = sofs:family_specification(SpecFun, F1), sofs:to_external(F2). [{b,[1,2]}]"},{"ref":"sofs.html#family_to_digraphfamily_to_digraph/12","title":"sofs.family_to_digraphfamily_to_digraph/12","type":"function","doc":"Creates a directed graph from family Family. For each pair (a,{b[1],...,b[n]}) of Family, vertex a and the edges (a,b[i]) for 1&lt;=i&lt;=n are added to a newly created directed graph. If no graph type is specified, digraph:new/0 is used for creating the directed graph, otherwise argument GraphType is passed on as second argument to digraph:new/1. It F is a family, it holds that F is a subset of digraph_to_family(family_to_digraph(F),type(F)). Equality holds if union_of_family(F) is a subset of domain(F). Creating a cycle in an acyclic graph exits the process with a cyclic message."},{"ref":"sofs.html#family_to_relation/1","title":"sofs.family_to_relation/1","type":"function","doc":"If Family is a family, then BinRel is the binary relation containing all pairs (i,x) such that i belongs to the index set of Family and x belongs to Family[i]. 1&gt; F = sofs:family([{a,[]}, {b,[1]}, {c,[2,3]}]), R = sofs:family_to_relation(F), sofs:to_external(R). [{b,1},{c,2},{c,3}]"},{"ref":"sofs.html#family_union/1","title":"sofs.family_union/1","type":"function","doc":"If Family1 is a family and Family1[i] is a set of sets for each i in the index set of Family1, then Family2 is the family with the same index set as Family1 such that Family2[i] is the union of Family1[i]. 1&gt; F1 = sofs:from_term([{a,[[1,2],[2,3]]},{b,[[]]}]), F2 = sofs:family_union(F1), sofs:to_external(F2). [{a,[1,2,3]},{b,[]}] family_union(F) is equivalent to family_projection(fun sofs:union/1,F)."},{"ref":"sofs.html#family_union/2","title":"sofs.family_union/2","type":"function","doc":"If Family1 and Family2 are families, then Family3 is the family such that the index set is the union of Family1:s and Family2:s index sets, and Family3[i] is the union of Family1[i] and Family2[i] if both map i, otherwise Family1[i] or Family2[i]. 1&gt; F1 = sofs:family([{a,[1,2]},{b,[3,4]},{c,[5,6]}]), F2 = sofs:family([{b,[4,5]},{c,[7,8]},{d,[9,10]}]), F3 = sofs:family_union(F1, F2), sofs:to_external(F3). [{a,[1,2]},{b,[3,4,5]},{c,[5,6,7,8]},{d,[9,10]}]"},{"ref":"sofs.html#familyfamily/12","title":"sofs.familyfamily/12","type":"function","doc":"Creates a family of subsets. family(F,T) is equivalent to from_term(F,T) if the result is a family. If no type is explicitly specified, [{atom,[atom]}] is used as the family type."},{"ref":"sofs.html#field/1","title":"sofs.field/1","type":"function","doc":"Returns the field of the binary relation BinRel. 1&gt; R = sofs:relation([{1,a},{1,b},{2,b},{2,c}]), S = sofs:field(R), sofs:to_external(S). [1,2,a,b,c] field(R) is equivalent to union(domain(R), range(R))."},{"ref":"sofs.html#from_external/2","title":"sofs.from_external/2","type":"function","doc":"Creates a set from the external set ExternalSet and the type Type. It is assumed that Type is a valid type of ExternalSet."},{"ref":"sofs.html#from_sets/1","title":"sofs.from_sets/1","type":"function","doc":"Returns the unordered set containing the sets of list ListOfSets. 1&gt; S1 = sofs:relation([{a,1},{b,2}]), S2 = sofs:relation([{x,3},{y,4}]), S = sofs:from_sets([S1,S2]), sofs:to_external(S). [[{a,1},{b,2}],[{x,3},{y,4}]]"},{"ref":"sofs.html#from_sets/1","title":"sofs.from_sets/1","type":"function","doc":"Returns the ordered set containing the sets of the non-empty tuple TupleOfSets."},{"ref":"sofs.html#from_termfrom_term/12","title":"sofs.from_termfrom_term/12","type":"function","doc":"Creates an element of Sets by traversing term Term, sorting lists, removing duplicates, and deriving or verifying a valid type for the so obtained external set. An explicitly specified type Type can be used to limit the depth of the traversal; an atomic type stops the traversal, as shown by the following example where &quot;foo&quot; and {&quot;foo&quot;} are left unmodified: 1&gt; S = sofs:from_term([{{&quot;foo&quot;},[1,1]},{&quot;foo&quot;,[2,2]}], [{atom,[atom]}]), sofs:to_external(S). [{{&quot;foo&quot;},[1]},{&quot;foo&quot;,[2]}] from_term can be used for creating atomic or ordered sets. The only purpose of such a set is that of later building unordered sets, as all functions in this module that do anything operate on unordered sets. Creating unordered sets from a collection of ordered sets can be the way to go if the ordered sets are big and one does not want to waste heap by rebuilding the elements of the unordered set. The following example shows that a set can be built &quot;layer by layer&quot;: 1&gt; A = sofs:from_term(a), S = sofs:set([1,2,3]), P1 = sofs:from_sets({A,S}), P2 = sofs:from_term({b,[6,5,4]}), Ss = sofs:from_sets([P1,P2]), sofs:to_external(Ss). [{a,[1,2,3]},{b,[4,5,6]}] Other functions that create sets are from_external/2 and from_sets/1. Special cases of from_term/2 are a_function/1,2, empty_set/0, family/1,2, relation/1,2, and set/1,2."},{"ref":"sofs.html#image/2","title":"sofs.image/2","type":"function","doc":"Returns the image of set Set1 under the binary relation BinRel. 1&gt; R = sofs:relation([{1,a},{2,b},{2,c},{3,d}]), S1 = sofs:set([1,2]), S2 = sofs:image(R, S1), sofs:to_external(S2). [a,b,c]"},{"ref":"sofs.html#intersection/1","title":"sofs.intersection/1","type":"function","doc":"Returns the intersection of the set of sets SetOfSets. Intersecting an empty set of sets exits the process with a badarg message."},{"ref":"sofs.html#intersection/2","title":"sofs.intersection/2","type":"function","doc":"Returns the intersection of Set1 and Set2."},{"ref":"sofs.html#intersection_of_family/1","title":"sofs.intersection_of_family/1","type":"function","doc":"Returns the intersection of family Family. Intersecting an empty family exits the process with a badarg message. 1&gt; F = sofs:family([{a,[0,2,4]},{b,[0,1,2]},{c,[2,3]}]), S = sofs:intersection_of_family(F), sofs:to_external(S). [2]"},{"ref":"sofs.html#inverse/1","title":"sofs.inverse/1","type":"function","doc":"Returns the inverse of function Function1. 1&gt; R1 = sofs:relation([{1,a},{2,b},{3,c}]), R2 = sofs:inverse(R1), sofs:to_external(R2). [{a,1},{b,2},{c,3}]"},{"ref":"sofs.html#inverse_image/2","title":"sofs.inverse_image/2","type":"function","doc":"Returns the inverse image of Set1 under the binary relation BinRel. 1&gt; R = sofs:relation([{1,a},{2,b},{2,c},{3,d}]), S1 = sofs:set([c,d,e]), S2 = sofs:inverse_image(R, S1), sofs:to_external(S2). [2,3]"},{"ref":"sofs.html#is_a_function/1","title":"sofs.is_a_function/1","type":"function","doc":"Returns true if the binary relation BinRel is a function or the untyped empty set, otherwise false."},{"ref":"sofs.html#is_disjoint/2","title":"sofs.is_disjoint/2","type":"function","doc":"Returns true if Set1 and Set2 are disjoint, otherwise false."},{"ref":"sofs.html#is_empty_set/1","title":"sofs.is_empty_set/1","type":"function","doc":"Returns true if AnySet is an empty unordered set, otherwise false."},{"ref":"sofs.html#is_equal/2","title":"sofs.is_equal/2","type":"function","doc":"Returns true if AnySet1 and AnySet2 are equal, otherwise false. The following example shows that ==/2 is used when comparing sets for equality: 1&gt; S1 = sofs:set([1.0]), S2 = sofs:set([1]), sofs:is_equal(S1, S2). true"},{"ref":"sofs.html#is_set/1","title":"sofs.is_set/1","type":"function","doc":"Returns true if AnySet is an unordered set, and false if AnySet is an ordered set or an atomic set."},{"ref":"sofs.html#is_sofs_set/1","title":"sofs.is_sofs_set/1","type":"function","doc":"Returns true if Term is an unordered set, an ordered set, or an atomic set, otherwise false."},{"ref":"sofs.html#is_subset/2","title":"sofs.is_subset/2","type":"function","doc":"Returns true if Set1 is a subset of Set2, otherwise false."},{"ref":"sofs.html#is_type/1","title":"sofs.is_type/1","type":"function","doc":"Returns true if term Term is a type."},{"ref":"sofs.html#join/4","title":"sofs.join/4","type":"function","doc":"Returns the natural join of the relations Relation1 and Relation2 on coordinates I and J. 1&gt; R1 = sofs:relation([{a,x,1},{b,y,2}]), R2 = sofs:relation([{1,f,g},{1,h,i},{2,3,4}]), J = sofs:join(R1, 3, R2, 1), sofs:to_external(J). [{a,x,1,f,g},{a,x,1,h,i},{b,y,2,3,4}]"},{"ref":"sofs.html#multiple_relative_product/2","title":"sofs.multiple_relative_product/2","type":"function","doc":"If TupleOfBinRels is a non-empty tuple {R[1],...,R[n]} of binary relations and BinRel1 is a binary relation, then BinRel2 is the multiple relative product of the ordered set (R[i],...,R[n]) and BinRel1. 1&gt; Ri = sofs:relation([{a,1},{b,2},{c,3}]), R = sofs:relation([{a,b},{b,c},{c,a}]), MP = sofs:multiple_relative_product({Ri, Ri}, R), sofs:to_external(sofs:range(MP)). [{1,2},{2,3},{3,1}]"},{"ref":"sofs.html#no_elements/1","title":"sofs.no_elements/1","type":"function","doc":"Returns the number of elements of the ordered or unordered set ASet."},{"ref":"sofs.html#partition/1","title":"sofs.partition/1","type":"function","doc":"Returns the partition of the union of the set of sets SetOfSets such that two elements are considered equal if they belong to the same elements of SetOfSets. 1&gt; Sets1 = sofs:from_term([[a,b,c],[d,e,f],[g,h,i]]), Sets2 = sofs:from_term([[b,c,d],[e,f,g],[h,i,j]]), P = sofs:partition(sofs:union(Sets1, Sets2)), sofs:to_external(P). [[a],[b,c],[d],[e,f],[g],[h,i],[j]]"},{"ref":"sofs.html#partition/2","title":"sofs.partition/2","type":"function","doc":"Returns the partition of Set such that two elements are considered equal if the results of applying SetFun are equal. 1&gt; Ss = sofs:from_term([[a],[b],[c,d],[e,f]]), SetFun = fun(S) -&gt; sofs:from_term(sofs:no_elements(S)) end, P = sofs:partition(SetFun, Ss), sofs:to_external(P). [[[a],[b]],[[c,d],[e,f]]]"},{"ref":"sofs.html#partition/3","title":"sofs.partition/3","type":"function","doc":"Returns a pair of sets that, regarded as constituting a set, forms a partition of Set1. If the result of applying SetFun to an element of Set1 gives an element in Set2, the element belongs to Set3, otherwise the element belongs to Set4. 1&gt; R1 = sofs:relation([{1,a},{2,b},{3,c}]), S = sofs:set([2,4,6]), {R2,R3} = sofs:partition(1, R1, S), {sofs:to_external(R2),sofs:to_external(R3)}. {[{2,b}],[{1,a},{3,c}]} partition(F,S1,S2) is equivalent to {restriction(F,S1,S2), drestriction(F,S1,S2)}."},{"ref":"sofs.html#partition_family/2","title":"sofs.partition_family/2","type":"function","doc":"Returns family Family where the indexed set is a partition of Set such that two elements are considered equal if the results of applying SetFun are the same value i. This i is the index that Family maps onto the equivalence class. 1&gt; S = sofs:relation([{a,a,a,a},{a,a,b,b},{a,b,b,b}]), SetFun = {external, fun({A,_,C,_}) -&gt; {A,C} end}, F = sofs:partition_family(SetFun, S), sofs:to_external(F). [{{a,a},[{a,a,a,a}]},{{a,b},[{a,a,b,b},{a,b,b,b}]}]"},{"ref":"sofs.html#product/1","title":"sofs.product/1","type":"function","doc":"Returns the Cartesian product of the non-empty tuple of sets TupleOfSets. If (x[1],...,x[n]) is an element of the n-ary relation Relation, then x[i] is drawn from element i of TupleOfSets. 1&gt; S1 = sofs:set([a,b]), S2 = sofs:set([1,2]), S3 = sofs:set([x,y]), P3 = sofs:product({S1,S2,S3}), sofs:to_external(P3). [{a,1,x},{a,1,y},{a,2,x},{a,2,y},{b,1,x},{b,1,y},{b,2,x},{b,2,y}]"},{"ref":"sofs.html#product/2","title":"sofs.product/2","type":"function","doc":"Returns the Cartesian product of Set1 and Set2. 1&gt; S1 = sofs:set([1,2]), S2 = sofs:set([a,b]), R = sofs:product(S1, S2), sofs:to_external(R). [{1,a},{1,b},{2,a},{2,b}] product(S1,S2) is equivalent to product({S1,S2})."},{"ref":"sofs.html#projection/2","title":"sofs.projection/2","type":"function","doc":"Returns the set created by substituting each element of Set1 by the result of applying SetFun to the element. If SetFun is a number i&gt;=1 and Set1 is a relation, then the returned set is the projection of Set1 onto coordinate i. 1&gt; S1 = sofs:from_term([{1,a},{2,b},{3,a}]), S2 = sofs:projection(2, S1), sofs:to_external(S2). [a,b]"},{"ref":"sofs.html#range/1","title":"sofs.range/1","type":"function","doc":"Returns the range of the binary relation BinRel. 1&gt; R = sofs:relation([{1,a},{1,b},{2,b},{2,c}]), S = sofs:range(R), sofs:to_external(S). [a,b,c]"},{"ref":"sofs.html#relation_to_family/1","title":"sofs.relation_to_family/1","type":"function","doc":"Returns family Family such that the index set is equal to the domain of the binary relation BinRel, and Family[i] is the image of the set of i under BinRel. 1&gt; R = sofs:relation([{b,1},{c,2},{c,3}]), F = sofs:relation_to_family(R), sofs:to_external(F). [{b,[1]},{c,[2,3]}]"},{"ref":"sofs.html#relationrelation/12","title":"sofs.relationrelation/12","type":"function","doc":"Creates a relation. relation(R,T) is equivalent to from_term(R,T), if T is a type and the result is a relation. If Type is an integer N, then [{atom,...,atom}]), where the tuple size is N, is used as type of the relation. If no type is explicitly specified, the size of the first tuple of Tuples is used if there is such a tuple. relation([]) is equivalent to relation([],2)."},{"ref":"sofs.html#relative_product/2","title":"sofs.relative_product/2","type":"function","doc":"Returns the relative product of the binary relations BinRel1 and BinRel2."},{"ref":"sofs.html#relative_product1/2","title":"sofs.relative_product1/2","type":"function","doc":"Returns the relative product of the converse of the binary relation BinRel1 and the binary relation BinRel2. 1&gt; R1 = sofs:relation([{1,a},{1,aa},{2,b}]), R2 = sofs:relation([{1,u},{2,v},{3,c}]), R3 = sofs:relative_product1(R1, R2), sofs:to_external(R3). [{a,u},{aa,u},{b,v}] relative_product1(R1,R2) is equivalent to relative_product(converse(R1),R2)."},{"ref":"sofs.html#relative_productrelative_product/12","title":"sofs.relative_productrelative_product/12","type":"function","doc":"If ListOfBinRels is a non-empty list [R[1],...,R[n]] of binary relations and BinRel1 is a binary relation, then BinRel2 is the relative product of the ordered set (R[i],...,R[n]) and BinRel1. If BinRel1 is omitted, the relation of equality between the elements of the Cartesian product of the ranges of R[i], rangeR[1]...rangeR[n], is used instead (intuitively, nothing is &quot;lost&quot;). 1&gt; TR = sofs:relation([{1,a},{1,aa},{2,b}]), R1 = sofs:relation([{1,u},{2,v},{3,c}]), R2 = sofs:relative_product([TR, R1]), sofs:to_external(R2). [{1,{a,u}},{1,{aa,u}},{2,{b,v}}] Notice that relative_product([R1],R2) is different from relative_product(R1,R2); the list of one element is not identified with the element itself."},{"ref":"sofs.html#restriction/2","title":"sofs.restriction/2","type":"function","doc":"Returns the restriction of the binary relation BinRel1 to Set. 1&gt; R1 = sofs:relation([{1,a},{2,b},{3,c}]), S = sofs:set([1,2,4]), R2 = sofs:restriction(R1, S), sofs:to_external(R2). [{1,a},{2,b}]"},{"ref":"sofs.html#restriction/3","title":"sofs.restriction/3","type":"function","doc":"Returns a subset of Set1 containing those elements that gives an element in Set2 as the result of applying SetFun. 1&gt; S1 = sofs:relation([{1,a},{2,b},{3,c}]), S2 = sofs:set([b,c,d]), S3 = sofs:restriction(2, S1, S2), sofs:to_external(S3). [{2,b},{3,c}]"},{"ref":"sofs.html#setset/12","title":"sofs.setset/12","type":"function","doc":"Creates an unordered set. set(L,T) is equivalent to from_term(L,T), if the result is an unordered set. If no type is explicitly specified, [atom] is used as the set type."},{"ref":"sofs.html#specification/2","title":"sofs.specification/2","type":"function","doc":"Returns the set containing every element of Set1 for which Fun returns true. If Fun is a tuple {external,Fun2}, Fun2 is applied to the external set of each element, otherwise Fun is applied to each element. 1&gt; R1 = sofs:relation([{a,1},{b,2}]), R2 = sofs:relation([{x,1},{x,2},{y,3}]), S1 = sofs:from_sets([R1,R2]), S2 = sofs:specification(fun sofs:is_a_function/1, S1), sofs:to_external(S2). [[{a,1},{b,2}]]"},{"ref":"sofs.html#strict_relation/1","title":"sofs.strict_relation/1","type":"function","doc":"Returns the strict relation corresponding to the binary relation BinRel1. 1&gt; R1 = sofs:relation([{1,1},{1,2},{2,1},{2,2}]), R2 = sofs:strict_relation(R1), sofs:to_external(R2). [{1,2},{2,1}]"},{"ref":"sofs.html#substitution/2","title":"sofs.substitution/2","type":"function","doc":"Returns a function, the domain of which is Set1. The value of an element of the domain is the result of applying SetFun to the element. 1&gt; L = [{a,1},{b,2}]. [{a,1},{b,2}] 2&gt; sofs:to_external(sofs:projection(1,sofs:relation(L))). [a,b] 3&gt; sofs:to_external(sofs:substitution(1,sofs:relation(L))). [{{a,1},a},{{b,2},b}] 4&gt; SetFun = {external, fun({A,_}=E) -&gt; {E,A} end}, sofs:to_external(sofs:projection(SetFun,sofs:relation(L))). [{{a,1},a},{{b,2},b}] The relation of equality between the elements of {a,b,c}: 1&gt; I = sofs:substitution(fun(A) -&gt; A end, sofs:set([a,b,c])), sofs:to_external(I). [{a,a},{b,b},{c,c}] Let SetOfSets be a set of sets and BinRel a binary relation. The function that maps each element Set of SetOfSets onto the image of Set under BinRel is returned by the following function: images(SetOfSets, BinRel) -&gt; Fun = fun(Set) -&gt; sofs:image(BinRel, Set) end, sofs:substitution(Fun, SetOfSets). External unordered sets are represented as sorted lists. So, creating the image of a set under a relation R can traverse all elements of R (to that comes the sorting of results, the image). In image/2, BinRel is traversed once for each element of SetOfSets, which can take too long. The following efficient function can be used instead under the assumption that the image of each element of SetOfSets under BinRel is non-empty: images2(SetOfSets, BinRel) -&gt; CR = sofs:canonical_relation(SetOfSets), R = sofs:relative_product1(CR, BinRel), sofs:relation_to_family(R)."},{"ref":"sofs.html#symdiff/2","title":"sofs.symdiff/2","type":"function","doc":"Returns the symmetric difference (or the Boolean sum) of Set1 and Set2. 1&gt; S1 = sofs:set([1,2,3]), S2 = sofs:set([2,3,4]), P = sofs:symdiff(S1, S2), sofs:to_external(P). [1,4]"},{"ref":"sofs.html#symmetric_partition/2","title":"sofs.symmetric_partition/2","type":"function","doc":"Returns a triple of sets: * `Set3` contains the elements of `Set1` that do not belong to `Set2`. * `Set4` contains the elements of `Set1` that belong to `Set2`. * `Set5` contains the elements of `Set2` that do not belong to `Set1`."},{"ref":"sofs.html#to_external/1","title":"sofs.to_external/1","type":"function","doc":"Returns the external set of an atomic, ordered, or unordered set."},{"ref":"sofs.html#to_sets/1","title":"sofs.to_sets/1","type":"function","doc":"Returns the elements of the ordered set ASet as a tuple of sets, and the elements of the unordered set ASet as a sorted list of sets without duplicates."},{"ref":"sofs.html#type/1","title":"sofs.type/1","type":"function","doc":"Returns the type of an atomic, ordered, or unordered set."},{"ref":"sofs.html#union/1","title":"sofs.union/1","type":"function","doc":"Returns the union of the set of sets SetOfSets."},{"ref":"sofs.html#union/2","title":"sofs.union/2","type":"function","doc":"Returns the union of Set1 and Set2."},{"ref":"sofs.html#union_of_family/1","title":"sofs.union_of_family/1","type":"function","doc":"Returns the union of family Family. 1&gt; F = sofs:family([{a,[0,2,4]},{b,[0,1,2]},{c,[2,3]}]), S = sofs:union_of_family(F), sofs:to_external(S). [0,1,2,3,4]"},{"ref":"sofs.html#weak_relation/1","title":"sofs.weak_relation/1","type":"function","doc":"Returns a subset S of the weak relation W corresponding to the binary relation BinRel1. Let F be the field of BinRel1. The subset S is defined so that x S y if x W y for some x in F and for some y in F. 1&gt; R1 = sofs:relation([{1,1},{1,2},{3,1}]), R2 = sofs:weak_relation(R1), sofs:to_external(R2). [{1,1},{1,2},{2,2},{3,1},{3,3}]"},{"ref":"string.html","title":"string","type":"module","doc":"This module provides functions for string processing. A string in this module is represented by unicode:chardata(), that is, a list of codepoints, binaries with UTF-8-encoded codepoints (UTF-8 binaries), or a mix of the two. &quot;abcd&quot; is a valid string &lt;&lt;&quot;abcd&quot;&gt;&gt; is a valid string [&quot;abcd&quot;] is a valid string &lt;&lt;&quot;abc..&quot;/utf8&gt;&gt; is a valid string &lt;&lt;&quot;abc..&quot;&gt;&gt; is NOT a valid string, but a binary with Latin-1-encoded codepoints [&lt;&lt;&quot;abc&quot;&gt;&gt;, &quot;..&quot;] is a valid string [atom] is NOT a valid string This module operates on grapheme clusters. A grapheme cluster is a user-perceived character, which can be represented by several codepoints. &quot;&quot; [229] or [97, 778] &quot;e&quot; [101, 778] The string length of &quot;e&quot; is 3, even though it is represented by the codepoints [223,8593,101,778] or the UTF-8 binary &lt;&lt;195,159,226,134,145,101,204,138&gt;&gt;. Grapheme clusters for codepoints of class prepend and non-modern (or decomposed) Hangul is not handled for performance reasons in find/3, replace/3, split/2, split/2 and trim/3. Splitting and appending strings is to be done on grapheme clusters borders. There is no verification that the results of appending strings are valid or normalized. Most of the functions expect all input to be normalized to one form, see for example unicode:characters_to_nfc_list/1. Language or locale specific handling of input is not considered in any function. The functions can crash for non-valid input strings. For example, the functions expect UTF-8 binaries but not all functions verify that all binaries are encoded correctly. Unless otherwise specified the return value type is the same as the input type. That is, binary input returns binary output, list input returns a list output, and mixed input can return a mixed output. 1&gt; string:trim(&quot; sarah &quot;). &quot;sarah&quot; 2&gt; string:trim(&lt;&lt;&quot; sarah &quot;&gt;&gt;). &lt;&lt;&quot;sarah&quot;&gt;&gt; 3&gt; string:lexemes(&quot;foo bar&quot;, &quot; &quot;). [&quot;foo&quot;,&quot;bar&quot;] 4&gt; string:lexemes(&lt;&lt;&quot;foo bar&quot;&gt;&gt;, &quot; &quot;). [&lt;&lt;&quot;foo&quot;&gt;&gt;,&lt;&lt;&quot;bar&quot;&gt;&gt;] This module has been reworked in Erlang/OTP 20 to handle unicode:chardata() and operate on grapheme clusters. The old functions that only work on Latin-1 lists as input are still available but should not be used, they will be deprecated in a future release."},{"ref":"string.html#casefold/1","title":"string.casefold/1","type":"function","doc":"Converts String to a case-agnostic comparable string. Function casefold/1 is preferred over lowercase/1 when two strings are to be compared for equality. See also equal/4. Example: 1&gt; string:casefold(&quot; and  SHARP S&quot;). &quot; and ss sharp s&quot;"},{"ref":"string.html#centrecentre/23","title":"string.centrecentre/23","type":"function","doc":"Returns a string, where String is centered in the string and surrounded by blanks or Character. The resulting string has length Number. This function is obsolete. Use pad/3."},{"ref":"string.html#charschars/23","title":"string.charschars/23","type":"function","doc":"Returns a string consisting of Number characters Character. Optionally, the string can end with string Tail. This function is obsolete. Use lists:duplicate/2."},{"ref":"string.html#chomp/1","title":"string.chomp/1","type":"function","doc":"Returns a string where any trailing \\n or \\r\\n have been removed from String. Example: 182&gt; string:chomp(&lt;&lt;&quot;\\nHello\\n\\n&quot;&gt;&gt;). &lt;&lt;&quot;\\nHello&quot;&gt;&gt; 183&gt; string:chomp(&quot;\\nHello\\r\\r\\n&quot;). &quot;\\nHello\\r&quot;"},{"ref":"string.html#chr/2","title":"string.chr/2","type":"function","doc":"Returns the index of the first occurrence of Character in String. Returns 0 if Character does not occur. This function is obsolete. Use find/2."},{"ref":"string.html#concat/2","title":"string.concat/2","type":"function","doc":"Concatenates String1 and String2 to form a new string String3, which is returned. This function is obsolete. Use [``String1``, ``String2``] as Data argument, and call unicode:characters_to_list/2 or unicode:characters_to_binary/2 to flatten the output."},{"ref":"string.html#copies/2","title":"string.copies/2","type":"function","doc":"Returns a string containing String repeated Number times. This function is obsolete. Use lists:duplicate/2."},{"ref":"string.html#cspan/2","title":"string.cspan/2","type":"function","doc":"Returns the length of the maximum initial segment of String, which consists entirely of characters not from Chars. This function is obsolete. Use take/3. Example: &gt; string:cspan(&quot;\\t abcdef&quot;, &quot; \\t&quot;). 0"},{"ref":"string.html#equalequalequal/234","title":"string.equalequalequal/234","type":"function","doc":"Returns true if A and B are equal, otherwise false. If IgnoreCase is true the function does casefolding on the fly before the equality test. If Norm is not none the function applies normalization on the fly before the equality test. There are four available normalization forms: nfc, nfd, nfkc, and nfkd. By default, IgnoreCase is false and Norm is none. Example: 1&gt; string:equal(&quot;&quot;, &lt;&lt;&quot;&quot;/utf8&gt;&gt;). true 2&gt; string:equal(&quot;&quot;, unicode:characters_to_nfd_binary(&quot;&quot;)). false 3&gt; string:equal(&quot;&quot;, unicode:characters_to_nfd_binary(&quot;&quot;), true, nfc). true"},{"ref":"string.html#findfind/23","title":"string.findfind/23","type":"function","doc":"Removes anything before SearchPattern in String and returns the remainder of the string or nomatch if SearchPattern is not found. Dir, which can be leading or trailing, indicates from which direction characters are to be searched. By default, Dir is leading. Example: 1&gt; string:find(&quot;ab..cd..ef&quot;, &quot;.&quot;). &quot;..cd..ef&quot; 2&gt; string:find(&lt;&lt;&quot;ab..cd..ef&quot;&gt;&gt;, &quot;..&quot;, trailing). &lt;&lt;&quot;..ef&quot;&gt;&gt; 3&gt; string:find(&lt;&lt;&quot;ab..cd..ef&quot;&gt;&gt;, &quot;x&quot;, leading). nomatch 4&gt; string:find(&quot;ab..cd..ef&quot;, &quot;x&quot;, trailing). nomatch"},{"ref":"string.html#is_empty/1","title":"string.is_empty/1","type":"function","doc":"Returns true if String is the empty string, otherwise false. Example: 1&gt; string:is_empty(&quot;foo&quot;). false 2&gt; string:is_empty([&quot;&quot;,&lt;&lt;&gt;&gt;]). true"},{"ref":"string.html#join/2","title":"string.join/2","type":"function","doc":"Returns a string with the elements of StringList separated by the string in Separator. This function is obsolete. Use lists:join/2. Example: &gt; join([&quot;one&quot;, &quot;two&quot;, &quot;three&quot;], &quot;, &quot;). &quot;one, two, three&quot;"},{"ref":"string.html#leftleft/23","title":"string.leftleft/23","type":"function","doc":"Returns String with the length adjusted in accordance with Number. The left margin is fixed. If length(``String``) &lt; Number, then String is padded with blanks or Characters. This function is obsolete. Use pad/2 or pad/3. Example: &gt; string:left(&quot;Hello&quot;,10,$.). &quot;Hello.....&quot;"},{"ref":"string.html#len/1","title":"string.len/1","type":"function","doc":"Returns the number of characters in String. This function is obsolete. Use length/1."},{"ref":"string.html#length/1","title":"string.length/1","type":"function","doc":"Returns the number of grapheme clusters in String. Example: 1&gt; string:length(&quot;e&quot;). 3 2&gt; string:length(&lt;&lt;195,159,226,134,145,101,204,138&gt;&gt;). 3"},{"ref":"string.html#lexemes/2","title":"string.lexemes/2","type":"function","doc":"Returns a list of lexemes in String, separated by the grapheme clusters in SeparatorList. Notice that, as shown in this example, two or more adjacent separator graphemes clusters in String are treated as one. That is, there are no empty strings in the resulting list of lexemes. See also split/3 which returns empty strings. Notice that [$\\r,$\\n] is one grapheme cluster. Example: 1&gt; string:lexemes(&quot;abc defxxghix jkl\\r\\nfoo&quot;, &quot;x e&quot; ++ [[$\\r,$\\n]]). [&quot;abc&quot;,&quot;def&quot;,&quot;ghi&quot;,&quot;jkl&quot;,&quot;foo&quot;] 2&gt; string:lexemes(&lt;&lt;&quot;abc defxxghix jkl\\r\\nfoo&quot;/utf8&gt;&gt;, &quot;x e&quot; ++ [$\\r,$\\n]). [&lt;&lt;&quot;abc&quot;&gt;&gt;,&lt;&lt;&quot;def&quot;/utf8&gt;&gt;,&lt;&lt;&quot;ghi&quot;&gt;&gt;,&lt;&lt;&quot;jkl\\r\\nfoo&quot;&gt;&gt;]"},{"ref":"string.html#lowercase/1","title":"string.lowercase/1","type":"function","doc":"Converts String to lowercase. Notice that function casefold/1 should be used when converting a string to be tested for equality. Example: 2&gt; string:lowercase(string:uppercase(&quot;Micha&quot;)). &quot;micha&quot;"},{"ref":"string.html#next_codepoint/1","title":"string.next_codepoint/1","type":"function","doc":"Returns the first codepoint in String and the rest of String in the tail. Returns an empty list if String is empty or an {error, String} tuple if the next byte is invalid. Example: 1&gt; string:next_codepoint(unicode:characters_to_binary(&quot;efg&quot;)). [101|&lt;&lt;&quot;fg&quot;/utf8&gt;&gt;]"},{"ref":"string.html#next_grapheme/1","title":"string.next_grapheme/1","type":"function","doc":"Returns the first grapheme cluster in String and the rest of String in the tail. Returns an empty list if String is empty or an {error, String} tuple if the next byte is invalid. Example: 1&gt; string:next_grapheme(unicode:characters_to_binary(&quot;efg&quot;)). [&quot;e&quot;|&lt;&lt;&quot;fg&quot;&gt;&gt;]"},{"ref":"string.html#nth_lexeme/3","title":"string.nth_lexeme/3","type":"function","doc":"Returns lexeme number N in String, where lexemes are separated by the grapheme clusters in SeparatorList. Example: 1&gt; string:nth_lexeme(&quot;abc.def.ghiejkl&quot;, 3, &quot;.e&quot;). &quot;ghi&quot;"},{"ref":"string.html#padpadpad/234","title":"string.padpadpad/234","type":"function","doc":"Pads String to Length with grapheme cluster Char. Dir, which can be leading, trailing, or both, indicates where the padding should be added. By default, Char is $\\s and Dir is trailing. Example: 1&gt; string:pad(&lt;&lt;&quot;Hell&quot;/utf8&gt;&gt;, 8). [&lt;&lt;72,101,204,138,108,108,195,182&gt;&gt;,32,32,32] 2&gt; io:format(&quot;&#39;~ts&#39;~n&quot;,[string:pad(&quot;Hell&quot;, 8, leading)]). &#39; Hell&#39; 3&gt; io:format(&quot;&#39;~ts&#39;~n&quot;,[string:pad(&quot;Hell&quot;, 8, both)]). &#39; Hell &#39;"},{"ref":"string.html#prefix/2","title":"string.prefix/2","type":"function","doc":"If Prefix is the prefix of String, removes it and returns the remainder of String, otherwise returns nomatch. Example: 1&gt; string:prefix(&lt;&lt;&quot;prefix of string&quot;&gt;&gt;, &quot;pre&quot;). &lt;&lt;&quot;fix of string&quot;&gt;&gt; 2&gt; string:prefix(&quot;pre&quot;, &quot;prefix&quot;). nomatch"},{"ref":"string.html#rchr/2","title":"string.rchr/2","type":"function","doc":"Returns the index of the last occurrence of Character in String. Returns 0 if Character does not occur. This function is obsolete. Use find/3."},{"ref":"string.html#replacereplace/34","title":"string.replacereplace/34","type":"function","doc":"Replaces SearchPattern in String with Replacement. Where, default leading, indicates whether the leading, the trailing or all encounters of SearchPattern are to be replaced. Can be implemented as: lists:join(Replacement, split(String, SearchPattern, Where)). Example: 1&gt; string:replace(&lt;&lt;&quot;ab..cd..ef&quot;&gt;&gt;, &quot;..&quot;, &quot;*&quot;). [&lt;&lt;&quot;ab&quot;&gt;&gt;,&quot;*&quot;,&lt;&lt;&quot;cd..ef&quot;&gt;&gt;] 2&gt; string:replace(&lt;&lt;&quot;ab..cd..ef&quot;&gt;&gt;, &quot;..&quot;, &quot;*&quot;, all). [&lt;&lt;&quot;ab&quot;&gt;&gt;,&quot;*&quot;,&lt;&lt;&quot;cd&quot;&gt;&gt;,&quot;*&quot;,&lt;&lt;&quot;ef&quot;&gt;&gt;]"},{"ref":"string.html#reverse/1","title":"string.reverse/1","type":"function","doc":"Returns the reverse list of the grapheme clusters in String. Example: 1&gt; Reverse = string:reverse(unicode:characters_to_nfd_binary(&quot;&quot;)). [[79,776],[65,776],[65,778]] 2&gt; io:format(&quot;~ts~n&quot;,[Reverse]). OAA"},{"ref":"string.html#rightright/23","title":"string.rightright/23","type":"function","doc":"Returns String with the length adjusted in accordance with Number. The right margin is fixed. If the length of (``String``) &lt; Number, then String is padded with blanks or Characters. This function is obsolete. Use pad/3. Example: &gt; string:right(&quot;Hello&quot;, 10, $.). &quot;.....Hello&quot;"},{"ref":"string.html#rstr/2","title":"string.rstr/2","type":"function","doc":"Returns the position where the last occurrence of SubString begins in String. Returns 0 if SubString does not exist in String. This function is obsolete. Use find/3. Example: &gt; string:rstr(&quot; Hello Hello World World &quot;, &quot;Hello World&quot;). 8"},{"ref":"string.html#sliceslice/23","title":"string.sliceslice/23","type":"function","doc":"Returns a substring of String of at most Length grapheme clusters, starting at position Start. By default, Length is infinity. Example: 1&gt; string:slice(&lt;&lt;&quot;Hell Wrld&quot;/utf8&gt;&gt;, 4). &lt;&lt;&quot; Wrld&quot;/utf8&gt;&gt; 2&gt; string:slice([&quot;Hell &quot;, &lt;&lt;&quot;Wrld&quot;/utf8&gt;&gt;], 4,4). &quot; W&quot; 3&gt; string:slice([&quot;Hell &quot;, &lt;&lt;&quot;Wrld&quot;/utf8&gt;&gt;], 4,50). &quot; Wrld&quot;"},{"ref":"string.html#span/2","title":"string.span/2","type":"function","doc":"Returns the length of the maximum initial segment of String, which consists entirely of characters from Chars. This function is obsolete. Use take/2. Example: &gt; string:span(&quot;\\t abcdef&quot;, &quot; \\t&quot;). 5"},{"ref":"string.html#splitsplit/23","title":"string.splitsplit/23","type":"function","doc":"Splits String where SearchPattern is encountered and return the remaining parts. Where, default leading, indicates whether the leading, the trailing or all encounters of SearchPattern will split String. Example: 0&gt; string:split(&quot;ab..bc..cd&quot;, &quot;..&quot;). [&quot;ab&quot;,&quot;bc..cd&quot;] 1&gt; string:split(&lt;&lt;&quot;ab..bc..cd&quot;&gt;&gt;, &quot;..&quot;, trailing). [&lt;&lt;&quot;ab..bc&quot;&gt;&gt;,&lt;&lt;&quot;cd&quot;&gt;&gt;] 2&gt; string:split(&lt;&lt;&quot;ab..bc....cd&quot;&gt;&gt;, &quot;..&quot;, all). [&lt;&lt;&quot;ab&quot;&gt;&gt;,&lt;&lt;&quot;bc&quot;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&quot;cd&quot;&gt;&gt;]"},{"ref":"string.html#str/2","title":"string.str/2","type":"function","doc":"Returns the position where the first occurrence of SubString begins in String. Returns 0 if SubString does not exist in String. This function is obsolete. Use find/2. Example: &gt; string:str(&quot; Hello Hello World World &quot;, &quot;Hello World&quot;). 8"},{"ref":"string.html#stripstripstrip/123","title":"string.stripstripstrip/123","type":"function","doc":"Returns a string, where leading or trailing, or both, blanks or a number of Character have been removed. Direction, which can be left, right, or both, indicates from which direction blanks are to be removed. strip/1 is equivalent to strip(String, both). This function is obsolete. Use trim/3. Example: &gt; string:strip(&quot;...Hello.....&quot;, both, $.). &quot;Hello&quot;"},{"ref":"string.html#sub_stringsub_string/23","title":"string.sub_stringsub_string/23","type":"function","doc":"Returns a substring of String, starting at position Start to the end of the string, or to and including position Stop. This function is obsolete. Use slice/3. Example: sub_string(&quot;Hello World&quot;, 4, 8). &quot;lo Wo&quot;"},{"ref":"string.html#sub_wordsub_word/23","title":"string.sub_wordsub_word/23","type":"function","doc":"Returns the word in position Number of String. Words are separated by blanks or Characters. This function is obsolete. Use nth_lexeme/3. Example: &gt; string:sub_word(&quot; Hello old boy !&quot;,3,$o). &quot;ld b&quot;"},{"ref":"string.html#substrsubstr/23","title":"string.substrsubstr/23","type":"function","doc":"Returns a substring of String, starting at position Start, and ending at the end of the string or at length Length. This function is obsolete. Use slice/3. Example: &gt; substr(&quot;Hello World&quot;, 4, 5). &quot;lo Wo&quot;"},{"ref":"string.html#taketaketake/234","title":"string.taketaketake/234","type":"function","doc":"Takes characters from String as long as the characters are members of set Characters or the complement of set Characters. Dir, which can be leading or trailing, indicates from which direction characters are to be taken. Example: 5&gt; string:take(&quot;abc0z123&quot;, lists:seq($a,$z)). {&quot;abc&quot;,&quot;0z123&quot;} 6&gt; string:take(&lt;&lt;&quot;abc0z123&quot;&gt;&gt;, lists:seq($0,$9), true, leading). {&lt;&lt;&quot;abc&quot;&gt;&gt;,&lt;&lt;&quot;0z123&quot;&gt;&gt;} 7&gt; string:take(&quot;abc0z123&quot;, lists:seq($0,$9), false, trailing). {&quot;abc0z&quot;,&quot;123&quot;} 8&gt; string:take(&lt;&lt;&quot;abc0z123&quot;&gt;&gt;, lists:seq($a,$z), true, trailing). {&lt;&lt;&quot;abc0z&quot;&gt;&gt;,&lt;&lt;&quot;123&quot;&gt;&gt;}"},{"ref":"string.html#titlecase/1","title":"string.titlecase/1","type":"function","doc":"Converts String to titlecase. Example: 1&gt; string:titlecase(&quot; is a SHARP s&quot;). &quot;Ss is a SHARP s&quot;"},{"ref":"string.html#to_float/1","title":"string.to_float/1","type":"function","doc":"Argument String is expected to start with a valid text represented float (the digits are ASCII values). Remaining characters in the string after the float are returned in Rest. Example: &gt; {F1,Fs} = string:to_float(&quot;1.0-1.0e-1&quot;), &gt; {F2,[]} = string:to_float(Fs), &gt; F1+F2. 0.9 &gt; string:to_float(&quot;3/2=1.5&quot;). {error,no_float} &gt; string:to_float(&quot;-1.5eX&quot;). {-1.5,&quot;eX&quot;}"},{"ref":"string.html#to_graphemes/1","title":"string.to_graphemes/1","type":"function","doc":"Converts String to a list of grapheme clusters. Example: 1&gt; string:to_graphemes(&quot;e&quot;). [223,8593,[101,778]] 2&gt; string:to_graphemes(&lt;&lt;&quot;e&quot;/utf8&gt;&gt;). [223,8593,[101,778]]"},{"ref":"string.html#to_integer/1","title":"string.to_integer/1","type":"function","doc":"Argument String is expected to start with a valid text represented integer (the digits are ASCII values). Remaining characters in the string after the integer are returned in Rest. Example: &gt; {I1,Is} = string:to_integer(&quot;33+22&quot;), &gt; {I2,[]} = string:to_integer(Is), &gt; I1-I2. 11 &gt; string:to_integer(&quot;0.5&quot;). {0,&quot;.5&quot;} &gt; string:to_integer(&quot;x=2&quot;). {error,no_integer}"},{"ref":"string.html#to_lowerto_lowerto_upperto_upper/1111","title":"string.to_lowerto_lowerto_upperto_upper/1111","type":"function","doc":"The specified string or character is case-converted. Notice that the supported character set is ISO/IEC 8859-1 (also called Latin 1); all values outside this set are unchanged This function is obsolete use lowercase/1, uppercase/1, titlecase/1 or casefold/1."},{"ref":"string.html#tokens/2","title":"string.tokens/2","type":"function","doc":"Returns a list of tokens in String, separated by the characters in SeparatorList. Example: &gt; tokens(&quot;abc defxxghix jkl&quot;, &quot;x &quot;). [&quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;] Notice that, as shown in this example, two or more adjacent separator characters in String are treated as one. That is, there are no empty strings in the resulting list of tokens. This function is obsolete. Use lexemes/2."},{"ref":"string.html#trimtrimtrim/123","title":"string.trimtrimtrim/123","type":"function","doc":"Returns a string, where leading or trailing, or both, Characters have been removed. Dir which can be leading, trailing, or both, indicates from which direction characters are to be removed. Default Characters is the set of nonbreakable whitespace codepoints, defined as Pattern_White_Space in Unicode Standard Annex #31. By default, ``Dir is both. Notice that [$\\r,$\\n] is one grapheme cluster according to the Unicode Standard. Example: 1&gt; string:trim(&quot;\\t Hello \\n&quot;). &quot;Hello&quot; 2&gt; string:trim(&lt;&lt;&quot;\\t Hello \\n&quot;&gt;&gt;, leading). &lt;&lt;&quot;Hello \\n&quot;&gt;&gt; 3&gt; string:trim(&lt;&lt;&quot;.Hello.\\n&quot;&gt;&gt;, trailing, &quot;\\n.&quot;). &lt;&lt;&quot;.Hello&quot;&gt;&gt;"},{"ref":"string.html#uppercase/1","title":"string.uppercase/1","type":"function","doc":"Converts String to uppercase. See also titlecase/1. Example: 1&gt; string:uppercase(&quot;Micha&quot;). &quot;MICHA&quot;"},{"ref":"string.html#wordswords/12","title":"string.wordswords/12","type":"function","doc":"Returns the number of words in String, separated by blanks or Character. This function is obsolete. Use lexemes/2. Example: &gt; words(&quot; Hello old boy!&quot;, $o). 4"},{"ref":"supervisor.html","title":"supervisor","type":"behaviour","doc":"This behavior module provides a supervisor, a process that supervises other processes called child processes. A child process can either be another supervisor or a worker process. Worker processes are normally implemented using one of the gen_event, gen_server, or gen_statem behaviors. A supervisor implemented using this module has a standard set of interface functions and include functionality for tracing and error reporting. Supervisors are used to build a hierarchical process structure called a supervision tree, a nice way to structure a fault-tolerant application. For more information, see Supervisor Behaviour in OTP Design Principles. A supervisor expects the definition of which child processes to supervise to be specified in a callback module exporting a predefined set of functions. Unless otherwise stated, all functions in this module fail if the specified supervisor does not exist or if bad arguments are specified."},{"ref":"supervisor.html#check_childspecs/1","title":"supervisor.check_childspecs/1","type":"function","doc":"Takes a list of child specification as argument and returns ok if all of them are syntactically correct, otherwise {error,``Error``}."},{"ref":"supervisor.html#count_children/1","title":"supervisor.count_children/1","type":"function","doc":"Returns a property list (see proplists) containing the counts for each of the following elements of the supervisor&#39;s child specifications and managed processes: * `specs` - The total count of children, dead or alive. * `active` - The count of all actively running child processes managed by this supervisor. For a `simple_one_for_one` supervisors, no check is done to ensure that each child process is still alive, although the result provided here is likely to be very accurate unless the supervisor is heavily overloaded. * `supervisors` - The count of all children marked as `child_type = supervisor` in the specification list, regardless if the child process is still alive. * `workers` - The count of all children marked as `child_type = worker` in the specification list, regardless if the child process is still alive. For a description of SupRef, see start_child/2."},{"ref":"supervisor.html#delete_child/2","title":"supervisor.delete_child/2","type":"function","doc":"Tells supervisor SupRef to delete the child specification identified by Id. The corresponding child process must not be running. Use terminate_child/2 to terminate it. For a description of SupRef, see start_child/2. If successful, the function returns ok. If the child specification identified by Id exists but the corresponding child process is running or is about to be restarted, the function returns {error,running} or {error,restarting}, respectively. If the child specification identified by Id does not exist, the function returns {error,not_found}."},{"ref":"supervisor.html#get_childspec/2","title":"supervisor.get_childspec/2","type":"function","doc":"Returns the child specification map for the child identified by Id under supervisor SupRef. The returned map contains all keys, both mandatory and optional. For a description of SupRef, see start_child/2."},{"ref":"supervisor.html#restart_child/2","title":"supervisor.restart_child/2","type":"function","doc":"Tells supervisor SupRef to restart a child process corresponding to the child specification identified by Id. The child specification must exist, and the corresponding child process must not be running. Notice that for temporary children, the child specification is automatically deleted when the child terminates; thus, it is not possible to restart such children. For a description of SupRef, see start_child/2. If the child specification identified by Id does not exist, the function returns {error,not_found}. If the child specification exists but the corresponding process is already running, the function returns {error,running}. If the child process start function returns {ok,``Child``} or {ok,``Child``,``Info``}, the pid is added to the supervisor and the function returns the same value. If the child process start function returns ignore, the pid remains set to undefined and the function returns {ok,undefined}. If the child process start function returns an error tuple or an erroneous value, or if it fails, the function returns {error,``Error``}, where Error is a term containing information about the error."},{"ref":"supervisor.html#start_child/2","title":"supervisor.start_child/2","type":"function","doc":"Dynamically adds a child specification to supervisor SupRef, which starts the corresponding child process. SupRef can be any of the following: * The pid * `Name`, if the supervisor is locally registered * `{Name,Node}`, if the supervisor is locally registered at another node * `{global,Name}`, if the supervisor is globally registered * `{via,Module,Name}`, if the supervisor is registered through an alternative process registry `ChildSpec` must be a valid child specification (unless the supervisor is a `simple_one_for_one` supervisor; see below). The child process is started by using the start function as defined in the child specification. For a simple_one_for_one supervisor, the child specification defined in Module:init/1 is used, and ChildSpec must instead be an arbitrary list of terms List. The child process is then started by appending List to the existing start function arguments, that is, by calling apply(M, F, A++``List``), where {M,F,A} is the start function defined in the child specification. * If there already exists a child specification with the specified identifier, `ChildSpec` is discarded, and the function returns `{error,already_present}` or `{error,{already_started,``Child``}}`, depending on if the corresponding child process is running or not. * If the child process start function returns `{ok,``Child``}` or `{ok,``Child``,``Info``}`, the child specification and pid are added to the supervisor and the function returns the same value. * If the child process start function returns `ignore`, the child specification is added to the supervisor (unless the supervisor is a `simple_one_for_one` supervisor, see below), the pid is set to `undefined`, and the function returns `{ok,undefined}`. For a simple_one_for_one supervisor, when a child process start function returns ignore, the functions returns {ok,undefined} and no child is added to the supervisor. If the child process start function returns an error tuple or an erroneous value, or if it fails, the child specification is discarded, and the function returns {error,Error}, where Error is a term containing information about the error and child specification."},{"ref":"supervisor.html#start_linkstart_link/23","title":"supervisor.start_linkstart_link/23","type":"function","doc":"Creates a supervisor process as part of a supervision tree. For example, the function ensures that the supervisor is linked to the calling process (its supervisor). The created supervisor process calls Module``:init/1 to find out about restart strategy, maximum restart intensity, and child processes. To ensure a synchronized startup procedure, start_link/2,3 does not return until Module``:init/1 has returned and all child processes have been started. * If `SupName``={local,Name}`, the supervisor is registered locally as `Name` using `register/2`. * If `SupName``={global,Name}`, the supervisor is registered globally as `Name` using `global:register_name/2`. * If `SupName``={via,``Module``,``Name``}`, the supervisor is registered as `Name` using the registry represented by [`Module`](https://hexdocs.pm/elixir/Module.html). The [`Module`](https://hexdocs.pm/elixir/Module.html) callback must export the functions `register_name/2`, `unregister_name/1`, and [`send/2`](https://hexdocs.pm/elixir/Kernel.html#send/2), which must behave like the corresponding functions in `global`. Thus, `{via,global,``Name``}` is a valid reference. If no name is provided, the supervisor is not registered. Module is the name of the callback module. Args is any term that is passed as the argument to Module``:init/1. * If the supervisor and its child processes are successfully created (that is, if all child process start functions return `{ok,Child}`, `{ok,Child,Info}`, or `ignore`), the function returns `{ok,Pid}`, where `Pid` is the pid of the supervisor. * If there already exists a process with the specified `SupName`, the function returns `{error,{already_started,Pid}}`, where `Pid` is the pid of that process. * If `Module``:init/1` returns `ignore`, this function returns `ignore` as well, and the supervisor terminates with reason `normal`. * If `Module``:init/1` fails or returns an incorrect value, this function returns `{error,Term}`, where `Term` is a term with information about the error, and the supervisor terminates with reason `Term`. * If any child process start function fails or returns an error tuple or an erroneous value, the supervisor first terminates all already started child processes with reason `shutdown` and then terminate itself and returns `{error, {shutdown, Reason}}`."},{"ref":"supervisor.html#terminate_child/2","title":"supervisor.terminate_child/2","type":"function","doc":"Tells supervisor SupRef to terminate the specified child. If the supervisor is not simple_one_for_one, Id must be the child specification identifier. The process, if any, is terminated and, unless it is a temporary child, the child specification is kept by the supervisor. The child process can later be restarted by the supervisor. The child process can also be restarted explicitly by calling restart_child/2. Use delete_child/2 to remove the child specification. If the child is temporary, the child specification is deleted as soon as the process terminates. This means that delete_child/2 has no meaning and restart_child/2 cannot be used for these children. If the supervisor is simple_one_for_one, Id must be the pid() of the child process. If the specified process is alive, but is not a child of the specified supervisor, the function returns {error,not_found}. If the child specification identifier is specified instead of a pid(), the function returns {error,simple_one_for_one}. If successful, the function returns ok. If there is no child specification with the specified Id, the function returns {error,not_found}. For a description of SupRef, see start_child/2."},{"ref":"supervisor.html#which_children/1","title":"supervisor.which_children/1","type":"function","doc":"Returns a newly created list with information about all child specifications and child processes belonging to supervisor SupRef. Notice that calling this function when supervising many childrens under low memory conditions can cause an out of memory exception. For a description of SupRef, see start_child/2. The following information is given for each child specification/process: * `Id` - As defined in the child specification or `undefined` for a `simple_one_for_one` supervisor. * `Child` - The pid of the corresponding child process, the atom `restarting` if the process is about to be restarted, or `undefined` if there is no such process. * `Type` - As defined in the child specification. * `Modules` - As defined in the child specification."},{"ref":"supervisor_bridge.html","title":"supervisor_bridge","type":"behaviour","doc":"This behavior module provides a supervisor bridge, a process that connects a subsystem not designed according to the OTP design principles to a supervision tree. The supervisor bridge sits between a supervisor and the subsystem. It behaves like a real supervisor to its own supervisor, but has a different interface than a real supervisor to the subsystem. For more information, see Supervisor Behaviour in OTP Design Principles. A supervisor bridge assumes the functions for starting and stopping the subsystem to be located in a callback module exporting a predefined set of functions. The sys(3) module can be used for debugging a supervisor bridge. Unless otherwise stated, all functions in this module fail if the specified supervisor bridge does not exist or if bad arguments are specified."},{"ref":"supervisor_bridge.html#start_linkstart_link/23","title":"supervisor_bridge.start_linkstart_link/23","type":"function","doc":"Creates a supervisor bridge process, linked to the calling process, which calls Module``:init/1 to start the subsystem. To ensure a synchronized startup procedure, this function does not return until Module``:init/1 has returned. * If `SupBridgeName``={local,``Name``}`, the supervisor bridge is registered locally as `Name` using `register/2`. * If `SupBridgeName``={global,``Name``}`, the supervisor bridge is registered globally as `Name` using `global:register_name/2`. * If `SupBridgeName``={via,``Module``,``Name``}`, the supervisor bridge is registered as `Name` using a registry represented by Module. The [`Module`](https://hexdocs.pm/elixir/Module.html) callback is to export functions `register_name/2`, `unregister_name/1`, and [`send/2`](https://hexdocs.pm/elixir/Kernel.html#send/2), which are to behave like the corresponding functions in `global`. Thus, `{via,global,GlobalName}` is a valid reference. If no name is provided, the supervisor bridge is not registered. Module is the name of the callback module. Args is an arbitrary term that is passed as the argument to Module``:init/1. * If the supervisor bridge and the subsystem are successfully started, the function returns `{ok,``Pid``}`, where `Pid` is is the pid of the supervisor bridge. * If there already exists a process with the specified `SupBridgeName`, the function returns `{error,{already_started,``Pid``}}`, where `Pid` is the pid of that process. * If `Module``:init/1` returns `ignore`, this function returns `ignore` as well and the supervisor bridge terminates with reason `normal`. * If `Module``:init/1` fails or returns an error tuple or an incorrect value, this function returns `{error,``Error``r}`, where `Error` is a term with information about the error, and the supervisor bridge terminates with reason `Error`."},{"ref":"sys.html","title":"sys","type":"module","doc":"This module contains functions for sending system messages used by programs, and messages used for debugging purposes. Functions used for implementation of processes are also expected to understand system messages, such as debug messages and code change. These functions must be used to implement the use of system messages for a process; either directly, or through standard behaviors, such as gen_server. The default time-out is 5000 ms, unless otherwise specified. timeout defines the time to wait for the process to respond to a request. If the process does not respond, the function evaluates exit({timeout, {M, F, A}}). The functions make references to a debug structure. The debug structure is a list of dbg_opt(), which is an internal data type used by function handle_system_msg/6. No debugging is performed if it is an empty list."},{"ref":"sys.html#change_codechange_code/45","title":"sys.change_codechange_code/45","type":"function","doc":"Tells the process to change code. The process must be suspended to handle this message. Argument Extra is reserved for each process to use as its own. Function Module``:system_code_change/4 is called. OldVsn is the old version of the Module."},{"ref":"sys.html#debug_options/1","title":"sys.debug_options/1","type":"function","doc":"Can be used by a process that initiates a debug structure from a list of options. The values of argument Opt are the same as for the corresponding functions."},{"ref":"sys.html#get_debug/3","title":"sys.get_debug/3","type":"function","doc":"get_debug/3 is deprecated since it returns data of an internal type only useful for debugging. Gets the data associated with a debug option. Default is returned if Item is not found. Can be used by the process to retrieve debug data for printing before it terminates."},{"ref":"sys.html#get_log/1","title":"sys.get_log/1","type":"function","doc":"Returns the logged system events in the debug structure, that is the last argument to handle_debug/4."},{"ref":"sys.html#get_stateget_state/12","title":"sys.get_stateget_state/12","type":"function","doc":"Gets the state of the process. These functions are intended only to help with debugging. They are provided for convenience, allowing developers to avoid having to create their own state extraction functions and also avoid having to interactively extract the state from the return values of get_status/1 or get_status/2 while debugging. The value of State varies for different types of processes, as follows: * For a `gen_server` process, the returned `State` is the state of the callback module. * For a `gen_statem` process, `State` is the tuple `{CurrentState,CurrentData}`. * For a `gen_event` process, `State` is a list of tuples, where each tuple corresponds to an event handler registered in the process and contains `{Module, Id, HandlerState}`, as follows: Module * The module name of the event handler. Id * The ID of the handler (which is false if it was registered without an ID). HandlerState * The state of the handler. If the callback module exports a function `system_get_state/1`, it is called in the target process to get its state. Its argument is the same as the `Misc` value returned by `get_status/1,2`, and function `Module:system_get_state/1` is expected to extract the state of the callback module from it. Function `system_get_state/1` must return `{ok, State}`, where `State` is the state of the callback module. If the callback module does not export a system_get_state/1 function, get_state/1,2 assumes that the Misc value is the state of the callback module and returns it directly instead. If the callback module&#39;s system_get_state/1 function crashes or throws an exception, the caller exits with error {callback_failed, {Module, system_get_state}, {Class, Reason}}, where Module is the name of the callback module and Class and Reason indicate details of the exception. Function system_get_state/1 is primarily useful for user-defined behaviors and modules that implement OTP special processes. The gen_server, gen_statem, and gen_event OTP behavior modules export this function, so callback modules for those behaviors need not to supply their own. For more information about a process, including its state, see get_status/1 and get_status/2."},{"ref":"sys.html#get_statusget_status/12","title":"sys.get_statusget_status/12","type":"function","doc":"Gets the status of the process. The value of Misc varies for different types of processes, for example: * A `gen_server` process returns the state of the callback module. * A `gen_statem` process returns information, such as its current state name and state data. * A `gen_event` process returns information about each of its registered handlers. Callback modules for gen_server, gen_statem, and gen_event can also change the value of Misc by exporting a function format_status/2, which contributes module-specific information. For details, see gen_server:format_status/2, gen_statem:format_status/2, and gen_event:format_status/2."},{"ref":"sys.html#handle_debug/4","title":"sys.handle_debug/4","type":"function","doc":"This function is called by a process when it generates a system event. FormFunc is a formatting function, called as FormFunc``(Device, ``Event``, ``Extra``) to print the events, which is necessary if tracing is activated. Extra is any extra information that the process needs in the format function, for example, the process name."},{"ref":"sys.html#handle_system_msg/6","title":"sys.handle_system_msg/6","type":"function","doc":"This function is used by a process module to take care of system messages. The process receives a {system, ``From``, ``Msg``} message and passes Msg and From to this function. This function never returns. It calls either of the following functions: * `Module``:system_continue(``Parent``, NDebug, ``Misc``)`, where the process continues the execution. * `Module``:system_terminate(Reason, ``Parent``, ``Debug``, ``Misc``)`, if the process is to terminate. Module must export the following: * `system_continue/3` * `system_terminate/4` * `system_code_change/4` * `system_get_state/1` * `system_replace_state/2` Argument `Misc` can be used to save internal data in a process, for example, its state. It is sent to `Module``:system_continue/3` or `Module``:system_terminate/4`."},{"ref":"sys.html#installinstall/23","title":"sys.installinstall/23","type":"function","doc":"Enables installation of alternative debug functions. An example of such a function is a trigger, a function that waits for some special event and performs some action when the event is generated. For example, turning on low-level tracing. Func is called whenever a system event is generated. This function is to return done, or a new Func state. In the first case, the function is removed. It is also removed if the function fails. If one debug function should be installed more times, a unique FuncId must be specified for each installation."},{"ref":"sys.html#log_to_filelog_to_file/23","title":"sys.log_to_filelog_to_file/23","type":"function","doc":"Enables or disables the logging of all system events in text format to the file. The events are formatted with a function that is defined by the process that generated the event (with a call to handle_debug/4). The file is opened with encoding UTF-8."},{"ref":"sys.html#loglog/23","title":"sys.loglog/23","type":"function","doc":"Turns the logging of system events on or off. If on, a maximum of N events are kept in the debug structure (default is 10). If Flag is get, a list of all logged events is returned. If Flag is print, the logged events are printed to standard_io. The events are formatted with a function that is defined by the process that generated the event (with a call to handle_debug/4)."},{"ref":"sys.html#no_debugno_debug/12","title":"sys.no_debugno_debug/12","type":"function","doc":"Turns off all debugging for the process. This includes functions that are installed explicitly with function install/2,3, for example, triggers."},{"ref":"sys.html#print_log/1","title":"sys.print_log/1","type":"function","doc":"Prints the logged system events in the debug structure, using FormFunc as defined when the event was generated by a call to handle_debug/4."},{"ref":"sys.html#removeremove/23","title":"sys.removeremove/23","type":"function","doc":"Removes an installed debug function from the process. Func or FuncId must be the same as previously installed."},{"ref":"sys.html#replace_statereplace_state/23","title":"sys.replace_statereplace_state/23","type":"function","doc":"Replaces the state of the process, and returns the new state. These functions are intended only to help with debugging, and are not to be called from normal code. They are provided for convenience, allowing developers to avoid having to create their own custom state replacement functions. Function StateFun provides a new state for the process. Argument State and the NewState return value of StateFun vary for different types of processes as follows: * For a `gen_server` process, `State` is the state of the callback module and `NewState` is a new instance of that state. * For a `gen_statem` process, `State` is the tuple `{CurrentState,CurrentData}`, and `NewState` is a similar tuple, which can contain a new current state, new state data, or both. * For a `gen_event` process, `State` is the tuple `{Module, Id, HandlerState}` as follows: Module * The module name of the event handler. Id * The ID of the handler (which is false if it was registered without an ID). HandlerState * The state of the handler. NewState is a similar tuple where Module and Id are to have the same values as in State, but the value of HandlerState can be different. Returning a NewState, whose Module or Id values differ from those of State, leaves the state of the event handler unchanged. For a gen_event process, StateFun is called once for each event handler registered in the gen_event process. If a StateFun function decides not to effect any change in process state, then regardless of process type, it can return its State argument. If a StateFun function crashes or throws an exception, the original state of the process is unchanged for gen_server, and gen_statem processes. For gen_event processes, a crashing or failing StateFun function means that only the state of the particular event handler it was working on when it failed or crashed is unchanged; it can still succeed in changing the states of other event handlers registered in the same gen_event process. If the callback module exports a system_replace_state/2 function, it is called in the target process to replace its state using StateFun. Its two arguments are StateFun and Misc, where Misc is the same as the Misc value returned by get_status/1,2. A system_replace_state/2 function is expected to return {ok, NewState, NewMisc}, where NewState is the new state of the callback module, obtained by calling StateFun, and NewMisc is a possibly new value used to replace the original Misc (required as Misc often contains the state of the callback module within it). If the callback module does not export a system_replace_state/2 function, replace_state/2,3 assumes that Misc is the state of the callback module, passes it to StateFun and uses the return value as both the new state and as the new value of Misc. If the callback module&#39;s function system_replace_state/2 crashes or throws an exception, the caller exits with error {callback_failed, {Module, system_replace_state}, {Class, Reason}}, where Module is the name of the callback module and Class and Reason indicate details of the exception. If the callback module does not provide a system_replace_state/2 function and StateFun crashes or throws an exception, the caller exits with error {callback_failed, StateFun, {Class, Reason}}. Function system_replace_state/2 is primarily useful for user-defined behaviors and modules that implement OTP special processes. The OTP behavior modules gen_server, gen_statem, and gen_event export this function, so callback modules for those behaviors need not to supply their own."},{"ref":"sys.html#resumeresume/12","title":"sys.resumeresume/12","type":"function","doc":"Resumes a suspended process."},{"ref":"sys.html#statisticsstatistics/23","title":"sys.statisticsstatistics/23","type":"function","doc":"Enables or disables the collection of statistics. If Flag is get, the statistical collection is returned."},{"ref":"sys.html#suspendsuspend/12","title":"sys.suspendsuspend/12","type":"function","doc":"Suspends the process. When the process is suspended, it only responds to other system messages, but not other messages."},{"ref":"sys.html#terminateterminate/23","title":"sys.terminateterminate/23","type":"function","doc":"Orders the process to terminate with the specified Reason. The termination is done asynchronously, so it is not guaranteed that the process is terminated when the function returns."},{"ref":"sys.html#tracetrace/23","title":"sys.tracetrace/23","type":"function","doc":"Prints all system events on standard_io. The events are formatted with a function that is defined by the process that generated the event (with a call to handle_debug/4)."},{"ref":"timer.html","title":"timer","type":"module","doc":"This module provides useful functions related to time. Unless otherwise stated, time is always measured in milliseconds. All timer functions return immediately, regardless of work done by another process. Successful evaluations of the timer functions give return values containing a timer reference, denoted TRef. By using cancel/1, the returned reference can be used to cancel any requested action. A TRef is an Erlang term, which contents must not be changed. The time-outs are not exact, but are at least as long as requested."},{"ref":"timer.html#apply_after/4","title":"timer.apply_after/4","type":"function","doc":"Evaluates apply(``Module``, ``Function``, ``Arguments``) after Time milliseconds. Returns {ok, ``TRef``} or {error, ``Reason``}."},{"ref":"timer.html#apply_interval/4","title":"timer.apply_interval/4","type":"function","doc":"Evaluates apply(``Module``, ``Function``, ``Arguments``) repeatedly at intervals of Time. Returns {ok, ``TRef``} or {error, ``Reason``}."},{"ref":"timer.html#cancel/1","title":"timer.cancel/1","type":"function","doc":"Cancels a previously requested time-out. TRef is a unique timer reference returned by the related timer function. Returns {ok, cancel}, or {error, ``Reason``} when TRef is not a timer reference."},{"ref":"timer.html#exit_afterexit_after/23","title":"timer.exit_afterexit_after/23","type":"function","doc":"exit_after/2 is the same as exit_after(``Time``, self(), ``Reason1``). exit_after/3 sends an exit signal with reason Reason1 to pid Pid. Returns {ok, ``TRef``} or {error, ``Reason2``}."},{"ref":"timer.html#hms/3","title":"timer.hms/3","type":"function","doc":"Returns the number of milliseconds in Hours`` + ``Minutes`` + ``Seconds."},{"ref":"timer.html#hours/1","title":"timer.hours/1","type":"function","doc":"Returns the number of milliseconds in Hours."},{"ref":"timer.html#kill_afterkill_after/12","title":"timer.kill_afterkill_after/12","type":"function","doc":"kill_after/1 is the same as exit_after(``Time``, self(), kill). kill_after/2 is the same as exit_after(``Time``, ``Pid``, kill)."},{"ref":"timer.html#minutes/1","title":"timer.minutes/1","type":"function","doc":"Returns the number of milliseconds in Minutes."},{"ref":"timer.html#now_diff/2","title":"timer.now_diff/2","type":"function","doc":"Calculates the time difference Tdiff`` = ``T2`` - ``T1 in microseconds, where T1 and T2 are time-stamp tuples on the same format as returned from erlang:timestamp/0 or os:timestamp/0."},{"ref":"timer.html#seconds/1","title":"timer.seconds/1","type":"function","doc":"Returns the number of milliseconds in Seconds."},{"ref":"timer.html#send_aftersend_after/23","title":"timer.send_aftersend_after/23","type":"function","doc":"send_after/3 * Evaluates Pid`` ! ``Message after Time milliseconds. (Pid can also be an atom of a registered name.) Returns {ok, ``TRef``} or {error, ``Reason``}. send_after/2 * Same as send_after(``Time``, self(), ``Message``)."},{"ref":"timer.html#send_intervalsend_interval/23","title":"timer.send_intervalsend_interval/23","type":"function","doc":"send_interval/3 * Evaluates Pid`` ! ``Message repeatedly after Time milliseconds. (Pid can also be an atom of a registered name.) Returns {ok, ``TRef``} or {error, ``Reason``}. send_interval/2 * Same as send_interval(``Time``, self(), ``Message``)."},{"ref":"timer.html#sleep/1","title":"timer.sleep/1","type":"function","doc":"Suspends the process calling this function for Time milliseconds and then returns ok, or suspends the process forever if Time is the atom infinity. Naturally, this function does not return immediately."},{"ref":"timer.html#start/0","title":"timer.start/0","type":"function","doc":"Starts the timer server. Normally, the server does not need to be started explicitly. It is started dynamically if it is needed. This is useful during development, but in a target system the server is to be started explicitly. Use configuration parameters for Kernel for this."},{"ref":"timer.html#tctctc/123","title":"timer.tctctc/123","type":"function","doc":"tc/3 * Evaluates apply(``Module``, ``Function``, ``Arguments``) and measures the elapsed real time as reported by erlang:monotonic_time/0. Returns {``Time``, ``Value``}, where Time is the elapsed real time in microseconds, and Value is what is returned from the apply. tc/2 * Evaluates apply(``Fun``, ``Arguments``). Otherwise the same as tc/3. tc/1 * Evaluates Fun``(). Otherwise the same as tc/2."},{"ref":"unicode.html","title":"unicode","type":"module","doc":"This module contains functions for converting between different character representations. It converts between ISO Latin-1 characters and Unicode characters, but it can also convert between different Unicode encodings (like UTF-8, UTF-16, and UTF-32). The default Unicode encoding in Erlang is in binaries UTF-8, which is also the format in which built-in functions and libraries in OTP expect to find binary Unicode data. In lists, Unicode data is encoded as integers, each integer representing one character and encoded simply as the Unicode code point for the character. Other Unicode encodings than integers representing code points or UTF-8 in binaries are referred to as &quot;external encodings&quot;. The ISO Latin-1 encoding is in binaries and lists referred to as latin1-encoding. It is recommended to only use external encodings for communication with external entities where this is required. When working inside the Erlang/OTP environment, it is recommended to keep binaries in UTF-8 when representing Unicode characters. ISO Latin-1 encoding is supported both for backward compatibility and for communication with external entities not supporting Unicode character sets. Programs should always operate on a normalized form and compare canonical-equivalent Unicode characters as equal. All characters should thus be normalized to one form once on the system borders. One of the following functions can convert characters to their normalized forms characters_to_nfc_list/1, characters_to_nfc_binary/1, characters_to_nfd_list/1 or characters_to_nfd_binary/1. For general text characters_to_nfc_list/1 or characters_to_nfc_binary/1 is preferred, and for identifiers one of the compatibility normalization functions, such as characters_to_nfkc_list/1, is preferred for security reasons. The normalization functions where introduced in OTP 20. Additional information on normalization can be found in the Unicode FAQ."},{"ref":"unicode.html#bom_to_encoding/1","title":"unicode.bom_to_encoding/1","type":"function","doc":"Checks for a UTF Byte Order Mark (BOM) in the beginning of a binary. If the supplied binary Bin begins with a valid BOM for either UTF-8, UTF-16, or UTF-32, the function returns the encoding identified along with the BOM length in bytes. If no BOM is found, the function returns {latin1,0}."},{"ref":"unicode.html#characters_to_binary/1","title":"unicode.characters_to_binary/1","type":"function","doc":"Same as characters_to_binary(``Data``, unicode, unicode)."},{"ref":"unicode.html#characters_to_binary/2","title":"unicode.characters_to_binary/2","type":"function","doc":"Same as characters_to_binary(``Data``, ``InEncoding``, unicode)."},{"ref":"unicode.html#characters_to_binary/3","title":"unicode.characters_to_binary/3","type":"function","doc":"Behaves as characters_to_list/2, but produces a binary instead of a Unicode list. InEncoding defines how input is to be interpreted if binaries are present in Data OutEncoding defines in what format output is to be generated. Options: unicode * An alias for utf8, as this is the preferred encoding for Unicode characters in binaries. utf16 * An alias for {utf16,big}. utf32 * An alias for {utf32,big}. The atoms big and little denote big- or little-endian encoding. Errors and exceptions occur as in characters_to_list/2, but the second element in tuple error or incomplete is a binary() and not a list()."},{"ref":"unicode.html#characters_to_list/1","title":"unicode.characters_to_list/1","type":"function","doc":"Same as characters_to_list(``Data``, unicode)."},{"ref":"unicode.html#characters_to_list/2","title":"unicode.characters_to_list/2","type":"function","doc":"Converts a possibly deep list of integers and binaries into a list of integers representing Unicode characters. The binaries in the input can have characters encoded as one of the following: * ISO Latin-1 (0-255, one character per byte). Here, case parameter `InEncoding` is to be specified as `latin1`. * One of the UTF-encodings, which is specified as parameter `InEncoding`. Note that integers in the list always represent code points regardless of `InEncoding` passed. If `InEncoding`` latin1` is passed, only code points &lt; 256 are allowed; otherwise, all valid unicode code points are allowed. If InEncoding is latin1, parameter Data corresponds to the iodata() type, but for unicode, parameter Data can contain integers &gt; 255 (Unicode characters beyond the ISO Latin-1 range), which makes it invalid as iodata(). The purpose of the function is mainly to convert combinations of Unicode characters into a pure Unicode string in list representation for further processing. For writing the data to an external entity, the reverse function characters_to_binary/3 comes in handy. Option unicode is an alias for utf8, as this is the preferred encoding for Unicode characters in binaries. utf16 is an alias for {utf16,big} and utf32 is an alias for {utf32,big}. The atoms big and little denote big- or little-endian encoding. If the data cannot be converted, either because of illegal Unicode/ISO Latin-1 characters in the list, or because of invalid UTF encoding in any binaries, an error tuple is returned. The error tuple contains the tag error, a list representing the characters that could be converted before the error occurred and a representation of the characters including and after the offending integer/bytes. The last part is mostly for debugging, as it still constitutes a possibly deep or mixed list, or both, not necessarily of the same depth as the original data. The error occurs when traversing the list and whatever is left to decode is returned &quot;as is&quot;. However, if the input Data is a pure binary, the third part of the error tuple is guaranteed to be a binary as well. Errors occur for the following reasons: * Integers out of range. If InEncoding is latin1, an error occurs whenever an integer &gt; 255 is found in the lists. If InEncoding is of a Unicode type, an error occurs whenever either of the following is found: * An integer &gt; 16#10FFFF (the maximum Unicode character) * An integer in the range 16#D800 to 16#DFFF (invalid range reserved for UTF-16 surrogate pairs) * Incorrect UTF encoding. If InEncoding is one of the UTF types, the bytes in any binaries must be valid in that encoding. Errors can occur for various reasons, including the following: * &quot;Pure&quot; decoding errors (like the upper bits of the bytes being wrong). * The bytes are decoded to a too large number. * The bytes are decoded to a code point in the invalid Unicode range. * Encoding is &quot;overlong&quot;, meaning that a number should have been encoded in fewer bytes. The case of a truncated UTF is handled specially, see the paragraph about incomplete binaries below. If InEncoding is latin1, binaries are always valid as long as they contain whole bytes, as each byte falls into the valid ISO Latin-1 range. A special type of error is when no actual invalid integers or bytes are found, but a trailing binary() consists of too few bytes to decode the last character. This error can occur if bytes are read from a file in chunks or if binaries in other ways are split on non-UTF character boundaries. An incomplete tuple is then returned instead of the error tuple. It consists of the same parts as the error tuple, but the tag is incomplete instead of error and the last element is always guaranteed to be a binary consisting of the first part of a (so far) valid UTF character. If one UTF character is split over two consecutive binaries in the Data, the conversion succeeds. This means that a character can be decoded from a range of binaries as long as the whole range is specified as input without errors occurring. Example: decode_data(Data) -&gt; case unicode:characters_to_list(Data,unicode) of {incomplete,Encoded, Rest} -&gt; More = get_some_more_data(), Encoded ++ decode_data([Rest, More]); {error,Encoded,Rest} -&gt; handle_error(Encoded,Rest); List -&gt; List end. However, bit strings that are not whole bytes are not allowed, so a UTF character must be split along 8-bit boundaries to ever be decoded. A badarg exception is thrown for the following cases: * Any parameters are of the wrong type. * The list structure is invalid (a number as tail). * The binaries do not contain whole bytes (bit strings)."},{"ref":"unicode.html#characters_to_nfc_binary/1","title":"unicode.characters_to_nfc_binary/1","type":"function","doc":"Converts a possibly deep list of characters and binaries into a Normalized Form of canonical equivalent Composed characters according to the Unicode standard. Any binaries in the input must be encoded with utf8 encoding. The result is an utf8 encoded binary. 4&gt; unicode:characters_to_nfc_binary([&lt;&lt;&quot;abc..a&quot;&gt;&gt;,[778],$a,[776],$o,[776]]). &lt;&lt;&quot;abc..&quot;/utf8&gt;&gt;"},{"ref":"unicode.html#characters_to_nfc_list/1","title":"unicode.characters_to_nfc_list/1","type":"function","doc":"Converts a possibly deep list of characters and binaries into a Normalized Form of canonical equivalent Composed characters according to the Unicode standard. Any binaries in the input must be encoded with utf8 encoding. The result is a list of characters. 3&gt; unicode:characters_to_nfc_list([&lt;&lt;&quot;abc..a&quot;&gt;&gt;,[778],$a,[776],$o,[776]]). &quot;abc..&quot;"},{"ref":"unicode.html#characters_to_nfd_binary/1","title":"unicode.characters_to_nfd_binary/1","type":"function","doc":"Converts a possibly deep list of characters and binaries into a Normalized Form of canonical equivalent Decomposed characters according to the Unicode standard. Any binaries in the input must be encoded with utf8 encoding. The result is an utf8 encoded binary. 2&gt; unicode:characters_to_nfd_binary(&quot;abc..&quot;). &lt;&lt;97,98,99,46,46,97,204,138,97,204,136,111,204,136&gt;&gt;"},{"ref":"unicode.html#characters_to_nfd_list/1","title":"unicode.characters_to_nfd_list/1","type":"function","doc":"Converts a possibly deep list of characters and binaries into a Normalized Form of canonical equivalent Decomposed characters according to the Unicode standard. Any binaries in the input must be encoded with utf8 encoding. The result is a list of characters. 1&gt; unicode:characters_to_nfd_list(&quot;abc..&quot;). [97,98,99,46,46,97,778,97,776,111,776]"},{"ref":"unicode.html#characters_to_nfkc_binary/1","title":"unicode.characters_to_nfkc_binary/1","type":"function","doc":"Converts a possibly deep list of characters and binaries into a Normalized Form of compatibly equivalent Composed characters according to the Unicode standard. Any binaries in the input must be encoded with utf8 encoding. The result is an utf8 encoded binary. 4&gt; unicode:characters_to_nfkc_binary([&lt;&lt;&quot;abc..a&quot;&gt;&gt;,[778],$a,[776],$o,[776],[65299,65298]]). &lt;&lt;&quot;abc..32&quot;/utf8&gt;&gt;"},{"ref":"unicode.html#characters_to_nfkc_list/1","title":"unicode.characters_to_nfkc_list/1","type":"function","doc":"Converts a possibly deep list of characters and binaries into a Normalized Form of compatibly equivalent Composed characters according to the Unicode standard. Any binaries in the input must be encoded with utf8 encoding. The result is a list of characters. 3&gt; unicode:characters_to_nfkc_list([&lt;&lt;&quot;abc..a&quot;&gt;&gt;,[778],$a,[776],$o,[776],[65299,65298]]). &quot;abc..32&quot;"},{"ref":"unicode.html#characters_to_nfkd_binary/1","title":"unicode.characters_to_nfkd_binary/1","type":"function","doc":"Converts a possibly deep list of characters and binaries into a Normalized Form of compatibly equivalent Decomposed characters according to the Unicode standard. Any binaries in the input must be encoded with utf8 encoding. The result is an utf8 encoded binary. 2&gt; unicode:characters_to_nfkd_binary([&quot;abc..&quot;,[65299,65298]]). &lt;&lt;97,98,99,46,46,97,204,138,97,204,136,111,204,136,51,50&gt;&gt;"},{"ref":"unicode.html#characters_to_nfkd_list/1","title":"unicode.characters_to_nfkd_list/1","type":"function","doc":"Converts a possibly deep list of characters and binaries into a Normalized Form of compatibly equivalent Decomposed characters according to the Unicode standard. Any binaries in the input must be encoded with utf8 encoding. The result is a list of characters. 1&gt; unicode:characters_to_nfkd_list([&quot;abc..&quot;,[65299,65298]]). [97,98,99,46,46,97,778,97,776,111,776,51,50]"},{"ref":"unicode.html#encoding_to_bom/1","title":"unicode.encoding_to_bom/1","type":"function","doc":"Creates a UTF Byte Order Mark (BOM) as a binary from the supplied InEncoding. The BOM is, if supported at all, expected to be placed first in UTF encoded files or messages. The function returns &lt;&lt;&gt;&gt; for latin1 encoding, as there is no BOM for ISO Latin-1. Notice that the BOM for UTF-8 is seldom used, and it is really not a byte order mark. There are obviously no byte order issues with UTF-8, so the BOM is only there to differentiate UTF-8 encoding from other UTF formats."},{"ref":"uri_string.html","title":"uri_string","type":"module","doc":"This module contains functions for parsing and handling URIs (RFC 3986) and form-urlencoded query strings (HTML 5.2). Parsing and serializing non-UTF-8 form-urlencoded query strings are also supported (HTML 5.0). A URI is an identifier consisting of a sequence of characters matching the syntax rule named URI in RFC 3986. The generic URI syntax consists of a hierarchical sequence of components referred to as the scheme, authority, path, query, and fragment: URI = scheme &quot;:&quot; hier-part [ &quot;?&quot; query ] [ &quot;#&quot; fragment ] hier-part = &quot;//&quot; authority path-abempty / path-absolute / path-rootless / path-empty scheme = ALPHA *( ALPHA / DIGIT / &quot;+&quot; / &quot;-&quot; / &quot;.&quot; ) authority = [ userinfo &quot;@&quot; ] host [ &quot;:&quot; port ] userinfo = *( unreserved / pct-encoded / sub-delims / &quot;:&quot; ) reserved = gen-delims / sub-delims gen-delims = &quot;:&quot; / &quot;/&quot; / &quot;?&quot; / &quot;#&quot; / &quot;[&quot; / &quot;]&quot; / &quot;@&quot; sub-delims = &quot;!&quot; / &quot;$&quot; / &quot;&amp;&quot; / &quot;&#39;&quot; / &quot;(&quot; / &quot;)&quot; / &quot;*&quot; / &quot;+&quot; / &quot;,&quot; / &quot;;&quot; / &quot;=&quot; unreserved = ALPHA / DIGIT / &quot;-&quot; / &quot;.&quot; / &quot;_&quot; / &quot;~&quot; The interpretation of a URI depends only on the characters used and not on how those characters are represented in a network protocol. The functions implemented by this module cover the following use cases: * Parsing URIs into its components and returing a map [`parse/1`](#parse/1) * Recomposing a map of URI components into a URI string [`recompose/1`](#recompose/1) * Changing inbound binary and percent-encoding of URIs [`transcode/2`](#transcode/2) * Transforming URIs into a normalized form [`normalize/1`](#normalize/1) [`normalize/2`](#normalize/2) * Composing form-urlencoded query strings from a list of key-value pairs [`compose_query/1`](#compose_query/1) [`compose_query/2`](#compose_query/2) * Dissecting form-urlencoded query strings into a list of key-value pairs [`dissect_query/1`](#dissect_query/1) There are four different encodings present during the handling of URIs: * Inbound binary encoding in binaries * Inbound percent-encoding in lists and binaries * Outbound binary encoding in binaries * Outbound percent-encoding in lists and binaries Functions with `uri_string()` argument accept lists, binaries and mixed lists (lists with binary elements) as input type. All of the functions but [`transcode/2`](#transcode/2) expects input as lists of unicode codepoints, UTF-8 encoded binaries and UTF-8 percent-encoded URI parts (&quot;%C3%B6&quot; corresponds to the unicode character &quot;&quot;). Unless otherwise specified the return value type and encoding are the same as the input type and encoding. That is, binary input returns binary output, list input returns a list output but mixed input returns list output. In case of lists there is only percent-encoding. In binaries, however, both binary encoding and percent-encoding shall be considered. transcode/2 provides the means to convert between the supported encodings, it takes a uri_string() and a list of options specifying inbound and outbound encodings. RFC 3986 does not mandate any specific character encoding and it is usually defined by the protocol or surrounding text. This library takes the same assumption, binary and percent-encoding are handled as one configuration unit, they cannot be set to different values."},{"ref":"uri_string.html#compose_query/1","title":"uri_string.compose_query/1","type":"function","doc":"Composes a form-urlencoded QueryString based on a QueryList, a list of non-percent-encoded key-value pairs. Form-urlencoding is defined in section 4.10.21.6 of the HTML 5.2 specification and in section 4.10.22.6 of the HTML 5.0 specification for non-UTF-8 encodings. See also the opposite operation dissect_query/1. Example: 1&gt; uri_string:compose_query([{&quot;foo bar&quot;,&quot;1&quot;},{&quot;city&quot;,&quot;rebro&quot;}]). &quot;foo+bar=1&amp;city=%C3%B6rebro&quot; 2&gt; uri_string:compose_query([{&lt;&lt;&quot;foo bar&quot;&gt;&gt;,&lt;&lt;&quot;1&quot;&gt;&gt;}, 2&gt; {&lt;&lt;&quot;city&quot;&gt;&gt;,&lt;&lt;&quot;rebro&quot;/utf8&gt;&gt;}]). &lt;&lt;&quot;foo+bar=1&amp;city=%C3%B6rebro&quot;&gt;&gt;"},{"ref":"uri_string.html#compose_query/2","title":"uri_string.compose_query/2","type":"function","doc":"Same as compose_query/1 but with an additional Options parameter, that controls the encoding (&quot;charset&quot;) used by the encoding algorithm. There are two supported encodings: utf8 (or unicode) and latin1. Each character in the entry&#39;s name and value that cannot be expressed using the selected character encoding, is replaced by a string consisting of a U+0026 AMPERSAND character (&amp;), a &quot;#&quot; (U+0023) character, one or more ASCII digits representing the Unicode code point of the character in base ten, and finally a &quot;;&quot; (U+003B) character. Bytes that are out of the range 0x2A, 0x2D, 0x2E, 0x30 to 0x39, 0x41 to 0x5A, 0x5F, 0x61 to 0x7A, are percent-encoded (U+0025 PERCENT SIGN character (%) followed by uppercase ASCII hex digits representing the hexadecimal value of the byte). See also the opposite operation dissect_query/1. Example: 1&gt; uri_string:compose_query([{&quot;foo bar&quot;,&quot;1&quot;},{&quot;city&quot;,&quot;rebro&quot;}], 1&gt; [{encoding, latin1}]). &quot;foo+bar=1&amp;city=%F6rebro&quot; 2&gt; uri_string:compose_query([{&lt;&lt;&quot;foo bar&quot;&gt;&gt;,&lt;&lt;&quot;1&quot;&gt;&gt;}, 2&gt; {&lt;&lt;&quot;city&quot;&gt;&gt;,&lt;&lt;&quot;&quot;/utf8&gt;&gt;}], [{encoding, latin1}]). &lt;&lt;&quot;foo+bar=1&amp;city=%26%2326481%3B%26%2320140%3B&quot;&gt;&gt;"},{"ref":"uri_string.html#dissect_query/1","title":"uri_string.dissect_query/1","type":"function","doc":"Dissects an urlencoded QueryString and returns a QueryList, a list of non-percent-encoded key-value pairs. Form-urlencoding is defined in section 4.10.21.6 of the HTML 5.2 specification and in section 4.10.22.6 of the HTML 5.0 specification for non-UTF-8 encodings. See also the opposite operation compose_query/1. Example: 1&gt; uri_string:dissect_query(&quot;foo+bar=1&amp;city=%C3%B6rebro&quot;). [{&quot;foo bar&quot;,&quot;1&quot;},{&quot;city&quot;,&quot;rebro&quot;}] 2&gt; uri_string:dissect_query(&lt;&lt;&quot;foo+bar=1&amp;city=%26%2326481%3B%26%2320140%3B&quot;&gt;&gt;). [{&lt;&lt;&quot;foo bar&quot;&gt;&gt;,&lt;&lt;&quot;1&quot;&gt;&gt;}, {&lt;&lt;&quot;city&quot;&gt;&gt;,&lt;&lt;230,157,177,228,186,172&gt;&gt;}]"},{"ref":"uri_string.html#normalize/1","title":"uri_string.normalize/1","type":"function","doc":"Transforms an URI into a normalized form using Syntax-Based Normalization as defined by RFC 3986. This function implements case normalization, percent-encoding normalization, path segment normalization and scheme based normalization for HTTP(S) with basic support for FTP, SSH, SFTP and TFTP. Example: 1&gt; uri_string:normalize(&quot;/a/b/c/./../../g&quot;). &quot;/a/g&quot; 2&gt; uri_string:normalize(&lt;&lt;&quot;mid/content=5/../6&quot;&gt;&gt;). &lt;&lt;&quot;mid/6&quot;&gt;&gt; 3&gt; uri_string:normalize(&quot;http://localhost:80&quot;). &quot;https://localhost/&quot; 4&gt; uri_string:normalize(\#{scheme =&gt; &quot;http&quot;,port =&gt; 80,path =&gt; &quot;/a/b/c/./../../g&quot;, 4&gt; host =&gt; &quot;localhost-rebro&quot;}). &quot;http://localhost-%C3%B6rebro/a/g&quot;"},{"ref":"uri_string.html#normalize/2","title":"uri_string.normalize/2","type":"function","doc":"Same as normalize/1 but with an additional Options parameter, that controls if the normalized URI shall be returned as an uri_map(). There is one supported option: return_map. Example: 1&gt; uri_string:normalize(&quot;/a/b/c/./../../g&quot;, [return_map]). \#{path =&gt; &quot;/a/g&quot;} 2&gt; uri_string:normalize(&lt;&lt;&quot;mid/content=5/../6&quot;&gt;&gt;, [return_map]). \#{path =&gt; &lt;&lt;&quot;mid/6&quot;&gt;&gt;} 3&gt; uri_string:normalize(&quot;http://localhost:80&quot;, [return_map]). \#{scheme =&gt; &quot;http&quot;,path =&gt; &quot;/&quot;,host =&gt; &quot;localhost&quot;} 4&gt; uri_string:normalize(\#{scheme =&gt; &quot;http&quot;,port =&gt; 80,path =&gt; &quot;/a/b/c/./../../g&quot;, 4&gt; host =&gt; &quot;localhost-rebro&quot;}, [return_map]). \#{scheme =&gt; &quot;http&quot;,path =&gt; &quot;/a/g&quot;,host =&gt; &quot;localhost-rebro&quot;}"},{"ref":"uri_string.html#parse/1","title":"uri_string.parse/1","type":"function","doc":"Parses an RFC 3986 compliant uri_string() into a uri_map(), that holds the parsed components of the URI. If parsing fails, an error tuple is returned. See also the opposite operation recompose/1. Example: 1&gt; uri_string:parse(&quot;foo://user@example.com:8042/over/there?name=ferret#nose&quot;). \#{fragment =&gt; &quot;nose&quot;,host =&gt; &quot;example.com&quot;, path =&gt; &quot;/over/there&quot;,port =&gt; 8042,query =&gt; &quot;name=ferret&quot;, scheme =&gt; foo,userinfo =&gt; &quot;user&quot;} 2&gt; uri_string:parse(&lt;&lt;&quot;foo://user@example.com:8042/over/there?name=ferret&quot;&gt;&gt;). \#{host =&gt; &lt;&lt;&quot;example.com&quot;&gt;&gt;,path =&gt; &lt;&lt;&quot;/over/there&quot;&gt;&gt;, port =&gt; 8042,query =&gt; &lt;&lt;&quot;name=ferret&quot;&gt;&gt;,scheme =&gt; &lt;&lt;&quot;foo&quot;&gt;&gt;, userinfo =&gt; &lt;&lt;&quot;user&quot;&gt;&gt;}"},{"ref":"uri_string.html#recompose/1","title":"uri_string.recompose/1","type":"function","doc":"Creates an RFC 3986 compliant URIString (percent-encoded), based on the components of URIMap. If the URIMap is invalid, an error tuple is returned. See also the opposite operation parse/1. Example: 1&gt; URIMap = \#{fragment =&gt; &quot;nose&quot;, host =&gt; &quot;example.com&quot;, path =&gt; &quot;/over/there&quot;, 1&gt; port =&gt; 8042, query =&gt; &quot;name=ferret&quot;, scheme =&gt; &quot;foo&quot;, userinfo =&gt; &quot;user&quot;}. \#{fragment =&gt; &quot;top&quot;,host =&gt; &quot;example.com&quot;, path =&gt; &quot;/over/there&quot;,port =&gt; 8042,query =&gt; &quot;?name=ferret&quot;, scheme =&gt; foo,userinfo =&gt; &quot;user&quot;} 2&gt; uri_string:recompose(URIMap). &quot;foo://example.com:8042/over/there?name=ferret#nose&quot;"},{"ref":"uri_string.html#transcode/2","title":"uri_string.transcode/2","type":"function","doc":"Transcodes an RFC 3986 compliant URIString, where Options is a list of tagged tuples, specifying the inbound (in_encoding) and outbound (out_encoding) encodings. in_encoding and out_encoding specifies both binary encoding and percent-encoding for the input and output data. Mixed encoding, where binary encoding is not the same as percent-encoding, is not supported. If an argument is invalid, an error tuple is returned. Example: 1&gt; uri_string:transcode(&lt;&lt;&quot;foo%00%00%00%F6bar&quot;/utf32&gt;&gt;, 1&gt; [{in_encoding, utf32},{out_encoding, utf8}]). &lt;&lt;&quot;foo%C3%B6bar&quot;/utf8&gt;&gt; 2&gt; uri_string:transcode(&quot;foo%F6bar&quot;, [{in_encoding, latin1}, 2&gt; {out_encoding, utf8}]). &quot;foo%C3%B6bar&quot;"},{"ref":"win32reg.html","title":"win32reg","type":"module","doc":"This module provides read and write access to the registry on Windows. It is essentially a port driver wrapped around the Win32 API calls for accessing the registry. The registry is a hierarchical database, used to store various system and software information in Windows. It contains installation data, and is updated by installers and system programs. The Erlang installer updates the registry by adding data that Erlang needs. The registry contains keys and values. Keys are like the directories in a file system, they form a hierarchy. Values are like files, they have a name and a value, and also a type. Paths to keys are left to right, with subkeys to the right and backslash between keys. (Remember that backslashes must be doubled in Erlang strings.) Case is preserved but not significant. For example, &quot;\\\\hkey_local_machine\\\\software\\\\Ericsson\\\\Erlang\\\\5.0&quot; is the key for the installation data for the latest Erlang release. There are six entry points in the Windows registry, top-level keys. They can be abbreviated in this module as follows: Abbreviation Registry key ============ ============ hkcr HKEY_CLASSES_ROOT current_user HKEY_CURRENT_USER hkcu HKEY_CURRENT_USER local_machine HKEY_LOCAL_MACHINE hklm HKEY_LOCAL_MACHINE users HKEY_USERS hku HKEY_USERS current_config HKEY_CURRENT_CONFIG hkcc HKEY_CURRENT_CONFIG dyn_data HKEY_DYN_DATA hkdd HKEY_DYN_DATA The key above can be written as &quot;\\\\hklm\\\\software\\\\ericsson\\\\erlang\\\\5.0&quot;. This module uses a current key. It works much like the current directory. From the current key, values can be fetched, subkeys can be listed, and so on. Under a key, any number of named values can be stored. They have names, types, and data. win32reg supports storing of the following types: * `REG_DWORD`, which is an integer * `REG_SZ`, which is a string * `REG_BINARY`, which is a binary Other types can be read, and are returned as binaries. There is also a &quot;default&quot; value, which has the empty string as name. It is read and written with the atom default instead of the name. Some registry values are stored as strings with references to environment variables, for example, %SystemRoot%Windows. SystemRoot is an environment variable, and is to be replaced with its value. Function expand/1 is provided so that environment variables surrounded by % can be expanded to their values. For more information on the Windows registry, see consult the Win32 Programmer&#39;s Reference."},{"ref":"win32reg.html#change_key/2","title":"win32reg.change_key/2","type":"function","doc":"Changes the current key to another key. Works like cd. The key can be specified as a relative path or as an absolute path, starting with \\."},{"ref":"win32reg.html#change_key_create/2","title":"win32reg.change_key_create/2","type":"function","doc":"Creates a key, or just changes to it, if it is already there. Works like a combination of mkdir and cd. Calls the Win32 API function RegCreateKeyEx(). The registry must have been opened in write mode."},{"ref":"win32reg.html#close/1","title":"win32reg.close/1","type":"function","doc":"Closes the registry. After that, the RegHandle cannot be used."},{"ref":"win32reg.html#current_key/1","title":"win32reg.current_key/1","type":"function","doc":"Returns the path to the current key. This is the equivalent of pwd. Notice that the current key is stored in the driver, and can be invalid (for example, if the key has been removed)."},{"ref":"win32reg.html#delete_key/1","title":"win32reg.delete_key/1","type":"function","doc":"Deletes the current key, if it is valid. Calls the Win32 API function RegDeleteKey(). Notice that this call does not change the current key (unlike change_key_create/2). This means that after the call, the current key is invalid."},{"ref":"win32reg.html#delete_value/2","title":"win32reg.delete_value/2","type":"function","doc":"Deletes a named value on the current key. The atom default is used for the default value. The registry must have been opened in write mode."},{"ref":"win32reg.html#expand/1","title":"win32reg.expand/1","type":"function","doc":"Expands a string containing environment variables between percent characters. Anything between two % is taken for an environment variable, and is replaced by the value. Two consecutive % are replaced by one %. A variable name that is not in the environment results in an error."},{"ref":"win32reg.html#format_error/1","title":"win32reg.format_error/1","type":"function","doc":"Converts a POSIX error code to a string (by calling erl_posix_msg:message/1)."},{"ref":"win32reg.html#open/1","title":"win32reg.open/1","type":"function","doc":"Opens the registry for reading or writing. The current key is the root (HKEY_CLASSES_ROOT). Flag read in the mode list can be omitted. Use change_key/2 with an absolute path after open."},{"ref":"win32reg.html#set_value/3","title":"win32reg.set_value/3","type":"function","doc":"Sets the named (or default) value to value. Calls the Win32 API function RegSetValueEx(). The value can be of three types, and the corresponding registry type is used. The supported types are the following: * `REG_DWORD` for integers * `REG_SZ` for strings * `REG_BINARY` for binaries Other types cannot be added or changed. The registry must have been opened in write mode."},{"ref":"win32reg.html#sub_keys/1","title":"win32reg.sub_keys/1","type":"function","doc":"Returns a list of subkeys to the current key. Calls the Win32 API function EnumRegKeysEx(). Avoid calling this on the root keys, as it can be slow."},{"ref":"win32reg.html#value/2","title":"win32reg.value/2","type":"function","doc":"Retrieves the named value (or default) on the current key. Registry values of type REG_SZ are returned as strings. Type REG_DWORD values are returned as integers. All other types are returned as binaries."},{"ref":"win32reg.html#values/1","title":"win32reg.values/1","type":"function","doc":"Retrieves a list of all values on the current key. The values have types corresponding to the registry types, see value/2. Calls the Win32 API function EnumRegValuesEx()."},{"ref":"zip.html","title":"zip","type":"module","doc":"This module archives and extracts files to and from a zip archive. The zip format is specified by the &quot;ZIP Appnote.txt&quot; file, available on the PKWARE web site www.pkware.com. The zip module supports zip archive versions up to 6.1. However, password-protection and Zip64 are not supported. By convention, the name of a zip file is to end with .zip. To abide to the convention, add .zip to the filename. * To create zip archives, use function `zip/2` or `zip/3`. They are also available as `create/2,3`, to resemble the `erl_tar` module. * To extract files from a zip archive, use function `unzip/1` or `unzip/2`. They are also available as `extract/1,2`, to resemble the `erl_tar` module. * To fold a function over all files in a zip archive, use function [`foldl/3`](#foldl/3). * To return a list of the files in a zip archive, use function `list_dir/1` or `list_dir/2`. They are also available as `table/1,2`, to resemble the `erl_tar` module. * To print a list of files to the Erlang shell, use function [`t/1`](#t/1) or [`tt/1`](#tt/1). * Sometimes it is desirable to open a zip archive, and to unzip files from it file by file, without having to reopen the archive. This can be done by functions `zip_open/1,2`, `zip_get/1,2`, [`zip_list_dir/1`](#zip_list_dir/1), and [`zip_close/1`](#zip_close/1)."},{"ref":"zip.html#foldl/3","title":"zip.foldl/3","type":"function","doc":"Calls Fun``(``FileInArchive``, ``GetInfo ``, ``GetBin``, ``AccIn``) on successive files in the Archive, starting with AccIn`` == ``Acc0. FileInArchive is the name that the file has in the archive. GetInfo is a fun that returns information about the file. GetBin returns the file contents. Both GetInfo and GetBin must be called within the Fun. Their behavior is undefined if they are called outside the context of Fun. The Fun must return a new accumulator, which is passed to the next call. foldl/3 returns the final accumulator value. Acc0 is returned if the archive is empty. It is not necessary to iterate over all files in the archive. The iteration can be ended prematurely in a controlled manner by throwing an exception. Example: &gt; Name = &quot;dummy.zip&quot;. &quot;dummy.zip&quot; &gt; {ok, {Name, Bin}} = zip:create(Name, [{&quot;foo&quot;, &lt;&lt;&quot;FOO&quot;&gt;&gt;}, {&quot;bar&quot;, &lt;&lt;&quot;BAR&quot;&gt;&gt;}], [memory]). {ok,{&quot;dummy.zip&quot;, &lt;&lt;80,75,3,4,20,0,0,0,0,0,74,152,97,60,171,39,212,26,3,0, 0,0,3,0,0,...&gt;&gt;}} &gt; {ok, FileSpec} = zip:foldl(fun(N, I, B, Acc) -&gt; [{N, B(), I()} | Acc] end, [], {Name, Bin}). {ok,[{&quot;bar&quot;,&lt;&lt;&quot;BAR&quot;&gt;&gt;, {file_info,3,regular,read_write, {{2010,3,1},{19,2,10}}, {{2010,3,1},{19,2,10}}, {{2010,3,1},{19,2,10}}, 54,1,0,0,0,0,0}}, {&quot;foo&quot;,&lt;&lt;&quot;FOO&quot;&gt;&gt;, {file_info,3,regular,read_write, {{2010,3,1},{19,2,10}}, {{2010,3,1},{19,2,10}}, {{2010,3,1},{19,2,10}}, 54,1,0,0,0,0,0}}]} &gt; {ok, {Name, Bin}} = zip:create(Name, lists:reverse(FileSpec), [memory]). {ok,{&quot;dummy.zip&quot;, &lt;&lt;80,75,3,4,20,0,0,0,0,0,74,152,97,60,171,39,212,26,3,0, 0,0,3,0,0,...&gt;&gt;}} &gt; catch zip:foldl(fun(&quot;foo&quot;, _, B, _) -&gt; throw(B()); (_,_,_,Acc) -&gt; Acc end, [], {Name, Bin}). &lt;&lt;&quot;FOO&quot;&gt;&gt;"},{"ref":"zip.html#list_dirlist_dirtabletable/1212","title":"zip.list_dirlist_dirtabletable/1212","type":"function","doc":"list_dir/1 retrieves all filenames in the zip archive Archive. list_dir/2 provides options. table/1 and table/2 are provided as synonyms to resemble the erl_tar module. The result value is the tuple {ok, List}, where List contains the zip archive comment as the first element. One option is available: cooked * By default, this function opens the zip file in raw mode, which is faster but does not allow a remote (Erlang) file server to be used. Adding cooked to the mode list overrides the default and opens the zip file without option raw."},{"ref":"zip.html#t/1","title":"zip.t/1","type":"function","doc":"Prints all filenames in the zip archive Archive to the Erlang shell. (Similar to tart.)"},{"ref":"zip.html#tt/1","title":"zip.tt/1","type":"function","doc":"Prints filenames and information about all files in the zip archive Archive to the Erlang shell. (Similar to tar tv.)"},{"ref":"zip.html#unzipunzipextractextract/1212","title":"zip.unzipunzipextractextract/1212","type":"function","doc":"unzip/1 extracts all files from a zip archive. unzip/2 provides options to extract some files, and more. extract/1 and extract/2 are provided as synonyms to resemble module erl_tar. If argument Archive is specified as a binary, the contents of the binary is assumed to be a zip archive, otherwise a filename. Options: {file_list, ``FileList``} * By default, all files are extracted from the zip archive. With option {file_list, ``FileList``}, function unzip/2 only extracts the files whose names are included in FileList. The full paths, including the names of all subdirectories within the zip archive, must be specified. cooked * By default, this function opens the zip file in raw mode, which is faster but does not allow a remote (Erlang) file server to be used. Adding cooked to the mode list overrides the default and opens the zip file without option raw. The same applies for the files extracted. keep_old_files * By default, all files with the same name as files in the zip archive are overwritten. With option keep_old_files set, function unzip/2 does not overwrite existing files. Notice that even with option memory specified, which means that no files are overwritten, existing files are excluded from the result. verbose * Prints an informational message for each extracted file. memory * Instead of extracting to the current directory, the result is given as a list of tuples {Filename, Binary}, where Binary is a binary containing the extracted data of file Filename in the zip archive. {cwd, CWD} * Uses the specified directory as current directory. It is prepended to filenames when extracting them from the zip archive. (Acting like file:set_cwd/1 in Kernel, but without changing the global cwd property.)"},{"ref":"zip.html#zip_close/1","title":"zip.zip_close/1","type":"function","doc":"Closes a zip archive, previously opened with zip_open/1,2. All resources are closed, and the handle is not to be used after closing."},{"ref":"zip.html#zip_getzip_get/12","title":"zip.zip_getzip_get/12","type":"function","doc":"Extracts one or all files from an open archive. The files are unzipped to memory or to file, depending on the options specified to function zip_open/1,2 when opening the archive."},{"ref":"zip.html#zip_list_dir/1","title":"zip.zip_list_dir/1","type":"function","doc":"Returns the file list of an open zip archive. The first returned element is the zip archive comment."},{"ref":"zip.html#zip_openzip_open/12","title":"zip.zip_openzip_open/12","type":"function","doc":"Opens a zip archive, and reads and saves its directory. This means that later reading files from the archive is faster than unzipping files one at a time with unzip/1,2. The archive must be closed with zip_close/1. The ZipHandle is closed if the process that originally opened the archive dies."},{"ref":"zip.html#zipzipcreatecreate/2323","title":"zip.zipzipcreatecreate/2323","type":"function","doc":"Creates a zip archive containing the files specified in FileList. create/2 and create/3 are provided as synonyms to resemble module erl_tar. FileList is a list of files, with paths relative to the current directory, which are stored with this path in the archive. Files can also be specified with data in binaries to create an archive directly from data. Files are compressed using the DEFLATE compression, as described in the &quot;Appnote.txt&quot; file. However, files are stored without compression if they are already compressed. zip/2 and zip/3 check the file extension to determine if the file is to be stored without compression. Files with the following extensions are not compressed: .Z, .zip, .zoo, .arc, .lzh, .arj. It is possible to override the default behavior and control what types of files that are to be compressed by using options {compress, ``What``} and {uncompress, ``What``}. It is also possible to use many compress and uncompress options. To trigger file compression, its extension must match with the compress condition and must not match the uncompress condition. For example, if compress is set to [&quot;gif&quot;, &quot;jpg&quot;] and uncompress is set to [&quot;jpg&quot;], only files with extension &quot;gif&quot; are compressed. Options: cooked * By default, this function opens the zip file in mode raw, which is faster but does not allow a remote (Erlang) file server to be used. Adding cooked to the mode list overrides the default and opens the zip file without the raw option. The same applies for the files added. verbose * Prints an informational message about each added file. memory * The output is not to a file, but instead as a tuple {``FileName``, binary()}. The binary is a full zip archive with header and can be extracted with, for example, unzip/2. {comment, ``Comment``} * Adds a comment to the zip archive. {cwd, ``CWD``} * Uses the specified directory as current work directory (cwd). This is prepended to filenames when adding them, although not in the zip archive (acting like file:set_cwd/1 in Kernel, but without changing the global cwd property.). {compress, ``What``} * Controls what types of files to be compressed. Defaults to all. The following values of What are allowed: all * All files are compressed (as long as they pass the uncompress condition). [``Extension``] * Only files with exactly these extensions are compressed. {add,[``Extension``]} * Adds these extensions to the list of compress extensions. {del,[``Extension``]} * Deletes these extensions from the list of compress extensions. `{uncompress, ``What``}` * Controls what types of files to be uncompressed. Defaults to `[&quot;.Z&quot;, &quot;.zip&quot;, &quot;.zoo&quot;, &quot;.arc&quot;, &quot;.lzh&quot;, &quot;.arj&quot;]`. The following values of `What` are allowed: all * No files are compressed. [``Extension``] * Files with these extensions are uncompressed. {add,[``Extension``]} * Adds these extensions to the list of uncompress extensions. {del,[``Extension``]} * Deletes these extensions from the list of uncompress extensions."}]